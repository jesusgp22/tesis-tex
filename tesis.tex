\documentclass[12pt,oneside]{book}

\usepackage{ulamonog} % formato para la propuesta o proyecto de grado
\usepackage[ansinew]{inputenc} % escribir acentos
\setcounter{secnumdepth}{3}


%\usepackage[activeacute,spanish]{babel}
\usepackage{float}
\usepackage{placeins}
\usepackage{color}
\usepackage[colorlinks]{hyperref}
\usepackage[table,xcdraw]{xcolor}
\usepackage{multirow}
\usepackage{colortbl}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\definecolor{light-gray}{gray}{0.95}
\usepackage{listings}
\usepackage{enumitem}
\usepackage{longtable}
\definecolor{LightRed}{rgb}{1,0.3,0.3}
\definecolor{LightGreen}{rgb}{0,1.66,0.29}


% ***************************************************************** %
% En el siguiente comando se pueden modificar:
% Titulo, Autor, Palabras clave
% ***************************************************************** %

% si se va a imprimir,
% se incluye al final despues de citecolor=blue, el comando draft=true
% Las siguientes son propiedades del pdf, mï¿½s no cambian nada dentro del
% texto de la monografï¿½a
\hypersetup{pdftitle={Propuesta de Tesis},
pdfauthor={Jesús Gómez},
pdfsubject={Propuesta de Proyecto de Grado}, % se deja igual (se cambia para el proyecto de grado)
pdfkeywords={ Monitoreo de redes, Calidad de servicio, Big Data, Benchmarking, Cloud}, pdfstartview=FitH,
bookmarks=true, citecolor=blue}%, draft=true}

% ***************************************************************** %
% FIN DE
% Titulo, Autor, Palabras clave
% ***************************************************************** %

% Si desea que no aparezca la lista de tablas o figuras descomente las siguientes lineas
\nolistoftables
\nolistoffigures

%\usepackage{natbib}

\sloppy

\begin{document}

\frontmatter


% ***************************************************************** %
% Portada y resumen
% ***************************************************************** %

% Si desea que el logo de la ULA aparezca en la parte superior,
% descomente la siguiente lï¿½nea. Por defecto aparece en la parte inferior
\logoarriba{}

% Aï¿½o en el cual se entrega el proyecto de grado o la propuesta
\copyrightyear{2015}

% Al final cuando hayan presentado, sin comentar,
% deberia ser el nï¿½mero de tesis presentada y la opciï¿½n, IO por ejemplo
% (Actualmente, 11-03-08, no se estï¿½ trabajando con esta metodologï¿½a de llevar un
% nï¿½mero de proyecto para las tesis, por lo cual debe ir comentado)
%\numproy{00IO}

% En caso de hacer la propuesta, descomente la siguiente
% instrucciï¿½n. Para el Proyecto de Grado debe comentarse. Modifica
% tanto la categorï¿½a de la monografï¿½a, como la apariciï¿½n de
% "Presentado ante la ilustre Universidad de Los Andes
% como requisito parcial para obtener el Tï¿½tulo de" en la portada
%\tipomonografia{Propuesta de Proyecto de Gradooo}


% Tï¿½tulo de la monografï¿½a, el cual saldrï¿½ en la portada
\title{Diseño e implementación de un sistema de monitoreo de redes orientado a la recolección masiva de datos.}

% Autor de la monografï¿½a, el cual saldrï¿½ en la portada
 \author{Jesús Alberto Gómez Pérez}

% La fechaentrega, presentaciondia, presentacionlugar
% y mencionespecial, es para aquel caso en el cual se
% vaya a utilizar la hoja del veredicto en el formato
% que se presenta aquï¿½. El primerjurado, segundojurado,
% y cedula, son campos que pueden llenarse, pero sï¿½lo
% aparecerï¿½n si se utiliza la pï¿½gina del veredicto

% Cï¿½dula del autor de la monografï¿½a
 \cedula{XX.XXX.XXX}

% Tutor del Proyecto de Grado
 \tutor{Dr. Andrés Arcia-Moret}

% Cualquiera de los instructores que aparecen a continuaciï¿½n
% pueden comentarse o descomentarse segï¿½n sea el caso:

%%% Cotutor del Proyecto de Grado
% \cotutor{Dra. propuesta}
% \cotutordos{Dra. propuesta dos}
%%% Asesor del Proyecto de Grado
% \asesor{Dr. Asesor}
%%% Asesor Industrial del Proyecto de Grado
% \asesorindustrial{Dr. Asesor Industrial}
%%% Tutor Industrial del Proyecto de Grado
% \tutorindustrial{Dr. Tutor Industrial}
%%% Jurados del Proyecto de Grado
 \primerjurado{Dr. Primer Profesor}
 \segundojurado{Prof. Segundo Profesor}

% ***************************************************************** %
% Si sabe la fecha de presentaciï¿½n
%
% con o sin comentar
% (Esta hoja es un formato para asentar la nota del proyecto de grado;
% sin embargo, la hoja que se utiliza para ese fin, se busca en la escuela
% dï¿½as antes de la presentaciï¿½n)
% ***************************************************************** %
%\fechaentrega{Diciembre 2006} % Si sabe cuando se presentï¿½
%\presentaciondia{7 de Diciembre de 2005} % si conoce exactamente el dï¿½a
%\presentacionlugar{Salï¿½n de reuniones EISULA} % si conoce exactamente el lugar donde se presentï¿½
% ***************************************************************** %
% FIN DE
% Si sabe la fecha de presentaciï¿½n
% ***************************************************************** %


% ***************************************************************** %
% Si tiene mencion especial
% con o sin comentar
% ***************************************************************** %
%\mencionespecial{Este proyecto fue seleccionado como \textbf{mejor
%proyecto de grado} de la Escuela de Ingenierï¿½a de Sistemas, en el
%IC aniversario de la Facultad de Ingenierï¿½a.} % si tiene menciï¿½n especial
% (El texto puede cambiarse \mencionespecial{*********} segï¿½n corresponda
% ***************************************************************** %
% FIN DE
% Si tiene mencion especial
% con o sin comentar
% ***************************************************************** %

% NO TOCAR si es Ingenieria de Sistemas
% \grado{Ingeniero Quï¿½mico} % por defecto Ingeniero de Sistemas

%\signaturepage ----- NO TOCAR

%%%%%OJO%%%%%Arreglen esto segï¿½n su opciï¿½n
% Si es control y automatizacion se comentan las siguientes lï¿½neas. Si es de
% Sistemas Computacionales comenta la tercera. De Investigaciï¿½n de Operaciones
% comenta la segunda
\opcion{Sistemas Computacionales}
% \opcion{Investigaciï¿½n de Operaciones}

% Aquï¿½ se escribe el resumen de la monografía
\resumen{En el presente proyecto se plantea el desarrollo de un sistema de monitoreo distribuido de enlaces de redes a través de un servicio web centralizado. Este servicio además hace énfasis en la visualización de los datos recolectados a partir de pruebas periódicas. El sistema está planteado como una herramienta para facilitar el entendimiento del funcionamiento de la red y ofrecer una solucion de poco impacto computacional, de bajo costo y que pueda operar en componentes de hardware desatendidos.}

% Aquï¿½ se escriben las palabras claves de la monografï¿½a
\descriptores{Monitoreo de redes, Calidad de servicio, Big Data, Benchmarking, Cloud}

% Esto es para que salga la cota en la hoja del resumen. Actualmente,
% 11-03-08, en la Escuela de Ingenierï¿½a de Sistemas no es necesario
% buscar la cota previamente, sino que el Proyecto de Grado se entrega
% en la Escuela sin cota.
%\cota{IXD A01.1}

% Si desea eliminar la frase "Este trabajo fue procesado en LATEX"
% del resumen, descomente la siguiente lï¿½nea
\sinlatex{}

% ***************************************************************** %
% FIN DE
% Portada y resumen
% ***************************************************************** %


% ***************************************************************** %
% Si tiene dedicatoria
% con o sin comentar
% ***************************************************************** %
%\dedicatoria{A todos los amados seres\\ cuando son dos lï¿½neas o mï¿½s}
% ***************************************************************** %
% FIN DE
% Si tiene dedicatoria
% ***************************************************************** %

\beforepreface

% ***************************************************************** %
% Agradecimientos y capï¿½tulos NO numerados
% ***************************************************************** %

%\prefacesection{Agradecimientos}
% Aï¿½n no hay agradecimientos

%%% Capitulo sin numero, antes de la pagina 1

%\prefacesection{Introducciï¿½n}
% Este es un ejemplo de una secciï¿½n no numerada.


% ***************************************************************** %
% FIN DE
% Agradecimientos y capï¿½tulos NO numerados
% ***************************************************************** %

\afterpreface

\pagestyle{fancyplain}
\renewcommand{\chaptermark}[1]{\markboth{#1}{\textsc{\footnotesize\thechapter\ #1}}}
\renewcommand{\sectionmark}[1]{\markright{\textsc{\footnotesize\thesection\ #1}}}
\lhead[\fancyplain{}{\textsc{\footnotesize\thepage}}]%
{\fancyplain{}{\rightmark}}
\rhead[\fancyplain{}{\leftmark}]%
{\fancyplain{}{\textsc{\footnotesize\thepage}}} \cfoot{}

\mainmatter

% ***************************************************************** %
% Cuerpo
% ***************************************************************** %
% De aquï¿½ en adelante se desarrollan los capï¿½tulos numerados de la monografï¿½a

% ***************************************************************** %
% INICIO DE estructura tentativa de la Propuesta
% ***************************************************************** %

\chapter{Introducción}

Con el objetivo de proveer alternativas para el acceso a Internet a bajo costo se han popularizado despliegues de redes alternativos tales como las Redes Comunitarias\cite{gaia-alternative2015}. Estas redes consisten en arreglos interconectados de nodos mantenidos por la comunidad y para la comunidad, los interesados en formar parte de la red ofrecen su hardware y extienden la red, de manera que la red crece de forma orgánica y descentralizada. A pesar de que estos despliegues sean de bajo costo, descentralizadas, e incluso caóticos, los usuarios esperan una mínima calidad de servicio y velocidad de respuesta que les permita aprovechar tanto los servicios tradiciones de Internet así como servicios locales disponibles solo para los usuarios de la red comunitaria\cite{Octopus2015}. Tener un sistema de monitoreo de redes de bajo impacto sobre los recursos de red y de hardware disponibles y que ofrezca información sobre la red en tiempo real es crucial para ayudar a los interesados a detectar problemas y asegurar la calidad de servicio que los usuarios esperan.

Existen dos estrategias de monitoreo de redes: monitoreo activo o \textit{benchmarking} que consiste en generar tráfico para realizar medidas y comprobar la respuesta de la red, y monitoreo pasivo que consiste en escanear el tráfico de la red en ciertos puntos estratégicos para censar el tráfico en la red. El benchmarking tiene la desventaja de tener que inyectar tráfico lo cual puede entorpecer el funcionamiento normal de la red. Ejemplos de herramientas de benchmarking son \textit{ping}, \textit{iperf} y \textit{traceroute}.

El monitoreo pasivo tiene la ventaja de que nos puede dar una idea del uso de la red, sin embargo, para mayor efectividad debe realizarse en nodos intermedios a los que muchas veces no tenemos acceso. Ejemplos de herramientas de monitoreo pasivo son \textit{tcpdump}\footnote{tcpdump: http://www.tcpdump.org/} y \textit{wireshark}\footnote{Wireshark: https://www.wireshark.org/}; en ambos casos hay que resaltar que es difícil tener una imagen completa de la realidad de la red.

Uno de los trabajos más importantes en el área de monitoreo de redes es el Protocolo Simple de Administración de Red o SNMP (del inglés \textit{Simple Network Management Protocol}). Este emergió como una de las primeras soluciones al problema de manejo de redes y se ha convertido en la solución más ampliamente aceptada  debido a su diseño modular e independiente de productos o redes específicas. Así como plantea Kurose y Ross\cite{Kurose:13}, SNMP consiste de (1) un administrador de red, (2) una serie de dispositivos remotos monitoreados, (3) bases de información de administración (MIBs) en estos dispositivos, (4) agentes remotos que reportan la información de las MIBs al administrador de red y toman acciones si les indica, y, (5) un protocolo de comunicación entre los dispositivos.

SNMP no solo ofrece al administrador de red reportes sobre cada uno de los dispositivos administrados sino que también permite tomar acción sobre ellos proactivamente antes de que ocurran problemas o de forma reactiva para solucionar problemas cuando ocurren de forma inesperada.

%Este parrafo está descontextualizado
%La red de TVWS (TV White Spaces o Espacios blancos en el espectro radioeléctrico) de Malawi fue implementada en el marco de un proyecto para llevar Internet a áreas rurales en países en vías de desarrollo utilizando soluciones de bajo costo a través de los espacios en blanco en el espectro radioeléctrico específicamente en la banda UHF (siglas del inglés Ultra High Frequency, 'frecuencia ultra alta') \cite{Malawi:13}.

Las redes en zonas rurales como en el caso de la red de Malawi\cite{Malawi:13}, deben dejarse desatendidas durante largos periodos de tiempo ya que sus nodos son de difícil acceso o es muy costoso tener personal dedicado que se encargue del mantenimiento. Este escenario hace evidente la necesidad de una solución de monitoreo de redes a distancia y de dispositivos de mínimo mantenimiento. Además es atractivo para el centro de monitoreo de la red poder añadir, modificar o eliminar nodos de interés de manera sencilla a la interfaz de monitoreo.

Para intentar solucionar este problema y recolectar información sobre este tipo de redes, se propone un sistema en dos partes: un monitor de red instalado en la estación base (BS) y una aplicación web remota, el monitor en la estación base se conecta a cada uno de los nodos de la red y determina el tiempo de ida y vuelta (RTT por sus siglas en ingles) de forma automatizada en ciertos intervalos de tiempo, guarda los resultados en archivos y los coloca en una carpeta que se sincroniza a través de un servicio en la nube  de tipo PaaS (Plataforma como servicio) con el servidor web, que a su vez escanea la carpeta compartida y actualiza su base de datos que puede usarse para generar gráficas de RTT promedio y determinar tiempos de actividad continuos y porcentaje de disponibilidad de servicio \cite{MalawiNetMonitor:15}.

%A pesar de que este sistema recolecta información útil y presenta gráficas muy sencillas de entender, su programación no permite agregar nuevos nodos, esto trae como consecuencia que debe ser modificado manualmente cuando la red se expande, dando lugar a la necesidad de que el servicio web se pueda expandir para dar servicio a múltiples monitores remotos simultáneamente.

%Por estos motivos proponemos la construcción de un sistema de monitoreo a gran escala que llamaremos Octopus Monitor, para hacerlo totalmente configurable y robusto además de agregar una interfaz de configuración vía web que permita manejar usuarios, agregar monitores remotos, agregar nodos y modificar los parámetros de las pruebas, todo esto apoyándonos en un sistema de archivos compartidos a través de la nube.

%Mientras que  el mayor valor de Malawinet Monitor es la visualización de grandes volúmenes de datos  que se pueden obtener a partir de pruebas de bajo impacto de tráfico (ping, traceroute). 

Se han realizado otros trabajos en el área de monitoreo de redes como Bowlmap\cite{Bowlmap:12}; este es un sistema de monitoreo de redes a través de la visualización de mediciones para el Laboratorio Abierto Inalámbrico de Berlín (BOWL,  por sus siglas en ingles). Este sistema permite hacer ajustes en sus pruebas existentes, así como agregar pruebas nuevas y a su vez generar las visualizaciones necesarias para el análisis de dicha información.

Bowlmap permite la observación del estado de la red en tiempo real y minimiza el uso de recursos de red transmitiendo solo la información necesaria para cada actualización; es decir, que solo envía el estado completo de la red cuando un cliente comienza a observar y las siguientes actualizaciones solo contienen la descripción de los cambios que han ocurrido desde entonces.\cite{Bowlmap:12}.

Netradar\cite{sonntag2013netradar} es un sistema orientado a la evaluación de la calidad de redes de telefonía y e Internet inalámbrico. Este obtiene datos como la intensidad de la señal, velocidad de descarga, posición geográfica, y latencia a partir de pruebas realizadas en dispositivos móviles. Estos datos son usados para generar mapas de calor indicando la calidad del servicio por regiones y por proveedor de servicio.

Project Bismark\cite{sundaresan2014bismark} es un proyecto de monitoreo de redes con el objetivo de investigar el rendimiento de redes en hogares, el software de Bismark se instala en enrutadores y realiza mediciones regulares (benchmarks) y capturas del tráfico de la red. Los usuarios de Bismark pueden observar los datos sobre la latencia, ancho de banda y uso de la red a través de un panel de control disponible en linea.

Ripe Atlas\cite{ripe2010ripe} es otro proyecto de monitoreo de redes con el objetivo de obtener un mayor entendimiento del estado de Internet en tiempo real. Ripe Atlas recolecta datos a partir de mediciones realizadas en dispositivos especializados llamados \textit{probes} y \textit{anchors}. Los probes realizan mediciones para determinar la conectividad y alcanzabilidad con respecto a ciertos nodos de interés como servidores DNS o anchors. Los anchors son probes extendidos que ademas de ejecutar pruebas sirven como referencias regionales para la realización de mediciones. Los usuarios que colaboran alojando cualquiera de estos dispositivos pueden aprovechar toda la red de medición para realizar sus propias pruebas y observar todos los resultados obtenidos.

Tanto Netradar como Project Bismark y Ripe Atlas dependen de la colaboración de numerosos usuarios para la recolección masiva de datos. A mayor número de colaboradores es posible hacer análisis mas completos y detallados sobre el estado y calidad del servicio de Internet a nivel mundial. A cambio de su colaboración, los usuarios obtienen información valiosa sobre su propia red y pueden consultar los resultados públicos y comparar su rendimiento con respecto al total de datos disponibles.

\section{Planteamiento del Problema}

Las redes de computadoras se componen de un conjunto de nodos interconectados y generalmente no ofrecen garantías sobre el servicio que prestan. Algunas aplicaciones dependen de una alta disponibilidad y estabilidad de la red, por lo que es esencial para un administrador de red tener información del estado de la red para diagnosticar y solucionar problemas asegurando la calidad de servicio.

Otro caso de uso interesante corresponde al monitoreo de datos del estado de redes de bajo costo en las que fácilmente pueden ocurrir largas interrupciones de servicio. Así mismo, para un cliente de un servicio de alojamiento web desea saber si su sitio web está disponible y que tan rápido responde. Plataformas como Pingdom \cite{PINGDOM} o UptimeRobot \cite{UPTIMEROBOT} permiten monitorear distintos servicios en Internet y generan alertas cuando encuentran problemas, sin embargo no son gratuitas y no permiten la inclusión de nuevos tipos de pruebas o la visualización masiva de datos históricos.

Mantener estas mediciones con las herramientas existentes se vuelve una tarea compleja mientras crece el número de nodos a monitorear pues la cantidad de datos aumenta a través del tiempo. Sumado a esto, solo podemos capturar información a partir de los nodos extremos de la red.

En este trabajo, proponemos la construcción de un sistema de monitoreo de redes a bajo costo, configurable, y tolerante a fallas en las redes a monitorear. El sistema se manejará a través de una aplicacion web que permitirá a usuarios autenticados manejar agentes de red remotos, para ejecutar pruebas planificadas y recoger datos de los enlaces de interés. La transferencia de datos entre la aplicacion web y los monitores remotos se realizará a través de la nube. A este sistema le hemos dado el nombre de Octopus Monitor\ref{Octopus2015}

%A pesar de que Malawinet Network Monitor podría ofrecer estadísticas de tiempo de ida y vuelta (RTT) y disponibilidad de un enlace solo a partir de las trazas capturadas con Ping, se desea además implementar un marco de trabajo que permita agregar nuevas pruebas automatizadas que ayuden a obtener una imagen más completa de la red.
  
\section{Justificacion}

Ante la aparición de nuevas formas y organizaciones alternativas en la distribución del acceso a Internet, tales como redes comunitarias caracterizadas por despliegues caóticos y descentralizados o redes inalámbricas con enlaces de larga distancia que pueden ser poco confiables, se evidencia la necesidad de tener herramientas de bajo costo, sencillas de desplegar y mantener que puedan ayudar a los miembros de la comunidad a tener conocimiento del estado de la red. 

A pesar de que existe una gran variedad de herramientas para el monitoreo de despliegues de redes arbitrarias, se desea construir una plataforma que  facilite el monitoreo a través de una interfaz clara y metáforas intuitivas que abstraigan las entidades monitoreadas y que permita extender rápidamente el sistema cuando se deseen monitorear nuevas características de la red. 

\section{Objetivos}

\subsection{Objetivos Generales}

Construir un sistema de monitoreo de redes de bajo costo con almacenamiento de datos en la nube de tipo PaaS que sea de fácil instalación y permita configurar múltiples monitores remotos. Este debe ajustarse a cambios en el uso de recursos en los nodos donde vive el sistema y la carencia de personal in sitio.

\subsection{Objetivos Específicos}

\begin{itemize}
\item Desarrollar un servicio de monitoreo de bajo costo que de servicio a múltiples monitores de red remotos, presente visualizaciones gráficas a partir de los datos recogidos y ofrezca un marco de trabajo para agregar nuestros tipos de pruebas a los monitores de red existentes.
\item Desarrollar un cliente monitor para desplegar en nodos desatendidos con dispositivos recolectores de muestra de bajo costo (ej. Raspberry PI, Alix boards, APU) para observar el comportamiento de los enlaces a través de aplicaciones de monitoreo sencillas y de consola.
\item Utilizar sistemas de bajo costo y alta disponibilidad en la nube para almacenamiento y transferencia de datos.
%\item Integrar los distintos subsistemas que conforman el servicio de monitoreo.
\item Desarrollar un modulo de calculo asíncrono de gráficas que permita mejorar los tiempos de interacción del usuario final con el sistema utilizando técnicas para agilizar cómputo como caching, prefetching, threads, etc.
\end{itemize}

\section{Metodología}

Para el desarrollo de este trabajo se siguió una metodología en espiral; el modelo en espiral es un modelo del ciclo de vida del software donde el esfuerzo del desarrollo es iterativo. Cada ciclo de la espiral representa una fase del desarrollo de software, cada uno de los ciclos consiste de los siguientes pasos:
\begin{enumerate}
  \item Determinar o fijar los objetivos. En este paso se definen los objetivos específicos para posteriormente identificar las limitaciones del proceso y del sistema de software, además se diseña una planificación detallada de gestión y se identifican los riesgos.
  \item Análisis del riesgo. En este paso se efectúa un análisis detallado para cada uno de los riesgos identificados del proyecto, se definen los pasos a seguir para reducir los riesgos y luego del análisis de estos riesgos se planean estrategias alternativas.
  \item Desarrollar, verificar y validar. En este tercer paso, después del análisis de riesgo, se eligen un paradigma para el desarrollo del sistema de software.
  \item Planificar. En este último paso es donde el proyecto se revisa y se toma la decisión si se debe continuar con un ciclo posterior al de la espiral. Si se decide continuar, se desarrollan los planes para la siguiente fase del proyecto.
\end{enumerate}

Se realizaron cuatro ciclos, el primero correspondió a la realización de un monitor remoto básico que realice mediciones de RTT de la red con almacenamiento en la nube y visualizaciones de los datos obtenidos.

El segundo ciclo consistió en permitir el monitoreo de una cantidad arbitraria de monitores remotos permitiendo a múltiples usuarios manejar sus monitores remotos desde el servicio web y obtener las visualizaciones.

El tercer ciclo correspondió en diseñar e integrar una prueba con otras herramientas (traceroute, iperf, etc) para conseguir puntos comunes y generar un enfoque de integración sencillo de los \textit{wrappers} futuros a las aplicaciones. (ej. Lidiar con aplicaciones que requieren enfoque cliente solo [ping] o cliente-servidor [iperf]).

El cuarto ciclo consistió en hacer análisis del rendimiento del sistema y hacer las optimizaciones necesarias para ofrecer una calidad de servicio apropiada, determinar costos, limitaciones y requisitos mínimos para implementar en plataformas de bajo costo.

\section{Alcance}

El alcance de este trabajo remite al diseño y detalles de implementación tanto de una aplicacion web que funge como plataforma central de coordinación del monitoreo, y un agente monitor de redes ligero y robusto que pueda ser controlado remotamente. Se diseñó un sistema flexible y un esquema de coordinación entre sus distintos entes a través de la nube.

\section{Estructura del Documento}

El presente trabajo se estructura de la siguiente manera:

Capítulo 1. Introducción, este capítulo consiste de los antecedentes relevantes al tema a tratar, planteamiento del problema, justificación, objetivos, metodología a emplear y el alcance de este trabajo.

Capítulo 2. Marco Teórico, define brevemente los conceptos y herramientas usados durante el desarrollo de este trabajo y que son esenciales para su comprensión; tales como conceptos de alto nivel de monitoreo de redes, métricas de la calidad de un enlace, visualización de datos y los y sistemas de software usados para su implementación.

Capítulo 3. Aplicacion Web, contiene el diseño general del sistema de monitoreo, así como la arquitectura de la aplicacion web, sus sub-sistemas, componentes relevantes, casos de uso y finalmente análisis de rendimiento. 

Capitulo 4. Monitor de Red, explica el diseño del monitor de red remoto, su arquitectura, componentes y los módulos de prueba implementados.

Capitulo 5. Framework de Integración de Pruebas, describe los requisitos del marco de trabajo para la implementación de nuevas pruebas, así como todos sus componentes genéricos, finalmente explica como usar dichos componentes para integrar nuevas características a un sistema en producción.

Capitulo 6. Conclusiones y Recomendaciones, contiene las conclusiones obtenidas a partir del diseño e implementación del sistema, así como recomendaciones y posibles mejoras a incluir en trabajos futuros.

Finalmente se presentan los apéndices y las referencias bibliográficas.
%
%******************************
%FIN DE CAPITULO I
%******************************
%

\chapter{Marco Teórico}

En este capitulo se presentan los conceptos necesarios para la comprensión de este documento y se describen las herramientas de software, métodos y formatos que se emplearán para el desarrollo del sistema propuesto.

\section{Monitoreo de Redes}

El monitoreo de redes se refiere al uso de sistemas computacionales para determinar el estado de redes de computadoras, el estado de la red puede ser visto como el conjunto de factores o métricas que describen la red en un momento dado, se hablará a detalle de algunas de estas métricas en la sección \ref{sec:metricas}.

Mientras una red tiene ciertos elementos relativamente invariables como la posición de sus nodos, la longitud de los enlaces, el tipo de enlace (fibra óptica, cable, satelital, etc), el ancho de banda de los enlaces, la velocidad de procesamiento de los enrutadores, entre otros, el estado de la red viene determinado por elementos generalmente impredecibles, como condiciones climatológicas, problemas de configuración, equipos en mal estado y congestión, determinar todo este tipo de problemas para generar alertas, aplicar acciones correctivas o al menos tener conocimiento de ellas es el objetivo de un sistema de monitoreo de redes.

Existen dos paradigmas fundamentales en el monitoreo de redes, el monitoreo activo que consiste en generar tráfico y observar la respuesta de la red y el monitoreo pasivo, que consiste en observar el tráfico que atraviesa un cierto enlace o nodo. Para tener una imagen completa de la red es conveniente usar ambos paradigmas ya que ambos pueden ofrecer distintas perspectivas.

\section{Redes Comunitarias}

Las redes comunitarias se caracterizan por ser despliegues de redes a gran escalada construidos y organizados de una manera descentralizada \cite{gaia-alternative2015}, el crecimiento de la red es orgánico y está abierto a la participación de cualquiera. Los usuarios interesados en formar parte de la red colaboran aportando su propia infraestructura de red, agregando nuevos nodos que permiten que otros usuarios a su vez puedan continuar extendiendo la red.

A pesar de que el despliegue es distribuido y auto-gestionado se necesita una mínima infraestructura de gobernanza  para coordinar el direccionamiento IP y enrutamiento, las redes comunitarias tienden a estar compuestas por elementos de hardware y software muy diversos, y usualmente coexisten en ellas enlaces alambricos e inalambricos, distintos protocolos de enrutamiento o sistemas de manejo de la topología de red\cite{gaia-alternative2015}.

Las redes comunitarias sirven como una forma de distribuir el acceso a Internet de forma libre y neutral, tanto en zonas urbanas como rurales, sin embargo, también pueden servir para distribuir servicios y aplicaciones comunitarias tanto completamente gratuitas como comerciales. Cada participante sigue siendo dueño de la infraestructura que presta a la red y se benefician mutuamente al tener acceso a los servicios y aplicaciones de la red comunitaria.


%\section{Principio de Extremo-a-Extremo}

%El principio de extremo-a-extremo (también llamado argumento de extremo-a-extremo) sugiere que las funciones en los niveles bajos de un sistema pueden ser redundantes o de poco valor comparadas con el costo de proveerlas a bajo nivel\cite{saltzer1984end}, en otras palabras este argumento recomienda que la complejidad de un sistema de computación distribuido debe estar en los nodos mas externos o de "mayor nivel".

%Este principio es valioso para el diseño de cualquier tipo de sistema distribuido sin embargo ha sido fundamental en la expansión y desarrollo de redes de computadoras de propósito general y se sustenta en que los nodos intermedios de una red deben proveer solo las funciones necesarias para permitir la comunicación entre los nodos finales, de esta manera es posible implementar nuevas funcionalides en los extremos de la red sin necesidad de hacer cambios a los nodos intermedios.

%En el contexto de monitoreo de redes, se denomina tomografía de redes al proceso de inferir aspectos internos de una red a partir de mediciones realizadas en sus nodos externos.

\section{Métricas de calidad de un enlace} \label{sec:metricas}

A continuación se explican las métricas mas comúnmente utilizadas para determinar la calidad de un enlace.

\subsection{Latencia} \label{sub:lat}

La latencia es el tiempo que le toma a un paquete o mensaje viajar desde su origen hasta el punto destino \cite{Grigorik:13}. Teóricamente la latencia está relacionada directamente con la distancia entre los puntos finales de una comunicación, en la practica los paquetes viajan a través de una red de enrutadores que retransmiten el mensaje hasta su destino, la latencia total será la suma de cada uno de los siguientes factores para cada uno de los enrutadores que atraviese el paquete\cite{Grigorik:13}:
\begin{itemize}
\item{\textbf{Retraso de Propagación:} es el tiempo que tarda un mensaje en viajar del emisor al receptor y es función de la distancia por la velocidad a la que la señal se propaga.}
\item{\textbf{Retraso de Transmisión:} es el tiempo que tarda el emisor en poner todos los bits de un mensaje en el medio de transmisión y es función de la longitud del paquete y el ancho de banda del enlace.}
\item{\textbf{Retraso de Procesamiento:} tiempo requerido para revisar la cabecera del paquete, buscar errores y determinar el destino del paquete.}
\item{\textbf{Retraso de Colas:} Cantidad de tiempo que un paquete pasa en la cola de una interfaz esperando su turno por ser procesado.}
\end{itemize}

\subsection{Tiempo de ida y vuelta}

El tiempo de ida y vuelta (RTT por sus siglas es ingles) es el tiempo que le toma a un paquete viajar desde el origen a su destino y de vuelta, podría pensarse que el RTT es aproximadamente el resultado de multiplicar la latencia por dos, sin embargo existen factores como el retraso por procesamiento en el equipo destino o diferencias en el enrutamiento del paquete en su camino de vuelta que hace que sea arriesgado establecer esa proposición. 

Uno de los métodos mas populares para medir el RTT es enviar un paquete ICMP Echo Request y esperar el correspondiente ICMP Echo Reply sin embargo también es posible medir el RTT pasivamente durante la transmisión de un flujo TCP usando marcas de tiempo en la cabecera de los mensajes TCP\cite{strowes2013passively}.

Es importante notar que no es lo mismo medir el RTT desde la capa de red con el protocolo ICMP que hacerlo en la capa de transporte con TCP o en la capa de aplicación con un protocolo como HTTP, evidentemente el RTT será mayor en las capas superiores, sin embargo estas métricas también son útiles ya que se acercan mas fielmente a la experiencia del usuario.

\subsection{Perdida de paquetes}

La pérdida de paquetes ocurre cuando los paquetes en una transmisión fallan en llegar a su destino, ya sea por interferencias en el medio de transmisión (por ejemplo obstáculos físicos en un enlace WiFi), o cuando son desechados por un nodo de la red, los paquetes pueden ser desechados si se determina que están corruptos o mas comúnmente debido a escenarios de congestión en los que un enrutador está recibiendo paquetes a una tasa mayor de la que puede retransmitirlos y no tiene mas opción que desechar los paquetes que desborden la cola.

La perdida de paquetes afecta dramáticamente la latencia percibida en la capa de aplicación, según \cite{strowes2013passively} una perdida de paquetes del 5\% puede introducir un retraso de medio segundo en la aplicación. 
 
Mientras puede parecer que la perdida de paquetes es siempre producto de un problema, esta juega un papel vital en el algoritmo de prevención de congestión (congestion avoidance) del protocolo TCP, ayudándolo a detectar congestión en la red el cual responderá limitando su tasa de envío de datos, esto ha sido esencial para evitar el colapso de las redes ip NOTA: Nosotros alguna vez hablamos de esto, valdría la pena nombrar el RFC que lo explica. 

\subsection{Jitter} 

Se llama jitter a la fluctuación de la latencia durante la transmisión de un conjunto de paquetes, estas fluctuaciones vienen dadas principalmente por la variación del retraso que los paquetes experimentan en las colas en los enrutadores\cite{Kurose:13}, sin embargo todos los factores mencionados en la sección \ref{sub:lat} pueden contribuir en menor medida.

El término jitter puede tener distintas connotaciones sin embargo es usado frecuentemente por científicos en el área de la computación como la variación de una métrica (comúnmente latencia) con respecto a otra métrica de referencia (como latencia mínima o promedio), a esto también se le llama variación en el retraso de los paquetes (PDV por sus siglas en ingles), este termino es a veces preferido por ser mas preciso \cite{rfc3393}.

El jitter puede afectar considerablemente transmisiones en tiempo real como VoIP o streaming sin embargo la correcta implementación de políticas de buffering del lado del receptor puede minimizar e incluso mitigar este efecto\cite{Kurose:13}.

\subsection{Throughput}

En términos de redes de computadoras, el throughput es la tasa en bits por segundo a la que fluyen los datos a través de un enlace \cite{Kurose:13}, el throughput puede compararse al caudal de un rio, donde mientras mas ancho sea el rio mas agua puede fluir a través de el.

El máximo throughput teórico entre un par de nodos esta determinado principalmente por el segmento de la red con menor ancho de banda, este comportamiento se ilustra en la figura \ref{fig:throughput}, donde el cable entre el punto de acceso wifi y el ISP resulta ser el cuello de botella en la comunicación. En la practica el throughput también viene determinado por varios factores como otros flujos de datos con los que se comparte la red o la velocidad a la que el receptor es capaz de procesar el flujo de datos entrante.

\begin{figure}[h]
\centering
\includegraphics[width=0.7\linewidth]{img/throughput}
\caption{Latencia y ancho de banda}
\label{fig:throughput}
\end{figure}

Para aplicaciones en tiempo real es esencial tener un throughput mínimo mayor a un cierto umbral que asegure que los datos se estén recibiendo a una tasa mayor o igual a la que se están consumiendo\cite{Kurose:13}, es decir que a partir de esa tasa mínima un mayor throughput no implica una mejoría en la calidad de la comunicación, otras aplicaciones como transferencias de archivos se benefician del mayor throughput posible ya que el tiempo de transferencia es una función del tamaño del archivo entre el throughput durante la transferencia.

No es posible medir el throughput de un enlace de forma pasiva, por lo que las pruebas que existen consisten en inyectar tráfico al enlace hasta saturarlo y determinar la velocidad a la que se reciben los datos del lado del receptor. Existen múltiples maneras de saturar el enlace, por ejemplo speedtest.net \cite{SPEEDTEST} utiliza hasta cuatro hilos paralelos transmitiendo mensajes aleatorios a través de HTTP, utilizar múltiples flujos es una forma efectiva de mitigar el efecto de la latencia sobre el throughput.

A diferencia de las métricas anteriores medir el throughput solo es posible con la colaboración de los nodos extremos del enlace, por lo que es necesario tener algún tipo de software preparado para aceptar la prueba e informar del resultado obtenido.

%\subsection{Uso del ancho de banda}

%Se le llama uso del ancho de banda a la medida de los datos que fluyen a través de un enlace, generalmente se busca optimizar el uso del ancho de banda para aprovechar al máximo los recursos de red. Mas allá de solo determinar la cantidad de datos o la velocidad del flujo a través de un enlace, también es útil hacer análisis detallados del uso del ancho de banda para descubrir patrones de uso de la red.

\subsection{Disponibilidad} \label{sub:disponibilidad}

Un servicio esta disponible para un cliente cuando dicho cliente puede comunicarse con el, análogamente un servicio no esta disponible para un cliente cuando no puede comunicarse con el, ya sea por un problema en el nodo final o en la red \cite{dahlin2003end}. 

Generalmente la disponibilidad se mide a través de la disponibilidad promedio, que es la fracción del tiempo  durante el cual un servicio esta disponible para un cliente promedio \cite{dahlin2003end}, sin embargo también se puede usar la disponibilidad continua, en este trabajo llamaremos actividad continua a un evento durante el cual un servicio está continuamente disponible para un cliente, y un inactividad continua a un evento durante el cual un servicio esta continuamente no disponible para un cliente.

Hemos definido la disponibilidad como un concepto meramente binario, en el que si un servicio es alcanzable entonces está disponible \cite{dahlin2003end} sin embargo hay ciertos escenarios en los que se puede considerar que un nodo alcanzable está fallando en ofrecer un servicio adecuadamente, por ejemplo cuando un servidor web está respondiendo a las peticiones con un código de estado 500, o cuando la latencia es tal que hace que una comunicación en tiempo real no sea posible. 

\subsection{Bufferbloat}

Bufferbloat es la existencia de buffers excesivamente grandes y generalmente llenos presentes en Internet \cite{gettys2011bufferbloat}; puede parecer contra-intuitivo ya que buffers mas grandes implican que menos paquetes serán desechados al llegar a un enrutador congestionado, pero mientras la cola en la interfaz del enrutador crece también lo hace el tiempo de espera del paquete y a la vez interfiere (o invalida) los algoritmos de control de congestión de los protocolos mas comunes en la capa de transporte \cite{gettys2011bufferbloat}.

El bufferbloat puede ser mitigado configurando apropiadamente el hardware disponible, sin embargo es difícil de diagnosticar y es confundido frecuentemente con congestión en la red.

Recientemente se ha comenzado a medir el blufferbloat como el tiempo adicional que toma enviar paquetes a través de un enlace congestionado, algunas pruebas disponibles en linea \cite{DSLReports}\cite{ThinkBroadband} intentan determinar este retraso haciendo mediciones constantes de latencia al mismo tiempo que inundan el enlace para determinar la forma en que esta varía durante la prueba.

\section{Big Data}

Debido a la rápida evolución en la capacidad de almacenamiento y procesamiento de los sistemas computaciones y la adopción de los mismos por parte de miles de millones de usuarios en Internet, así como la creciente de popularidad de objetos inteligentes (Internet de las Cosas), sensores, cámaras, micrófonos, lectores biométricos, lectores de radiofrecuencia, entre muchos otros, día a día se están produciendo datos de forma rápida y masiva, esta tendencia creciente en la generación de datos ha hecho evidente la necesidad de tener sistemas capaces de manipular estos datos para obtener información y hacer descubrimientos que habrían sido imposibles anteriormente. 

Big Data se refiere la tendencia reciente de recolectar, almacenar y hacer análisis sobre cantidades masivas de datos, Big Data es un termino relativamente impreciso ya que no existe un convenio sobre la cantidad de datos a la que se refiere, pero usualmente el termino se relaciona con datos en el orden de los petabytes (10\textsuperscript{15} bytes) y exabytes (10\textsuperscript{18} bytes) \cite{barranco2012}. 

El aprovechamiento de este flujo de datos generalmente inmanejable por los sistemas previamente concebidos ha sido adoptado por muchos tipos de organizaciones, por ejemplo las redes sociales rutinariamente analizan a sus usuarios para descubrir sus gustos y preferencias y ajustar cuidadosamente la publicidad que estos ven, juegos en linea analizan a sus jugadores para entender que factores determinan su comportamiento y de esta manera optimizar finamente las experiencias que les ofrecen, un ejemplo conocido de uso de big data en el ámbito médico ha sido la exitosa predicción de transmisión de enfermedades como el dengue a partir de patrones de búsqueda en google\cite{GoogleFlu}, también existe preocupación sobre el uso del big data para violar la privacidad de usuarios de Internet por parte de organizaciones gubernamentales de seguridad y vigilancia que son capaces de conocer todo tipo de detalles personales como transacciones y compras, sitios web visitados, búsquedas realizadas, publicaciones en redes sociales, posición geográfica con el uso de GPS, etc.

\section{Visualización de datos} \label{sec:visualizacion}

La visualización de datos se refiere al aprovechamiento de elementos gráficos para representar información cuantitativa; cualquier conjunto de datos no tienen significado sin alguna manera de organizar y  presentar los descubrimientos relevantes que se encuentran potencialmente ocultos dentro de estos.

Los humanos podemos comprender los datos de mejor manera cuando son presentados a través de imágenes y elementos gráficos que leyendo números en tablas y listas\cite{Pervasif}, una visualización apropiada de los datos permite de forma efectiva preguntar y responder las preguntas relevantes a una organización, por ejemplo en el marco de un sistema de monitoreo de redes preguntas como "¿donde están apareciendo los cuellos de botella?" "¿que factores afectan el rendimiento de un enlace?" o "¿cuales son los patrones de uso de los usuarios de la red?"

Hay una variedad de métodos apropiados para visualizar distintos conjuntos de datos, por ejemplo, los datos discretos se pueden observar a través de gráficas de barras, los gráficos de redes pueden comunicar la relación entre distintos entes, los mapas son efectivos para desplegar información geográfica, los mapas de calor permiten comparar el rendimiento de una variable a través del tiempo, etc, cada una de estas visualizaciones puede ser enriquecida a través del uso creativo de colores y formas para agregar nuevas dimensiones a los datos representados. Es posible combinar distintos conceptos para lograr visualizaciones aun mas poderosas como mapas de calor superpuestos en mapas que pueden expresar datos de la densidad de una variable al mismo tiempo que se da una idea de su posición geográfica.

\begin{figure}
\centering
\includegraphics[width=0.7\linewidth]{img/datavisualization}
\caption{Visualización de periodos de actividad e inactividad continua}
\label{fig:crimespotting}
\end{figure}

En la figura \ref{fig:crimespotting} se observa una visualización de los periodos de actividad continua como segmentos de linea verde y los periodos de inactividad como segmentos de linea roja, es posible hacer zoom para observar los periodos a mayor detalle y revisar el tiempo exacto del inicio del periodo pasando el puntero sobre un punto, la concentración de puntos de distintos colores da una idea rápida de la estabilidad del enlace.

\section{Computación en la nube}

La computación en la nube se refiere tanto a las aplicaciones desplegadas como servicios en Internet y el hardware y los sistemas computaciones en los centros de datos que proveen dichos servicios \cite{armbrust2010view}, a los servicios en si mismos se les ha dado el nombre de Software como Servicio (SaaS) y al hardware y software en los centros de datos es a lo que llamamos una nube. Cuando una nube se hace disponible para el publico en general a través de alguna forma de pago, se le llama una nube publica y el servicio que se esta vendiendo es Computación como Utilidad (Utility Computing), se le llama nube privada a los centros de datos internos de negocios u otras organizaciones pero que no pueden ser usados por el publico general, por lo tanto llamamos computación en la nube a la suma de SaaS y Computación como Utilidad sin incluir nubes privadas\cite{armbrust2010view}

La computación en la nube se caracteriza por ofrecer métodos de pago flexibles que permiten pagar solo por los recursos que se están utilizando (pay-as-you-go) y con una fina granularidad de modo que es lo mismo pagar mil procesadores una hora que un procesador por mil horas, esto permite a aplicaciones manejar cargas y escalas fluctuantes o patrones de uso específicos sin necesidad de tener hardware que esté ocioso durante largos periodos de tiempo. La nube ofrece a desarrolladores la ilusión de recursos computaciones ilimitados y disponibles a petición, eliminando la necesidad de planificar y aprovisionar equipos de hardware, y minimizar los riesgos relacionados con subestimar una aplicación que explota en popularidad o sobrestimar una aplicación que no llena las expectativas, en otras palabras no es necesario tener un gran capital de inversión inicial independientemente de la escala que resulte necesario manejar a corto o mediano plazo.

\subsection{Modelos de servicio en la nube}

Existen tres modelos de servicios en la nube que forman una "arquitectura orientada a servicios", estos son:

\subsubsection{Infraestructura como Servicio (IaaS)}

Infraestructura como Servicio a veces llamado Hardware como Servicio (HaaS) ofrece funciones básicas de almacenamiento y capacidad de computo como servicio ya sea a través de equipos de hardware físicos o de forma mas común como maquinas virtuales y una larga gama de imágenes de software disponible.

Esta capa abstrae al usuario de los detalles de infraestructura de los recursos de computo físico, localización, configuración, escala, seguridad, respaldo, mantenimiento, etc.

\subsubsection{Plataforma como Servicio (PaaS)}

Plataforma como servicio ofrece como servicio una plataforma para el desarrollo, ejecución y manejo de aplicaciones web, los recursos computacionales demandados por la aplicación son manejados automáticamente, de modo que la complejidad de manejar la infraestructura subyacente queda eliminada, esto permite reducir enormemente la complejidad necesaria para desplegar aplicaciones, que pueden pasar de la etapa de desarrollo y pruebas rápidamente a un entorno de producción con un esfuerzo mínimo. 

\subsubsection{Software como Servicio (SaaS)}

En el modelo de Software como servicio, los usuarios ganan acceso y hacen uso de aplicaciones de software, generalmente este tipo de software se paga bajo una subscripcion o por uso, este tipo de aplicaciones en la nube es conveniente y atractiva para los usuarios ya que estos no necesitan instalar software adicional en sus dispositivos sino que puede acceder a la aplicación desde navegadores web, esto permite que los usuarios puedan tener la misma experiencia en cualquier plataforma y reduce los costos operacionales.

\section{Herramientas usadas para el desarrollo del sistema}

A continuación se describen las herramientas usadas para el desarrollo del sistema de monitoreo de redes orientado a la recolección masiva de datos.

\subsection{Modelo Vista Controlador (MVC)}

El Modelo Vista Controlador es un patrón de diseño que divide la lógica de los datos y la presentación de forma claramente identificable y bien definida \cite{pantoja2004patron}. Este patrón de diseño es muy popular en el marco de aplicaciones web ya que su abstracción permite escribir software altamente desacoplado y fácil de mantener y escalar.

\subsubsection{Modelo} 

Según \cite{pantoja2004patron} \textit{''El modelo es un conjunto de clases que representan la información del mundo real que el sistema debe procesar, así por ejemplo un sistema de administración de datos climatologías tendrá un modelo que representará la temperatura, humedad ambiental, estado del tiempo esperado etc''}

Según la implementación de MVC el modelo puede dividirse en el modelo del dominio que es el modelo propiamente dicho, es decir una colección de clases que modelan la realidad relevante a la aplicación, y opcionalmente el modelo de la aplicación; este modelo tiene conocimiento de las vistas y es capaz de enviar notificaciones cuando ocurren cambios en el modelo. El modelo de la aplicación también es llamado coordinador de la aplicación \cite{pantoja2004patron} .

\subsubsection{Vista} 

La vista es la encargada de determinar que información contenida en el modelo mostrar al usuario y la presentación, por ejemplo si se está modelando una caldera es posible tener una vista que dibuje gráficamente el nivel de la caldera y un termómetro con su temperatura y otra vista que sencillamente muestre estas propiedades en una tabla. 

La vista pudiera cambiar cuando se actualiza el modelo del dominio a partir de notificaciones emitidas por el modelo de la aplicación, siguiendo con el ejemplo anterior de esta forma sería posible monitorear en tiempo real el estado de la caldera a partir de sensores que mantengan actualizado el modelo. 

\subsubsection{Controlador} 

El controlador es el encargado de dirigir el flujo de control de la aplicación a partir de mensajes externos, como datos introducidos por el usuario en el caso de una aplicación de escritorio o peticiones HTTP en el caso de aplicaciones web. A partir de estos estímulos, el controlador se encargará de invocar las vistas apropiadas, actualizar el modelo y hacer todas las acciones necesarias.

Distintas implementaciones del patrón MVC se toman la libertad de establecer la linea que separa el controlador y la vista de forma distinta, por ejemplo en algunas implementaciones el controlador se encarga tanto de actualizar el modelo y las vistas como de responder a los mensajes externos, es decir que el controlador es el encargado de ejecutar toda la lógica, y la vista meramente contiene la presentación de los datos, en otras implementaciones, la vista es la encargada tanto de seleccionar los datos que van a mostrarse así como de desplegar la presentación, esta ultima es una variación de MVC a veces llamado MTV (Modelo-Template-Vista)

\subsection{Django}

Django es un framework de desarrollo de aplicaciones web construido en python, en este trabajo usamos Django como el fundamento para Octopus Head. Django permite construir aplicaciones web rápidamente gracias a su filosofía de "baterias incluidas", es decir, que incluye una inmensa gama de características comunes a la mayoría de las aplicaciones web como validaciones de formularios, autenticación de usuarios, manejo de sesiones entre muchos otros \cite{DjangoWebsite}; así el desarrollador puede concentrarse en escribir la lógica que es especifica a su aplicación y dejar que Django maneje los aspectos repetitivos y muchas veces tediosos de la pila de desarrollo web.

Django esta diseñado con una arquitectura MVC es decir que separa claramente la lógica, de los datos y la forma en que dichos datos son presentados al usuario, en el caso de Django la "vista" describe que datos son presentados al usuario y el "template" representa la forma en que dichos datos son presentados. 

Cuando Django recibe una petición esta pasa por un despachador de URLs (URL Dispatcher), cuya tarea es emparejar el URL con una vista y delegar a la vista el manejo de la petición. La vista contiene la lógica necesaria para atender la petición entrante, generalmente esto consiste en retirar o actualizar algunos datos del modelo, que a su vez se comunica con el manejador de base de datos, finalmente la vista combina los datos retirados de la base de datos, la petición y la sesión activa con una plantilla (template) para generar la respuesta que será devuelta.

Las respuestas generadas por Django pueden ser tanto paginas HTML con CSS y Javascript pensadas para la interacción con el usuario así como respuestas en formato json o xml para la construcciones de APIs que pueden ser usados para la comunicación maquina-maquina, esto es especialmente útil cuando se desea desarrollar aplicaciones en otras plataformas como Android o iOS que compartan el mismo backend.

Django ha demostrado ser escalable y flexible, se sabe de instancias de Django atendiendo ráfagas de cincuenta mil peticiones por segundo, ademas es de código abierto, gratuito y cuenta con una enorme comunidad de colaboradores y amplia documentación. 

\subsection{Celery}

Celery es un sistema de procesamiento de tareas asíncrono, que permite tanto el encolamiento de tareas en tiempo real así como la planificación de tareas para ser ejecutadas mas tarde. Celery en realidad no implementa la mayoría de sus componentes, sino que define un protocolo de comunicación entre una serie de componentes (tambien llamados micro-servicios)\cite{CeleryWebsite}: 

\begin{itemize}
	\item{Bróker de mensajería.}
	\item{Planificador.}
	\item{Workers (Trabajadores).}
	\item{Backend de Resultados.}
\end{itemize}

Celery es usado comúnmente junto a Django y permite a una aplicación web escalar a bajo costo ya que solo hace falta aumentar el número de trabajadores disponibles que se pueden distribuir en tantas maquinas como sea necesario. 

\subsection{Redis} \label{sub:redis}

Redis es un almacén de estructuras de datos en memoria que soporta una amplia gama de tipos como cadenas de caracteres, hashes, listas, conjuntos, conjuntos ordenados, mapas de bits, indices geo-espaciales, etc \cite{RedisWebsite}. 

Redis es comúnmente usado como base de datos, cache o bróker de mensajería; y se caracteriza por su velocidad de respuesta ya que todos sus datos se mantienen en memoria principal y solo invierte recursos en asegurar ciertos niveles de persistencia, sin embargo, por omisión, los datos almacenados se pierden en caso de que ocurra cualquier falla inesperada.

\subsection{Bases de Datos}

Uno de los pilares fundamentales de casi toda aplicación moderna es tener un modo de almacenar datos de forma persistente en el tiempo así como consultarlos y actualizarlos de forma rápida, segura y resistente a fallas.

Según \cite{MysqlDev} una base de datos es una colección de datos estructurados. Puede ser cualquier cosa desde una simple lista de compras, una galería de fotos o las bastas cantidades de información en una red corporativa. Para agregar, acceder y procesar la data almacenada en una base de datos, se necesita un sistema manejador de base de datos. Ya que los computadores hacen un muy buen trabajo manejando grandes cantidades de datos, los sistemas manejadores de bases de datos juegan un papel central en la computación como utilidades independientes o partes de otras aplicaciones.

SQL por sus siglas en ingles "Structured Query Language" (lenguaje de consulta estructurado) es el lenguaje estandarizado mas común para acceder a bases de datos, SQL está definido por el Estándar ANSI/ISO SQL y ha ido evolucionando desde 1986 para convertirse en un estándar de facto en el mundo de la computación.  

\subsubsection{Mysql}

Mysql es un sistema manejador de bases de datos relacionales (RDBMS por sus siglas en ingles) de codigo abierto bajo la licencia GPL (GNU General Public License). Mysql se caracteriza por ser rápido, confiable, escalable y fácil de usar, es posible instalar Mysql tanto en una maquina junto a otras aplicaciones como servidores web o también instarlo en maquinas dedicadas para que use todo el poder de cómputo disponible. Mysql posee características para ejecutarse en clusters de maquinas junto con un motor de replicacion para obtener una alta escalabilidad \cite{MysqlDev}.

\subsubsection{Mapeo Objeto-Relacional}

El Mapeo Objeto-Relacional (ORM por sus siglas en ingles) es un método para interactuar con bases de datos relaciones desde el paradigma de la programación orientada a objetos, de esta manera es posible aprovechar conceptos como herencia y polimorfismo.

Según \cite{ScottORM} la mayoría de las aplicaciones modernas usan lenguajes orientados a objetos como Java o C\# para construir aplicaciones y bases de datos estructuradas para almacenar datos, por lo tanto, es util tener una interfaz que transforme los datos entre estos tipos de incompatibles. 

El uso de un ORM simplifica enormemente el manejo de la estructura de datos subyacente ya que permite al programador manejar los datos a un mayor nivel de abstracción como si fueran objetos, sin necesidad de generar manualmente las consultas SQL, ademas esta capa de abstracción permite desacoplar el código de la aplicación de los detalles específicos de cada RDBMS.

\subsection{Json (JavaScript Object Notation)}

Json (JavaScript Object Notation) o notación de objectos javascript es un formato textual de intercambio y almacenamiento de datos no estructurados, json posee un formato que es fácil de leer para humanos y fácil de interpretar para maquinas y mas ligero que XML por lo que se ha popularizado para el desarrollo de APIs. 

Json soporta dos tipos de estructuras de datos fundamentales:
\begin{enumerate}
	\item{Colecciones de pares $<$nombre,valor$>$ comparable a un diccionario o tablashash.}
	\item{Listas ordenadas de valores, similar a las listas o vectores que existen en virtualmente cualquier lenguaje de programación }
\end{enumerate}

Un archivo en formato json puede estar formado de cualquiera de las estructuras de datos antes descritas o cualquier permutación de dichas estructuras anidadas.

\subsection{Dropbox}

Dropbox es una plataforma de almacenamiento de datos en la nube de tipo PaaS y SaaS que permite compartir y sincronizar archivos entre un número arbitrario de clientes.

Dropbox es usado por aproximadamente 400 millones de personas y 100.000 organizaciones\cite{Dropbox} y posee aplicaciones en Windows, Linux, Mac OS X, iOS, Android, Blackberry y web. 

Como todo servicio en la nube es atractivo para desarrolladores por ser robusto y confiable y es gratis hasta alcanzar una cierta cantidad de espacio de almacenamiento usado, a partir de ese punto incluye planes de pago que dependen de la cantidad de espacio usado.


\subsubsection{API de Dropbox}

Un API (Aplication Programming Interface) o interfaz de programación de aplicaciones, es una serie de métodos o funciones orientados a la comunicación maquina-maquina, en el caso de la computación en la nube un API conforma un servicio que permite desarrollar aplicaciones sobre una plataforma (en este caso Dropbox).

El API de Dropbox permite realizar peticiones (como subir o descargar archivos, listar directorios o crear carpetas) sobre el espacio de almacenamiento de un usuario, el usuario debe previamente dar permiso a la aplicación para que esta pueda hacer cambios a su nombre, el usuario puede elegir denegar el acceso a la aplicación en todo momento y existen distintos tipos de esquemas de acceso donde una aplicación solo tiene acceso a un conjunto limitado de directorios dentro del espacio de almacenamiento del usuario.

El API de Dropbox impone ciertos límites de peticiones por usuario para impedir que una aplicación realice una cantidad excesiva de peticiones en un periodo corto de tiempo, sin embargo el limite se considera lo suficientemente alto como para no entorpecer la inmensa mayoría de los casos de uso.

\subsection{Diseño web adaptable}

Debido a la inmensa diversidad de dispositivos desplegados en el mercado y sus distintos tamaños y formas es imposible realizar manualmente diseños que puedan ajustarse a cada uno de ellos, anteriormente una solución popular a este problema era tener varias versiones con distintas resoluciones y elegir que versión mostrar a cada cliente, sin embargo esto ya no es necesario gracias a las nuevas herramientas disponibles en HTML5 CSS y Javascript que están ampliamente implementadas en navegadores modernos.

El diseño web adaptable o "Responsive Web Design" es la tendencia en el diseño de paginas web que se ajusten elásticamente a cualquier resolución, adaptando la forma en que se presentan sus elementos de forma "inteligente".

Las técnicas mas comunes para lograr esto es tener elementos que ocupen el mayor espacio horizontal posible en pantallas grandes y mientras el tamaño horizontal se reduce estos pasan a ocupar el espacio verticalmente; siempre ocupando el máximo del ancho disponible, evitando crear barras de desplazamiento horizontal que desorientan e incomodan a los usuarios. 

Otra heuristica en la creación de sitios web adaptables es escalar o esconder elementos gráficos decorativos o menús de navegación laterales, reducir el tamaño de margenes o incluso cambiar tipos de letras para que sean mas legibles en dispositivos móviles, mientras el tamaño del dispositivo es menor, cada pixel se vuelve mas precioso.

\begin{figure}[h]
\centering
\includegraphics[width=0.9\linewidth]{img/responsive_final}
\caption{Ejemplo de diseño adaptable, se puede ver como los elementos se reagrupan, escalan o esconden para ajustarse al tamaño de la pantalla.}
\label{fig:responsive}
\end{figure}

El diseño web adaptable no solo facilita el desarrollo de sitios web ahorrando a los desarrolladores y diseñadores el costo de construir múltiples versiones de un mismo sitio web sino que ademas el sitio web ofrece una experiencia similar independientemente del dispositivo con el que se esté visitando.

\subsection{Highcharts}

Highcharts es una biblioteca Javascript para dibujar gráficas en entornos HTML es gratis para proyectos no comerciales y de código abierto. Las gráficas generadas por highcharts aprovechan las características de HTML5 por lo que pueden soportar enormes conjuntos de datos sin afectar el rendimiento incluso en dispositivos móviles, son totalmente interactivas de manera que el usuario puede inspeccionar detalladamente el conjunto de datos y son dinámicas permitiendo actualizar la gráfica en tiempo real cuando se reciben nuevos datos.

Highcharts incluye una amplia gama de gráficas predefinidas que la hace ideal para todo tipo de visualización de datos como mapas de calor, splines, gráficas de área, barras, pie, mapas, entre muchos otros; cada una de ellas ofrece un gran control sobre la forma en que son presentadas de modo que es posible lograr casi cualquier resultado deseado.

Desde el punto de vista del programador es muy fácil de usar ya que solo requiere especificar un "objeto de configuración" y uno o mas arreglos conteniendo los datos a desplegar, es posible obtener distintas representaciones de los mismos datos solo cambiando el objeto de configuración. 

\subsection{Google Maps}

Google Maps es el servicio de mapas web de Google, ofrece distintos tipos de mapas, como mapas viales, mapas de relieve e incluso imágenes satelitales e imágenes de calles en tercera dimensión (llamado Google Street View)

Los mapas de Google Maps son totalmente dinámicos, permitiendo al usuario desplazarse, hacer zoom y cambiar el tipo de mapa a voluntad, Google Maps funciona dividendo el espacio mostrado en sectores que son descargados individualmente, de manera que cuando el usuario desplaza el mapa solo es necesario descargar los nuevos sectores desde los servidores de Google.

Google Maps es una de las herramientas mas populares para dibujar mapas web ya que ofrece un API gratuito y fácil de usar que permite enmarcar mapas en cualquier sitio web con solo algunas lineas, ademas los mapas de Google son de altisima calidad y se mantienen constantemente actualizados. 

\subsection{Geo-localizacion IP}

La geo-localizacion IP consiste en asignar a un IP la localizacion geográfica de la maquina anfitriona correspondiente\cite{poese2011ip}. 

Existen dos paradigmas principales para aproximar la localización geográfica de una dirección IP: activo y pasivo; las técnicas activas de localización se basan en mediciones de retraso y en muchos casos proveen resultados precisos\cite{poese2011ip}, el paradigma pasivo consiste del uso de bases de datos que contienen rangos de direcciones ips a los que se les llaman bloques o prefijos relacionados a una localización geográfica especifica, sin embargo su precisión puede estar sujeta a errores substanciales. En ambos casos es imposible conocer la localización exacta asociada a una dirección IP sin la colaboración activa de los anfitriones finales, sin embargo es posible hacer buenas aproximaciones en algunos a nivel de ciudades o países.

Ya que conocer la localización de sus clientes a partir de su dirección ip es útil para muchos servicios (por ejemplo, para conducir anuncios localizados) existe una gran variedad de soluciones de geolocalizacion tanto gratuitas como de pago.

\subsection{Ajax}

AJAX (Asynchronous JavaScript And XML) es una técnica para construir sitios web interactivos a través de peticiones asíncronas con Javascript que mantienen comunicación con el servidor web para mantener el estado del cliente actualizado sin necesidad de que el usuario tenga que refrescar la pagina o realizar consultas adicionales, de esta manera el usuario tiene una experiencia similar a la que tendría con aplicaciones de escritorio. 

A pesar de que el nombre AJAX sugiera el uso XML como lenguaje para la transferencia de datos entre el cliente y el servidor, se puede usar cualquier formato como texto plano, HTML y JSON

\subsection{APScheduler}

APScheduler (Advanced Python Scheduler) es una biblioteca python para retrasar la ejecución de rutinas a un instante dado en el futuro ya sea como eventos de una sola vez o de forma recurrente\cite{APScheduler}, esta biblioteca provee las herramientas para construir cualquier esquema de planificación que se desee su arquitectura consta de los siguientes componentes: gatillos para determinar el momento de ejecucion de las tareas (por fecha, por intervalos de tiempo, o tipo crontab), almacenes de tareas para alojar los datos de las tareas, ejecutores para controlar la ejecucion de las tareas y planificadores que unen los componentes antes descritos y se encargan de 

\subsection{Ping} \label{sub:ping}

Ping es un programa utilitario incluido en todos los sistemas basados en UNIX y Windows que comprueba la presencia y tiempo de respuesta de un host en una red IP. Ping utiliza el Protocolo de Mensajes de Control de Internet (ICMP) para enviar un paquete de solicitud ICMP (ICMP Echo Request) y espera el mensaje de respuesta del host remoto (ICMP Echo Reply); calculando la diferencia de tiempo entre el envío y la recepción se puede calcular la latencia de la red, ping también incluye funciones para enviar paquetes en ráfaga útil cuando se desea medir la perdida de paquetes.

Ya que históricamente ping se ha usado por atacantes para determinar la presencia de equipos en una red o realizar ataques de denegación de servicio (ping flood) muchos enrutadores y firewalls bloquean estos mensajes como medida de seguridad, aunado a esto ya que ping utiliza ICMP que es un protocolo de capa de red, este no es capaz de alcanzar equipos detrás de un NAT; a pesar de esto, ping ha demostrado ser una herramienta vital en el diagnostico y monitoreo de redes IP.

\subsection{Traceroute}

Traceroute (tambien llamado Tracert en sistemas Windows) es un programa utilitario de diagnostico que permite conocer los hosts que visita un paquete durante su transito por una red.

Al igual que Ping, Traceroute utiliza el protocolo ICMP pero envía paquetes con un valor de "Time to Live" (TTL) incremental, cada vez que un nodo de la red recibe un paquete decrementa su valor de TTL y si este llega a cero lo descarta y envía de vuelta al host emisor un mensaje de control indicando que el TTL llegó a 0, de esta manera Traceroute puede generar una lista de los nodos visitados y el valor de RTT para cada uno de ellos.

Un análisis cuidadoso de la salida de Traceroute puede ayudar a diagnosticar numerosos problemas en una red como ineficiencias en el enrutamiento, presencia de enrutadores congestionados, cuellos de botella, comportamientos inesperados, etc. 

\subsection{Iperf}

Iperf es una herramienta que permite medir el rendimiento (throughput) entre un par de nodos en un red. Al igual que muchas otras pruebas para medir velocidad de transferencia, Iperf funciona con una arquitectura cliente-servidor, donde el cliente genera un flujo de datos hacia el servidor y mide la velocidad obtenida, también es posible ejecutar una prueba "en reversa" donde es el servidor el que genera el flujo de datos.

Iperf puede ejecutar pruebas utilizando TCP o UDP, sin embargo existen diferencias entre ellos:

\begin{itemize}
		\item{Ya que UDP a diferencia de TCP no implementa ningún algoritmo de control de congestión se podría obtener un rendimiento ligeramente superior con este protocolo.}
		\item{Con UDP se puede obtener una estadística de la perdida de datagramas durante la prueba.}
		\item{Con UDP es el servidor el que totaliza los resultados, ya que el cliente no tiene manera de saber que datagramas se han recibido.}
\end{itemize}

Para obtener una buena medición del rendimiento del enlace hay que ajustar los parámetros de la prueba cuidadosamente, por ejemplo, es posible ajustar la cantidad de datos que se van a transferir durante la prueba, elegir una cantidad muy pequeña podría resultar en que no sea suficiente para saturar el enlace, mientras tanto elegir una cantidad demasiado grande podría resultar en una prueba innecesariamente larga, en ambos casos el valor del rendimiento obtenido no reflejará la realidad, también hay que tomar en cuenta que es difícil obtener una lectura exacta del rendimiento del enlace ya que podrían existir otros flujos en la red que afecten el resultado de la prueba. 

\section{Estado del Arte}

A pesar de que el monitoreo de redes no es un nuevo campo de estudio, existe una variedad de soluciones innovadoras y aplicaciones web que proveen distintos enfoques para el monitoreo y evaluación de redes.

En esta sección resumimos estos sistemas por los siguientes parámetros:

\begin{enumerate}
	\item{\textbf{Servicio ofrecido:} define el servicio proveído por el sistema, por ejemplo: monitoreo de actividad de servicios web, evaluación de calidad de servicio de WISP, etc.}
	\item{\textbf{Dispositivos de monitoreo:} define el tipo de dispositivo que ejecuta las pruebas o actúa como el punto final "activo" del monitoreo; por ejemplo: dispositivos móviles, hardware especializado, enrutadores, etc.}
	\item{\textbf{Localización de los dispositivos de monitoreo:} define la localización donde los dispositivos de monitoreo son desplegados.}
	\item{\textbf{Referencia de monitoreo:} define el dispositivo que sirve como la referencia de monitoreo, en otras palabras, un dispositivo que espera por los mensajes del dispositivo de monitoreo y responde apropiadamente; estos no siempre son necesarios ya que muchos de los elementos presentes en la red implementan protocolos que pueden ser usados para propósitos de monitoreo. Ejemplos de estos dispositivos son: nodos en la red como enrutadores y computadores o servidores dedicados.}
	\item{\textbf{Localización de las referencias de monitoreo:} define la localización donde las referencias de monitoreo son desplegadas. Esto es importante ya que la distancia entre los distintos dispositivos impacta los resultados de manera relevante.}
	\item{\textbf{Tipo de red:} se consideraron dos configuraciones de monitoreo de redes: cliente-servidor donde un conjunto de clientes ejecutan pruebas en contra de uno o mas servidores dedicados y redes peer-to-peer, donde los entes de monitoreo puedes realizar pruebas entre sí (es decir, actuar como dispositivos monitores y referencias de monitoreo), esta configuración es muy útil ya que permite un gran arreglo de pruebas posibles.}
	\item{\textbf{Tests:} detalles sobre las pruebas ejecutadas por el sistema, por ejemplo: pruebas de rendimiento con UDP, traza de rutas, ICMP ping, resolución de DNS, etc.}
	\item{\textbf{Visualizaciones disponibles:} detalles sobre los métodos de visualización de datos disponibles como mapas, gráficas de barras, tablas, etc.}
	\item{\textbf{Numero estimado de usuarios:} número estimado de usuarios en el orden de potencias de diez.} 
	\item{\textbf{Referencias:} determina si el sistema tiene referencias en papers o otras publicaciones.}
	
\end{enumerate}


\begin{table}[h!]
	\scriptsize{
	\begin{flushleft}

	\begin{tabular}{|p{1.5cm}p{2.5cm}p{2cm}p{2cm}p{2cm}p{2cm}p{1.5cm}|}
		\hline
		~                              & Servicio                                       & Dispositivos Monitores                                     & Localización                                         & Referencias de monitoreo            & Localizacion                                         & Tipo de red                     \\ \hline
		Atlas Ripe                     & Monitoreo de alcanzabilidad, latencia y DNS    & Probes y anchors (hardware especializado)                  & Distribuidos a nivel mundial                         & Servidores DNS y anchors            & Distribuidos a nivel mundial                         & Peer-to-peer y cliente-servidor \\ 
		\hline
		Netradar                       & Monitoreo de calidad de WISPs                  & Dispositivos móbiles                                       & Cualquier Lugar                                      & Servidores dedicados                & Localizaciones en Europa, Asia y EEUU                & cliente-servidor                \\ 
		\hline
		SpeedTest                      & Evaluacion de latencia y rendimiento           & Dispositivos web                                           & Cualquier Lugar                                      & Servidores dedicados                & Distribuidos a nivel mundial                         & cliente-servidor                \\ 
		\hline
		Guifinet                       & Evaluacion de rendimiento y monitoreo de uso   & Nodos centrales de la red guifi.net                        & Desplegados en la red guifi.net en Barcelona, España & Nodos centrales de la red guifi.net & Desplegados en la red guifi.net en Barcelona, España & Peer-to-peer                    \\ 
		\hline
		Broadby DSL Report             & Evalauacion de latencia y rendimiento          & Dispositivos web                                           & Cualquier Lugar                                      & Servidores dedicados                & Localizaciones en EEUU                               & cliente-servidor                \\ 
		\hline
		Project BISmark                & Monitoreo de calidad de banda ancha en hogares & Enrutadores OpenWRT, raspberry pi y android & Distribuidos a nivel mundial                         & Servidores dedicados                & Distribuidos a nivel mundial                         & cliente-servidor                \\ 
		\hline
		Pingdom                        & Monitoreo de servidores web                    & Servidores dedicados                                       & Localizaciones en Europa y EEUU                      & Servidores web                      & Cualquier Lugar                                      & cliente-servidor                \\ 
		\hline
		Monitis Visual Traceroute Tool & Evaluacion de alcanzabilidad                   & Servidores dedicados                                       & Localizaciones en Europa, Asia y EEUU                & Dispositivos web                    & Cualquier Lugar                                      & cliente-servidor                \\ 
		\hline
		Uptime Robot                   & Monitoreo de servidores web                    & Servidores dedicados                                       & Localizaciones en Europa, EEUU y Japón               & Servidores Web                      & Cualquier Lugar                                      & cliente-servidor                \\ 
		\hline
		ICSI Netalyzr                  & Evaluacion de acceso a Internet                & Dispositivos web y android                                 & Cualquier Lugar                                      & Servidores dedicados, DNS y proxies & Desconocido                                          & cliente-servidor                \\
		\hline
	\end{tabular}
	\end{flushleft}
	}
	\caption{Tabla del Estado del Arte parte I}
\end{table}


	
\begin{table}[h!]
	\scriptsize{
	\begin{flushleft}
	\begin{tabular}{|p{1.5cm}|p{4.5cm}|p{4.5cm}|p{1.5cm}|p{1.5cm}|}
		\hline
		~                              & Pruebas                                                                                        & Visualizaciones                                                                               & Usuarios    & Referencias    \\ \hline
		Atlas Ripe                     & Ping, Traceroute y DNS.                                                                        & Mapas de Internet con Resultados en los anchors y probes                                      & 10.000      & si             \\ \hline
		Netradar                       & Throughput TCP (mono-flujo), medicion de RTT pasivo con TCP, GPS geo-location.                 & Mapas de calor geográfico con detalles de calidad por area y proveedor de servicio            & 1.000.000   & si             \\ \hline
		SpeedTest                      & Throughput TCP (multi-flujos) sobre HTTP                                                       & Gráfica de velocidad de subida/bajada vs tiempo.                                              & 100.000.000 & si             \\ \hline
		Guifinet                       & Desconocido                                                                                    & Mapa de la red con detalles sobre el uso y rendimiento por enlace.                            & 100.000     & si             \\ \hline
		Broadband DSL Report           & Throughput TCP (multi-stream)                                                                  & Gráfica de velocidad de subida/bajada vs tiempo, gráfica de telaraña de.                      & 1.000.000   & no encontradas \\ \hline
		Project BISmark                & Throughput TCP (multi-flujos) y Ping                                                           & Latencia y throughput vs tiempo.                                                              & 100.000     & si             \\ \hline
		Pingdom                        & Ping sobre HTTP                                                                                & Gráfica de latencia vs tiempo, lista de periodos de actividad e inactividad.                  & 1.000.000   & si             \\ \hline
		Monitis Visual Traceroute Tool & Traceroute                                                                                     & Mapa de la posicion geográfica de los saltos                                                  & Desconocido & no encontradas \\ \hline
		Uptime Robot                   & Ping sobre HTTP                                                                                & Gráfica de latencia vs tiempo, lista de periodos de actividad e inactividad.                  & Desconocido & si             \\ \hline
		ICSI Netalyzr                  & Ping, resolución de DNS, throughput, detection de NATs, chequeo de correctitud de Proxys, etc. & Lista de los eventos relevantes durante el monitoreo y problemas encontrados marcados en rojo & 10.000      & si             \\
		\hline
	\end{tabular}
	\end{flushleft}
	}
	\caption{Tabla del Estado del Arte parte II}
\end{table}

\chapter{Aplicación Web "Optopus Head"}

El sistema de monitoreo de redes "Octopus Monitor" consiste de cuatro elementos principales: (1) La aplicación web "Octopus Head" que funciona como cerebro y coordinador del monitoreo, (2) un conjunto de agentes monitores de red "Tentacle Probe Source" que realizan acciones de monitoreo a partir de las instrucciones de Octopus Head, (3) Nodos a monitorear llamados "Tentacle Probe Destination" y (4) La nube, que ofrece funcionalidades de paso de mensajes y alojamiento de datos compartido entre los distintos entes.

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.8\linewidth]{img/octopusmon}
	\caption{Sistema de Monitoreo "Octopus Monitor"}
	\label{fig:octopusmon}
\end{figure}

En la Figura \ref{fig:octopusmon} se puede ver como hemos usado una analogía sencilla para identificar todos los entes que participan en el sistema, la cabeza del pulpo representa a la aplicacion web, los tentáculos están conformados por monitores de red Tentacle Probe Sorce, nodos Tentacle Probe Destination, y una cantidad variable de nodos intermedios entre ellos, en otras palabras, los tentáculos conforman los enlaces de interes a a monitorear. Se desea que usuarios no-técnicos puedan entender fácilmente el esquema del sistema y así puedan monitorear sus redes y servicios.

Los monitores de red remotos son los que ejecutan el plan de monitoreo, es decir, el conjunto de pruebas específicas planificadas para ejecutarse con el fin de recoger datos relevantes de la red. Es en la aplicacion web que los usuarios pueden definir (y re-definir) las políticas de monitoreo y sincronización de los datos; toda la comunicación entre la aplicacion web y los monitores de red ocurre a través de la nube, la aplicacion web publica mensajes destinados a un monitor específico y los monitores a su vez son notificados por el servicio de la nube cuando hay nuevos mensajes para ellos, el monitor de red se mantiene al día sobre los cambios realizados al plan de monitoreo y ejecuta fielmente el plan de monitoreo.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.9\linewidth]{img/configurationworkflow.png}
	\caption{Definición de políticas de monitoreo}
	\label{fig:monitor-config}
\end{figure}

Este esquema asegura que la aplicacion web sirva como interfaz entre el usuario y los monitores, y simplifica el manejo de monitores de red remotos que podrían potencialmente ser abandonados en sitios de difícil acceso; la nube no solo sirve para almacenar datos a bajo costo y a largo plazo, sino que podemos aprovechar sus funcionalidades para mantener cualquier número de monitores actualizados a baja latencia sin necesidad de mantener un servicio de notificaciones propio. 

\begin{figure}[h]
	\centering
	\includegraphics[width=0.9\linewidth]{img/visualization-workflow-final.png}
	\caption{Sincronización y visualización de datos}
	\label{fig:visual-workflow}
\end{figure}

La aplicacion web es también la responsable de desplegar visualizaciones a partir de los datos obtenidos del monitoreo, para esto, los monitores constantemente suben los datos obtenidos del monitoreo y la aplicacion web a su vez recolecta dichos datos y los procesa en un formato que facilite el cálculo de las visualizaciones, a este proceso lo llamamos \textbf{sincronización} y es otra de las tareas esenciales de la aplicacion web. El proceso de sincronización y visualización de datos puede ser visto en la Figura \ref{fig:visual-workflow}.

A partir de este diseño, es claro que la aplicación web  posea una arquitectura que pueda manejar los recursos disponibles de forma eficiente y así poder ofrecer tanto un servicio web rápido como planificar y ejecutar las tareas de sincronización y cómputo de visualizaciones.


\section{Diseño de la aplicacion web}

Para el desarrollo de esta aplicación se usó el Framework de desarrollo web Django que implementa un patrón MVC, ya que nuestra aplicación web se encargará de manejar tareas computacionalmente intensas, o de largo tiempo de ejecución, Django se integró con el sistema de procesamiento de tareas distribuido Celery, esto no solo con la finalidad de que el servidor web pueda delegar estas tareas y responder rápidamente al usuario, sino también para permitir una mejor escalabilidad del sistema, que entonces podrá responder a un mayor número de peticiones por unidad de tiempo.

\subsection{Arquitectura}

\begin{figure}[h!]
	\centering
	\includegraphics[width=1\linewidth]{img/octopus-arch-final.png}
	\caption{Arquitectura de la aplicacion web.}
	\label{fig:webapp-arch}
\end{figure}

La arquitectura de Octopus Head consiste en cuatro capas, la capa superior o capa de presentación se ejecuta en el navegador del cliente monitor, administrador o quien sea que vea los resultados obtenidos a partir del monitoreo, esta capa se comunica con la capa dos o capa de servicio que es ejecutada por el servidor web, este responde a las peticiones de los usuarios, delega tareas a la capa tres y retira y actualiza datos de la capa cuatro, la capa tres es la encargada de ejecutar tareas largas o computacionalmente intensas así como de planificar e iniciar tareas periódicas, la capa cuatro o capa de datos aloja los datos de la aplicación como usuarios, monitores, planes de monitoreo, historiales, datos recolectados de las redes, reportes, cache, datos en la nube, etc.






\subsection{Capa 1: Presentación}

La capa de presentación o front-end es la interfaz gráfica que permite la interacción del usuario con el sistema de monitoreo, esta se despliega a través de un navegador en cualquier dispositivo conectado a Internet y su propósito es ofrecer al usuario un flujo de trabajo claro para ingresar al sistema, configurar y manejar monitores TPS, planificar pruebas, observar los resultados obtenidos, entre otros.

La capa de presentación puede ser extendida para permitir la implementación de distintos front-ends como aplicaciones nativas para sistemas operativos móviles o de escritorio a través de APIs programáticas. 

\subsection{Capa 2: Servidor Web}
\label{sub:servidorweb}

El servidor web es el punto de entrada a la aplicacion, este responde a las peticiones realizadas desde el front-end a través del protocolo HTTP, el enfoque del servidor web es manejar tareas ligeras de la forma mas rápida posible y retornar respuestas para ofrecer al usuario baja latencia en su interacción con el sistema. 

La ejecucion de tareas largas y pesadas es delegada a la capa de procesamiento asíncrono de tareas, de esta manera un solo usuario no ocupa los recursos del servidor web durante mucho tiempo independientemente de la petición que realice; esto hace posible manejar un mayor numero de usuarios que visiten concurrentemente el sitio, igualmente el servidor web no se sobrecarga aunque exista una alta carga de trabajos de fondo como computo de visualizaciones y sincronizaciones.

El servidor web debe manejar dos tipos de peticiones: aquellas que requieren respuestas dinámicas ajustadas a cada usuario particular que visite el sistema y peticiones de archivos estáticos como css, javascript, imágenes o archivos html pre-definidos que cambien poco o rara vez. A pesar de que la aplicacion web es capaz de manejar ambos tipos de peticiones, cada una de ellas tendrá que pasar por todo el pipeline de Django (middlewares, resolución de URLs, procesamiento de la vista, etc), esta complejidad es innecesaria cuando se trata de archivos estáticos y va a sobrecargar severamente el servidor web en entornos de producción.

Para manejar eficientemente todo tipo de peticiones, debemos implementar un mecanismo que sea capaz de servir los archivos estáticos rápidamente y que sirva como proxy entre el front-end y la aplicacion web, hay una gran variedad de servidores web ligeros como ngnix o lighthttpd diseñados especialmente con este propósito, estos tendrán una sencilla tabla de enrutamiento que decidirá como manejar las peticiones. la aplicacion web podrá correr entonces en un proceso separado y solo atenderá peticiones dinámicas, así se asegurará la eficiencia en el uso de los recursos computaciones disponibles.

\begin{table}[]
	\centering

	\label{table:routing}
	\begin{tabular}{l|l}
		Ruta & Acción            \\ \hline
		/static/ & static serve      \\
		/media/  & static serve      \\
		/        & proxy to web  app
	\end{tabular}
	
		\caption{Tabla de enrutamiento del servidor web}
\end{table}

\subsection{Capa 3: Procesamiento asíncrono de tareas}

Mantener el servidor web ocupado con tareas largas puede degradar su calidad de servicio y ocupar rápidamente sus recursos disponibles, mas aún muchas veces no es posible dejar al usuario esperando indefinidamente mientras se procesa su petición, por este motivo es menester tener un sistema de procesamiento asíncrono de tareas, de manera que las tareas se puedan mandar a ejecutar en segundo plano y ofrecer una respuesta inmediata al usuario.

Ya que es imposible conocer de antemano el número de tareas que se van a estar ejecutando concurrentemente necesitamos una manera de encolar las tareas para que puedan ser ejecutadas cuando alguno de los trabajadores se desocupe, de igual forma, para la implementación de sincronizaciones periódicas de los monitores, necesitamos tener un planificador que inicie las tareas según el horario definido.

La inmensa mayoría de las peticiones realizadas por los usuarios serán manejadas directamente por el servidor web, las tareas delegadas a este capa son las siguientes:
\begin{itemize}
	\item{\textbf{Conexiones con la nube:} A pesar de que la mayoría de las tareas que incluyen conexiones con el API de la nube son bastante sencillas, estas tareas pueden considerarse "de largo tiempo de ejecucion" ya que es necesario obtener recursos presentes en Internet.}
	\item{\textbf{Computo de visualizaciones:} el tiempo y poder de computo necesario para generar visualizaciones depende altamente del tipo de visualización y la cantidad de datos involucrados, algunas de ellas como mapas de calor, periodos de actividad continua o días y horas activos pueden tardar decenas de segundos en calcularse y requerir una cantidad extraordinaria de computo especialmente cuando se están visualizando largos periodos de tiempo.}
	\item{\textbf{Sincronizaciones:} las sincronizaciones combinan varias subtareas altamente costosas: la primera de ellas es descargar los archivos de la nube, esto depende altamente de la cantidad de archivos por descargar y el tamaño de los archivos, la segunda es procesar los archivos para convertirlos a un formato adecuado para pasarlos a la base de datos, la tercera es la inserción a la base de datos, la cual depende de los indices de la tabla y la cantidad de datos en la base de datos.}
\end{itemize}

El sistema de procesamiento asíncrono de tareas está construido usando Celery, Celery no es solo cada uno de los micro-servicios necesarios para el procesamiento distribuido de las tareas, sino también el protocolo de comunicación entre ellos. Hay que tener en mente que el esquema de Celery \textbf{no incluye ninguna autoridad central} que lleve la cuenta de todos los entes participantes. A continuación se explica cada uno de los micro-servicios y su implementación en el marco de Octopus Head. 

\subsubsection{Planificador}

El planificador retrasa la ejecucion de tareas según un horario dado, Celery incluye un planificador llamado Celery Beat que se puede configurar fácilmente para usar la base de datos de la aplicacion web a modo de almacén para sus tareas a ejecutar. Celery Beat consulta constantemente una tabla en la base de datos buscando cambios en las tareas planificadas, la aplicacion web solo modifica esa tabla y deja que Celery Beat se encargue de inciar las tareas en el momento adecuado.

Celery Beat no manda a ejecutar las tareas directamente por un trabajador sino que las inserta a la cola de tareas, es por esto que no es posible asegurar que las tareas se ejecuten justo en el momento planificado, sino que puede existir un retraso variable en la ejecucion basado en el tamaño de las colas y la carga de trabajo de los trabajadores.

\subsubsection{Broker de Mensajería}

El broker de mensajería es un micro-servicio responsable de pasar mensajes entre los entes que encolan tareas (aplicacion web y planificador) y los trabajadores que las ejecutan. Es posible enrutar tareas a trabajadores específicos a través del uso de múltiples colas, por ejemplo sería posible tener una cola para las tareas de sincronización, y otra cola para el computo de visualizaciones y subscribir un distinto número de trabajadores a cada una de ellas. Este sistema asegura una gran granularidad para ejercer control en el orden de ejecucion de las tareas, ya que ademas es posible establecer prioridades, mandando tareas urgentes rápidamente al tope la cola. 

Establecer un esquema apropiado de prioridades y encolamiento es esencial para asegurar un tiempo de espera óptimo, las tareas de cómputo de visualizaciones deben tener una muy baja latencia ya que generalmente el usuario está esperando por una respuesta lo más rápida posible, la subida de mensajes al buzón del monitor puede tener una latencia ligeramente mayor, sin embargo no mayor a unos 10 segundos, las sincronizaciones planificadas por otra parte pueden tener un mayor tiempo de espera en cola donde 10-60 segundos es aceptable.

Existen distintos sistemas que pueden hacer el papel de broker de mensajería, algunas opciones populares incluyen RabbitMQ, un sistema de mensajería robusto y persistente, Redis del que se habló en la Sección \ref{sub:redis} o algún SMBD, la elección del message broker debe depender de volumen de tareas que se va a manejar, el uso de base de datos puede ser aceptable cuando se maneja una cantidad reducida de tareas, pero sistemas más rápidos como RabbitMQ y Redis son preferibles en entornos de producción.

\subsubsection{Trabajadores} \label{sub:trabajadores}

Los trabajadores son los encargados de ejecutar las tareas encoladas, estos se subscriben a una o mas colas y toman las tareas en el tope, determinar la cantidad necesaria de trabajadores para cada cola es esencial para evitar que las colas crezcan indefinidamente (y por lo tanto también, el tiempo de espera de las tareas).

Tener múltiples trabajadores permite tener un gran control sobre los recursos computacionales usados por el sistema, es posible instanciar nuevos trabajadores ejecutándose en distintas maquinas físicas durante los momentos de alta carga del sistema, y liberar estos recursos cuando no se estén usando, esto hace posible manejar una escala variable y minimiza los costos de operación.

Ya que los trabajadores se pueden estar ejecutando en múltiples máquinas físicas es necesario tener alguna manera de controlarlos remotamente, para esto, los trabajadores se subscriben a una cola de 'broadcasting' de alta prioridad en la que se pueden dirigir comandos a todos o a un grupo específico de trabajadores. Existe un conjunto de comandos predefinidos para realizar acciones básicas como revocar tareas, apagar trabajadores o hacer "ping", sin embargo, también es posible implementar nuevos comandos, por ejemplo sería posible implementar un comando para que los trabajadores puedan actualizar su propio código y reiniciar, de este modo podrían aceptar nuevas tareas implementadas.

\subsubsection{Backend de Resultados}

Ya que Celery es un sistema distribuido sin una autoridad central que conozca el estado de todo el sistema, es necesario tener algún micro-servicio donde los distintos entes puedan publicar y consultar el estado de las tareas y su valor de retorno. Tener un backend de resultados permite hacer seguimiento del estado de las tareas e implementar mecanismos como barras de carga que indiquen el progreso de alguna tarea particularmente costosa, es posible crear estados personalizados para estos fines, los estados incorporados por omisión en el sistema se pueden ver en la Tabla \ref{table:task-states}

\begin{table}[h]
	\centering

	\label{table:task-states}
	\begin{tabular}{l|l|l}
		Estado  & Descripcion                            & Metadata                      \\ \hline
		PENDING & La tarea está esperando  ser ejecutada & -                             \\
		STARTED & La tarea ha sido iniciada              & pid y hostname del trabajador \\
		SUCESS  & La tarea se ejecuto con exito          & valor de retorno de la tarea  \\
		FAILURE & La tarea no se ejecuto con exito       & traza de la exepcion          \\
		RETRY   & Se está reintando ejecutar la tarea    & traza de la última excepcion  \\
		REVOKED & La tarea se ha cancelado               & -                            
	\end{tabular}
	\caption{Estados de las tareas}
\end{table}

Para este sistema hemos elegido Redis como backend, ya que guarda el estado de las tares en memoria ofreciendo consultas rápidas y poco costosas a costo, el comportamiento por defecto del backend es poner un tiempo de vencimiento a sus registros, pasado el cual son eliminados y no pueden volver a ser consultados.

\subsection{Capa 4: Datos}

La capa de datos incluye todos los sistemas encargados de almacenar o alojar datos de forma persistente ya sea a través de bases de datos, estructuras de archivos o la nube.

\subsubsection{Base de Datos}

La base de datos es el almacén principal de los datos estructurados de la aplicacion web, almacena todo tipo de información como preferencias del usuario, datos de los monitores, horario de sincronizaciones, parámetros de conexión a Dropbox, y sirve como backend del Framework de Integración de Pruebas del que se hablará en el Capitulo \ref{cap:framework}.

El diseño de la base de datos es uno de los pilares fundamentales del diseño del sistema, el correcto diseño e indexación de las tablas de la base de datos tiene repercusiones importantes en la escalabilidad y tiempo de respuesta del sistema, el diseño de la base de datos se explica a fondo en la Sección \ref{sub:basededatos}

\subsubsection{Caché de archivos}

El caché de archivos es un almacén de archivos con el objetivo principal de almacenar visualizaciones pre-computadas y así evitar la repetición de procesamiento ya realizado y reducir los tiempos de espera del usuario.

Los archivos se guardan en distintos directorios dependiendo del tipo de visualización, cada visualización tiene un código hash asociado que se genera a partir de sus parámetros, por lo tanto el acceso a los archivos en el caché es directo, la velocidad de búsqueda en el caché depende de la implementación del sistema de archivos (por ejemplo ext3, ext4, XFS), los sistemas de archivos modernos pueden manejar cientos de miles de archivos en el mismo directorio sin ningún problema de rendimiento. Usar un caché de archivos ciertamente es mas lento que usar un caché en memoria pero es capaz de almacenar una cantidad mucho mayor de datos a un menor costo. 

\subsubsection{Alojamiento en la nube}

El alojamiento en la nube sirve como intermediario entre la aplicacion web OH y los monitores remotos TPS, la nube ofrece muchas ventajas con respecto a la escalabilidad y facilidad de implementación del sistema. Usamos el alojamiento en la nube para guardar los archivos de trazas generados por los monitores en las redes remotas y también a modo de "buzón" para enviar mensajes a los monitores remotos. 

\subsection{Diseño de la base de datos} \label{sub:basededatos}

La base de datos de Octopus Head esencialmente modela un conjunto de monitores junto con sus enlaces monitoreados (tentáculos), los resultados obtenidos para cada enlace (o monitor) de cada una de sus pruebas, las pruebas y sus parámetros, el historial de cambios en el plan de monitoreo, entre otros. Ya que Django usa un ORM para manejar la base de datos, desde el punto de vista de la aplicación cada entidad es una clase por lo que es posible aprovechar todas las características de la programación orientada a objetos, como herencia de clases, clases abstractas implementación de métodos específicos a un modelo y sobrecarga de métodos de los padres, a continuación se describen las entidades que se desea modelar:

Cada usuario registrado del sistema está representado por el modelo "User" que viene incluido como parte del framework web, este guarda la información mínima necesaria para autenticar al usuario, así como sus grupos y permisos, un usuario autenticado puede estar en uno o mas grupos y puede tener uno o mas permisos, por defecto se tienen tres tipos de usuarios: el usuario normal, el usuario "staff" que puede ingresar la panel de administración del sistema y el superusuario, el superusuario tiene todos los privilegios de lectura y escritura de la base de datos, por lo tanto puede manejar otros usuarios (agregando grupos, permisos, cambiando el tipo de otros usuarios, etc) y hacer cambios a cualquier otra tabla del sistema.

Los usuarios finales del sistema (es decir aquellos que no son staff o superuser) tienen un modelo adicional llamado "UserProfile" (perfil de usuario), para implementar esta funcionalidad podría parecer conveniente sencillamente extender el modelo "User" sin embargo esto interfiere con el mecanismo de autenticación (que no espera que exista otra tabla de usuarios) de modo que implementar una relación uno-a-uno entre el modelo "UserProfile" y el modelo "User" es preferido. El perfil de usuario aloja los detalles adicionales del usuario monitor como credenciales de Dropbox y códigos de confirmación.

El modelo central de la base de datos es el monitor, que representa un Tentacle Probe Source haciendo pruebas en una red remota. Cada usuario posee uno o mas monitores, el monitor está compuesto por un número de enlaces monitoreados y un plan de monitoreo así como su horario de sincronización y sus detalles específicos como zona horaria, posición geográfica, dirección ip entre otros. 

Los enlaces monitoreados son un concepto fundamental en el enfoque de monitoreo de este trabajo, cada uno de ellos consiste de un Tentacle Probe Source (el monitor) y un Tentacle Probe Destination (un nodo monitoreado) y cualquier número de nodos intermedios entre ellos (como enrutadores, proxys, etc), para representar esto usamos el modelo "Link" que guarda el ip del Tentacle Probe Source y otros detalles como posición geográfica, nombre y descripción.

Las pruebas son procedimientos que el usuario puede planificar para que sus monitores ejecuten según una planificación dada, es a esto a lo que llamamos el 'plan de monitoreo', una prueba consiste en cualquier código python ejecutable, generalmente con el objetivo de obtener algún dato de la red monitoreada, desde el punto de vista de la aplicacion web una prueba se modela como una agregación de parámetros configurables, estos son usados para construir un formulario que permite al usuario editar el plan de monitoreo.

Los resultados de las pruebas también llamados trazas se guardan según las características especificas de cada prueba, no existe ningún limitante a la hora de diseñar modelos para los resultados de las pruebas, sin embargo las pruebas implementadas hasta ahora tienen en común un timestamp (el tiempo de ejecucion de la prueba) y el enlace relacionado a la prueba, sin embargo sería posible guardar trazas que no estén relacionadas a ningún enlace (por ejemplo, resultados del sondeo de el número de errores en una interfaz del TPS)

"MonitorTest" es un modelo intermedio que representa una prueba planificada para un monitor y sus parámetros, en otras palabras el conjunto de "MonitorTest" para un monitor conforman el plan de monitoreo, este modelo aloja el tiempo inicial de ejecucion de una prueba, el tiempo final, intervalo entre pruebas, y su estado (activa o inactiva). 

Ya que el usuario tiene la libertad de modificar el plan de ejecucion en cualquier momento dado, se guarda un historial de los cambios hechos a los "MonitorTest" en una tabla a modo de historial, de esta manera es posible reconstruir con que parámetros estaba siendo ejecutada una prueba en cualquier momento especifico, esto no solo con fines informativos para el usuario, sino también puede ser útil para algoritmos de análisis de los datos que necesiten conocer los parámetros de ejecucion en algún momento especifico. 

A los distintos métodos de análisis y visualización los datos que permiten al usuario explorar y obtener información relevante a partir de ellos, las llamamos visualizaciones, computar visualizaciones consiste en retirar los datos seleccionados de la base de datos, pasar estos datos por algún algoritmo de análisis y prepararlos para ser desplegados en alguna forma elegida por el usuario, como mapas de calor, gráficas de barras, mapas, etc.

Las sincronizaciones consisten en recoger los datos dejados por los monitores remotos en la nube y insertarlos a la base de datos, generalmente haciendo algún pre-procesamiento o parsing, se guarda un historial de sincronizaciones no sólo como forma de informar al usuario de la cantidad de archivos recolectados y si ocurrieron errores, el mecanismo de sincronización depende un cursor que indica al sistema cuales son los archivos nuevos o modificados que deben ser insertados, el mecanismo de sincronización se explicará a fondo en la Sección \ref{sub:Recolector}. 

Como se vió en la figura \ref{fig:webapp-arch} el planificador depende de la base de datos para determinar el horario de sincronizaciones, por lo que es necesario un modelo para guardar el horario de sincronizaciones, ya sea este por intervalos o a una hora especifica del día. 

Los reportes son una forma de mostrar y compartir conjuntos de visualizaciones en una sola vista, de esta manera es posible hacer comparaciones de gráficas de distintos enlaces, o incluso de distintos monitores y ademas compartirlas con usuarios no autenticados haciendo los resultados públicos.

\subsubsection{Diagrama de entidad-relación}

La figura \ref{fig:basicl} muestra las entidades primordiales de la base de datos: usuarios, monitores, enlaces y resultados de las pruebas implementadas.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\linewidth]{img/basicl}
\caption{Entidades primordiales de la base de datos}
\label{fig:basicl}
\end{figure}

La figura \ref{fig:tests} muestra las entidades relacionadas al plan de monitoreo, así como su relación con la entidad monitor.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\linewidth]{img/tests.png}
\caption{Entidades del plan de monitoreo}
\label{fig:tests}
\end{figure}

La figura \ref{fig:sync} muestra las entidades relacionadas a mecanismo de sincronizacion y horario de sincronizaciones del monitor.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\linewidth]{img/sync}
\caption{Entidades de sincronizaciones}
\label{fig:sync}
\end{figure}

La figura \ref{fig:results} muestra las entidades relacionadas a las vistas de resultados y reportes.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\linewidth]{img/results}
\caption{Entidades de visualizaciones y reportes}
\label{fig:results}
\end{figure}


\subsubsection{Entidades} \label{subsub:entidades}

Las siguientes tablas resumen las entidades y la función de las entidades que forman parte de la aplicacion web.


\begin{table}[H]
	\caption{Entidades relacionadas al manejo de usuarios}
	\begin{center}
		\begin{tabular}{r|p{2cm}p{8cm}}
			\textbf{\textit{Nombre de la entidad}} & \multicolumn{2}{l}{\textbf{Función}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{User}} & \multicolumn{2}{p{10cm}}{Almacena credenciales e información básica del usuario.}\\
			\textbf{\textit{UserProfile}} & \multicolumn{2}{p{10cm}}{Almacena credenciales de dropbox y códigos de confirmación del usuario .}\\
			
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[H]
	\caption{Entidades relacionadas a los monitores}
	\begin{center}
		\begin{tabular}{r|p{2cm}p{8cm}}	
			\textbf{\textit{Nombre de la entidad}} & \multicolumn{2}{l}{\textbf{Función}}\\
			\hline
			\textbf{\textit{Monitor}} &
			 \multicolumn{2}{p{10cm}}{Almacena detalles del Tentacle Probe Source como dirección ip, posición geográfica y zona horaria.}\\
			\textbf{\textit{Link}} & \multicolumn{2}{p{10cm}}{Almacena detalles del Tentacle Probe Destination como dirección ip, posición geográfica y si está activo para el monitoreo.}\\
			\textbf{\textit{TracePing}} & \multicolumn{2}{p{10cm}}{Almacena el resultado de una prueba de ping como marca de tiempo, rtt y TPD relacionado.}\\
			\textbf{\textit{TraceHttping}} & \multicolumn{2}{p{10cm}}{Almacena el resultado de una prueba de httping como marca de tiempo, tiempo de respuesta, código de estado y TPD relacionado.}\\
			\textbf{\textit{TraceTraceroute}} & \multicolumn{2}{p{10cm}}{Almacena el resultado de una prueba de traceroute como marca de tiempo, número de saltos, alcanzabilidad y TPD relacionado.}\\
			\textbf{\textit{TraceIperf}} & \multicolumn{2}{p{10cm}}{Almacena el resultado de una prueba de iperf como marca de tiempo, dirección del flujo, rendimiento obtenido en bytes por segundo y TPD relacionado.}\\
			\textbf{\textit{Test}} & \multicolumn{2}{p{10cm}}{Almacena el nombre, descripción y tipo de una prueba.}\\
			\textbf{\textit{Parameter}} & \multicolumn{2}{p{10cm}}{Almacena el nombre, descripción tipo de dato y otros detalles sobre un parámetro relacionado a una prueba.}\\
			\textbf{\textit{MonitorTest}} & \multicolumn{2}{p{10cm}}{Tabla intermedia entre monitor y test que almacena una prueba planificada para un monitor, así como su tiempo inicial, final, su estado y parámetros.}\\
			\textbf{\textit{MonitorTestHistory}} & \multicolumn{2}{p{10cm}}{Almacena los cambios realizados a una prueba planificada así como sus parámetros y el periodo en que estos fueron efectivos.}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[H]
	\caption{Entidades relacionadas al planificador}
	\begin{center}
		\begin{tabular}{r|p{2cm}p{8cm}}	
			\textbf{\textit{Nombre de la entidad}} & \multicolumn{2}{l}{\textbf{Función}}\\
			\hline
			\textbf{\textit{Syncronization}} & \multicolumn{2}{p{10cm}}{Almacena el resultado de una planificación y algunos detalles como número de archivos recolectados y número de errores.}\\
			\textbf{\textit{DropboxCursor}} & \multicolumn{2}{p{10cm}}{Almacena un cursor obtenido de la última sincronizacion de un monitor.}\\
			\textbf{\textit{IntervalSchedule}} & \multicolumn{2}{p{10cm}}{Almacena el intervalo entre sincronizaciones de un monitor.}\\
			\textbf{\textit{CustomSchedule}} & \multicolumn{2}{p{10cm}}{Almacena la hora de y los días de la semana en que debe sincronizarse un monitor.}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[H]
	\caption{Entidades relacionadas a las visualizaciones y reportes}
	\begin{center}
		\begin{tabular}{r|p{2cm}p{8cm}}	
			\textbf{\textit{Nombre de la entidad}} & \multicolumn{2}{l}{\textbf{Función}}\\
			\hline
			\textbf{\textit{ResultView}} & \multicolumn{2}{p{10cm}}{Almacena el nombre y descripción de una visualización así como su tipo y slug.}\\
			\textbf{\textit{Report}} & \multicolumn{2}{p{10cm}}{Almacena el nombre y descripción de un reporte, su dueño y tipo (publico o privado).}\\
			\textbf{\textit{ResultItem}} & \multicolumn{2}{p{10cm}}{Almacena el url relacionado a una visualización que es parte de un reporte y comentarios.}\\
		\end{tabular}
	\end{center}
\end{table}

\subsubsection{Relaciones}

\begin{itemize}
	\item{\textbf{users - userprofiles (1-1)}: Un usuario solo puede tener un perfil de usuario.}
	\item{\textbf{users - monitors (n-1):} Un usuario puede ser dueño de cero o mas monitores, pero un monitor solo puede tener un dueño.}
	\item{\textbf{monitors - links (n-1):} Un monitor puede tener cero o mas tentacles, pero un tentacle solo puede estar en un monitor.}
	\item{\textbf{links - traces (n-1):} Un enlace puede tener cero o mas trazas relacionadas, pero una traza solo puede estar relacionada a un enlace.}
	\item{\textbf{test - parameter (n-1):} Una prueba puede tener uno o mas parámetros, pero un parámetro solo puede ser parte de una prueba.}
	\item{\textbf{test - monitor (n-n):} Una prueba puede ser planificada cero o mas veces en cero o mas monitores.}
	\item{\textbf{monitortest - monitortesthistory (n-1):} Una instancia de monitortest puede tener una o mas entradas en el historial, pero una entrada en el historial solo se refiere a un monitortest.}
	\item{\textbf{monitor - synchronization(n-1):} Un monitor puede ser sincronizado cero o mas veces pero una sincronizacion solo puede estar relacionada a un monitor.}
	\item{\textbf{synchronization - dropboxcursor (n-1):} Una sincronizacion puede tener uno o mas cursores, pero un cursor solo pertenece a una sincronizacion.}
	\item{\textbf{monitor - intervalschedule (1-1):} Un monitor solo puede tener un horario de sincronizacion en intervalo y este solo puede pertenecer a un monitor.}
	\item{\textbf{monitor - customschedule (1-1):} Un monitor solo puede tener un horario de sincronizacion personalizado y este solo puede pertenecer a un monitor.}
	\item{\textbf{test - resultview (n-1):} Una prueba puede tener una o mas vistas de resultados, pero una vista de resultados solo puede pertenecer a una prueba.}
	\item{\textbf{user - report (n-1):} Un usuario puede ser dueño de cero o mas reportes y un reporte solo puede pertenecer a un usuario.}
	\item{\textbf{report - reportitem (1-1):} Un reporte puede tener uno o mas items y un item solo puede pertenecer a un reporte.}
\end{itemize}

\subsection{Diseño de Pantallas}

Todas las pantallas del sistema fueron creadas bajo el paradigma del diseño web adaptable, es decir que pueden ajustarse a cualquier resolución de pantalla sin reducir la usabilidad o sacrificar la experiencia del usuario, el servidor no tiene que decidir entre un conjunto de plantillas para distintas resoluciones sino que envía al cliente un solo documento HTML y este combina las reglas de presentación de archivos css y la lógica en archivos javascript para desplegar una pagina web adaptada al dispositivo del usuario.

Ya que una aplicacion web está compuesta por decenas de vistas que comparten componentes como barras de navegación, cabeceras, y pies de pagina, Django incluye un micro-lenguaje de plantillas con funcionalidades de herencia e inclusión de plantillas y estructuras de repetición y decisión, esto hace que sea posible tener una taxonomía de plantillas, de manera que solo es necesario escribir los elementos comunes a un conjunto de plantillas una vez y crear nuevas pantallas en el tope de otras. Al proceso de combinar los datos de la base de datos y la petición del usuario, junto con una plantilla predefinida en la aplicacion para generar páginas web personalizadas se le llama \textit{rendering}.

Todas las plantillas heredan de una plantilla base, esta incluye la declaración del archivo html, la cabecera y define bloques que pueden ser sobreescritos por las plantillas "hijas", los bloques que define la plantilla base son: \textbf{(1) bloque de título} permite definir el titulo de la pagina \textbf{(2) bloque de estilo} permite reemplazar o agregar archivos de estilo/javascript \textbf{(3) bloque de modales} permite introducir código antes del cuerpo del documento \textbf{(4) bloque de contenido} bloque principal para el contenido de la pagina \textbf{(5) bloque de javascript} bloque para incluir archivos y métodos javascript, los archivos javascript se cargan al final para acelerar la carga de las páginas. La plantilla base es a su vez heredada por la plantilla "dashboard" que incluye el menú de navegación lateral y a su vez esta es heredada por la plantilla "monitor" que agrega el submenú del monitor.

A continuación se muestra el diseño de las principales pantallas de la interfaz de usuario del servicio web.

\begin{itemize}
	\item{\textbf{Pantalla Inicial del sistema,} esta es la pantalla principal del servicio web disponible en linea y sirve como punto de inicio donde los usuarios no-autenticados pueden registrarse, iniciar sesión y obtener información básica sobre el sistema.}
	
	\begin{figure}[h!]
\centering
\includegraphics[width=0.7\linewidth]{img/1-landing-page}
\caption{Pantalla Inicial del sistema}
\label{fig:1-landing-page}
\end{figure}

	
	\item{\textbf{Pantalla de registro de usuario,} en esta pantalla un usuario que desee utilizar el sistema de monitoreo introduce su nombre de usuario, contraseña y correo electrónico para registrarse}
	
	\item{\textbf{Pantalla de inicio de sesión,} en esta pantalla un usuario autenticado puede introducir su nombre de usuario y contraseña para iniciar sesión, también se incluyen enlaces para recuperar contraseña o crear una nueva cuenta en caso de no tener una.}
	
	\item{\textbf{Pantalla "Home",} esta es la pantalla de bienvenida al sistema para un usuario autenticado, esta muestra algunas estadísticas rápidas del uso del sistema (como número de monitores, tentáculos, pruebas, sincronizaciones ejecutada, etc), así como enlaces a las principales subsecciones de cada monitor. Todas las pantallas a partir de ahora comparten un menú de navegación superior con enlaces al home, y funcionalidades para ver el perfil de usuario y hacer logout y un menú de navegación lateral con enlaces a las principales secciones del sistema}
	
	\item{\textbf{Pantalla de selección de monitores,} esta pantalla muestra los monitores del usuario y le permite seleccionar alguno de ellos para dirigirlo a la pantalla del monitor, ademas incluye un botón para crear nuevos monitores.}
	
	\item{\textbf{Pantalla de creación de monitores,} en esta pantalla se introducen del detalles del monitor a crear como nombre, descripción, dirección ip, sistema operativo del dispositivo host y zona horaria del monitor, todas las pantallas.}
	
	\item{\textbf{Pantalla del monitor,} esta es la pantalla principal del monitor donde se muestran los detalles del monitor, un mapa de la red mostrando la localizacion de los distintos dispositivos de red (TPS y TPS) generado a partir de la información suministrada por el usuario y una lista de verificación para ayudar al usuario a seguir los pasos para monitorear una red. Todas las vistas relacionadas a un monitor específico despliegan un submenú de navegación para visitar las distintas subsecciones de manejo del monitor como tentáculos, resultados y sincronizaciones.}
	
	\begin{figure}[h!]
\centering
\includegraphics[width=0.7\linewidth]{img/3-monitor}
\caption{Pantalla del monitor}
\label{fig:3-monitor}
\end{figure}

	
	\item{\textbf{Pantalla de tentáculos,} esta pantalla muestra los detalles de los distintos tentáculos de un monitor, y incluye enlaces para registrar nuevos tentáculos y editar los detalles de los existentes.}
	
	\item{\textbf{Pantalla de Plan de monitoreo,} esta pantalla permite ver el plan de monitoreo por tipo de prueba, incluye enlaces para editar pruebas planificadas y para planificar nuevas pruebas ya sean periodicas o de una sola vez. En caso de que hayan muchas pruebas planificadas separa el contenido en páginas numeradas}
	
	\begin{figure}[h!]
\centering
\includegraphics[width=0.7\linewidth]{img/4-plan}
\caption{Pantalla de Plan de monitoreo}
\label{fig:4-plan}
\end{figure}

	
	\item{\textbf{Pantalla de planificación de pruebas,} esta pantalla permite agregar pruebas al plan de monitoreo, si se trata de una prueba de una sola vez permite elegir la hora y fecha de ocurrencia, en el caso de pruebas periódicas permite elegir fecha inicial, fecha final e intervalo entre pruebas, en todos los casos se incluye el formulario para fijar los parámetros de ejecucion de la prueba}
	
	\item{\textbf{Pantalla de detalles de la prueba,} esta pantalla muestra los parámetros activos de una prueba planificada en un formulario editable, así como opciones para habilitar o deshabilitar. En el panel lateral se muestra el historial de la prueba, mostrando los periodos en que estuvo inactiva y sus distintos parámetros en periodos de inactividad, así como enlaces para volver a activar parámetros anteriores en cualquier punto de la historia.}
	
	\begin{figure}[h!]
\centering
\includegraphics[width=0.7\linewidth]{img/4-testview}
\caption{Pantalla de detalles de la prueba}
\label{fig:4-testview}
\end{figure}

	
	\item{\textbf{Pantalla de resultados,} esta pantalla muestra todas las visualizaciones disponibles para un monitor (a partir de las pruebas activas o planificadas en algún momento) y una barra de búsqueda para filtrar los resultados.}
	
	\item{\textbf{Pantalla de visualización de resultados,} esta pantalla muestra un formulario para introducir los datos a visualizar y una barra de herramientas, con opciones para re-computar la visualizaciones, obtener enlaces directos para compartir o agregar la visualización a un reporte dado. Esta pantalla muestra un animación de carga para indicar que una gráfica se está computando o retirando del servidor y mensajes de error en caso de que el servicio no esté disponible o un problema haya aparecido}
	
	\begin{figure}[h!]
\centering
\includegraphics[width=0.7\linewidth]{img/4-result}
\caption{Pantalla de visualización de resultados}
\label{fig:4-result}
\end{figure}

	
	\item{\textbf{Pantalla de sincronizaciones,} esta pantalla muestra el tiempo desde la última sincronizacion y el tiempo  para la próxima así como un botón para forzar una sincronizacion inmediata, también muestra un formulario para definir el horario de sincronizacion y en un panel lateral muestra el historial de sincronizaciones, este ofrece información sobre la cantidad de archivos recolectados y el numero de errores encontrados durante las últimas sincronizaciones}
	
	\item{\textbf{Pantalla de reportes,} esta pantalla muestra una tabla de los reportes del usuario con enlaces para ver cada uno de ellos y su última fecha de modificación así como un botón para ir al formulario de creación de reportes}
	
	\item{\textbf{Pantalla de visualización y edición de reporte,} esta pantalla puede desplegarse de distintas maneras según el usuario que la observe, si se trata del usuario al que pertenece el reporte entonces este verá una barra de herramientas para agregar visualizaciones al reporte, cambiar la privacidad del reporte (publico o privado) o editar y borrar, del mismo modo podrá editar los comentarios de cada una de las visualizaciones o quitarlas del reporte. Un usuario que no sea dueño del reporte solo podrá leer su contenido y observar las visualizaciones}
	
	\begin{figure}[h!]
\centering
\includegraphics[width=0.7\linewidth]{img/6-report}
\caption{Pantalla de visualización y edición de reporte}
\label{fig:6-report}
\end{figure}

	
	\item{\textbf{Pantalla de cuenta del usuario,} esta pantalla muestra los detalles de la cuenta del usuario, así como enlaces para cambiar la contraseña y renovar el token de acceso a dropbox en caso de que en algún momento este haya sido revocado}
	
	\item{\textbf{Pantalla de descargas,} en esta pantalla se muestra una lista de las descargas disponibles, como distintas versiones del montitor de red o publicaciones relacionadas}
	
	\item{\textbf{Pantalla de ayuda,} esta pantalla muestra tópicos de ayuda al usuario como conceptos básicas, manual de instalación básico, especificaciones de las pruebas, etc.}
	
\end{itemize}

\subsection{Diseño de URLs}

Ya que la aplicacion web consiste de un largo conjunto de vistas, debemos diseñar URLs que apunten a cada una de las vistas de forma ordenada y lógica, para esto, se ha usado una convención en la que la unidad principal de operación es una colección de objetos, como monitores, o reportes, a continuación se muestran ejemplos de las reglas usadas para diseñar los URLs:

\begin{itemize}
	\item{Operaciones sobre colecciones:

\begin{itemize}
	\item{\textbf{GET /monitors} retorna la lista de monitores}
	\item{\textbf{GET /monitors/new} retorna un formulario para crear un nuevo monitor}
	\item{\textbf{POST /monitors/new} somete los campos para crear un nuevo monitor}
\end{itemize} 
}

	\item{Operaciones sobre un registro:

\begin{itemize}
			\item{\textbf{GET /monitor/1} retorna el primer monitor}
			\item{\textbf{GET /monitor/1/edit} retorna un formulario para editar el primer monitor}
			\item{\textbf{POST /monitor/1/edit} somete los campos para editar el monitor 1}
			\item{\textbf{GET /monitor/1/delete} destruye el primer monitor y todos sus registros relacionados}
\end{itemize} 
}

\item{Operaciones sobre relaciones de un registro:
	
	\begin{itemize}
		\item{\textbf{GET /monitor/1/links} retorna la lista de enlaces del monitor}
		\item{\textbf{GET /monitor/1/link/7/edit} retorna un formulario para editar el enlace con id \#7 del primer monitor.}
		\item{\textbf{POST /monitor/1/link/7/edit} somete los campos para editar el enlace con id \#7 del primer monitor.}
	\end{itemize} 
}

\item{Invocar operaciones especiales sobre un registro:
	
	\begin{itemize}
		\item{\textbf{GET /monitor/1/sync/now} manda a sincronizar el primer monitor inmediatamente}
		\item{\textbf{GET /monitor/1/test/12/toggle} activa o desactiva la prueba con id \#12 del primer monitor.}
		\item{\textbf{POST /monitor/1/form/average-rtt-heatmap/} somete los campos del formulario del mapa de calor de rtt para el primer monitor.}
	\end{itemize} 
}
		
		
\end{itemize}  

\section{Componentes}

En esta sección se explican los distintos componentes de software que son parte de la aplicacion web y su funcionalidad.

\subsection{Enlazador de cuentas de Dropbox}

Para realizar todas las tareas relacionadas con el almacenamiento remoto en la nube, la aplicación web hace peticiones a nombre de un usuario de Dropbox, sin embargo primero es necesario realizar un proceso de autenticación que dará permisos a la aplicacion web de realizar estas peticiones. El proceso de autenticación es un algoritmo a dos pasos que se puede observar a continuación:


\begin{algorithm}
	\caption{Enlazamiento con Dropbox}\label{alg:linking}
	\begin{algorithmic}[1]
		\Procedure{link\_dropbox\_account}{request}
		\If {$request.method = \textit{'POST'}$}
			\State $\textit{form} \gets \Call{DropboxCodeForm }{}$
			\If {$\textit{form} \text{ is valid}$}
				\State $\textit{flow} \gets$ \Call{DropboxOAuth2FlowNoRedirect}{}
				
				\State $\textit{access\_token , user\_id} \gets$\textit{flow}.\Call{finish}{\textit{form.code}}
				\State $\textit{profile} \gets \Call{get}{\textit{UserProfile},id=request.user.id}$\Comment{Retira un objeto UserProfile por su id de la base de datos}
				\State $\textit{profile.dropbox\_access\_token} \gets \textit{access\_token}$
				\State $\textit{profile.dropbox\_user\_id} \gets \textit{user\_id}$
				\State$\textit{profile.}\Call{save}$\Comment{Guarda los cambios en la base de datos}
				
				\Return \Call{HttpResponseRedirect}{"/dropbox/link-account/done"}
			\EndIf
		\Else
			\State $\textit{flow} \gets
			\Call{DropboxOAuth2FlowNoRedirect}{}$
			\State $\textit{url} \gets \textit{flow}$.\Call{start}{}
			\State $\textit{form} \gets \Call{DropboxCodeForm }{}$
			
		\EndIf
		
		\Return \Call{render}{request,"link\_dropbox.html",\textit{form}}

		\EndProcedure
	\end{algorithmic}
\end{algorithm}

La estructura de esta función es similar a muchas otras que manejan datos suministrados por el usuario: si la petición es de tipo GET entonces devuelve el formulario se devuelve un formulario en blanco donde el usuario deberá introducir algunos datos. Si la petición es de tipo POST pasamos a validar el formulario si es válido, entonces hacemos alguna operación como actualizar la base de datos y redireccionamos al usuario a una vista indicando el éxito de la operación, de modo contrario el formulario es inválido y se dibuja el formulario mostrando los mensajes de error correspondientes.

En este caso cuando el usuario visita la ruta \textit{'/dropbox/link-account/'} con el método GET la aplicacion web crea un URL hacia el sitio de Dropbox y muestra al usuario un formulario con una caja de texto para introducir un código y un enlace con el URL generado previamente, cuando el usuario hace click al enlace, este lo lleva al sitio de Dropbox que a su vez despliega un dialogo preguntando al usuario si dará permiso a la aplicacion de Octopus Monitor para hacer cambios en su carpeta personal, en caso positivo se genera un token que el usuario debe copiar en el formulario, cuando el usuario somete el formulario una petición HTTP POST se envía al servidor, entonces este llama al método "finish" con el token, este método retorna el código de acceso al Dropbox del usuario para nuestra aplicacion y el identificador del usuario, guardamos los cambios en la base de datos y llevamos al usuario a una página indicando que el proceso de enlazamiento fue exitoso. 

A partir de este momento tenemos los dos elementos necesarios para hacer peticiones al API de Dropbox: los permisos sobre la carpeta en la nube del usuario y el token de acceso a su dropbox.

\subsection{Subidor de mensajes}

Una de las tareas fundamentales de la aplicacion web es mantener a los monitores remotos informados de los cambios hechos al plan de monitoreo por parte de los usuarios, para esto usamos un concepto similar al de un buzón de correo electrónico, la aplicacion web sube archivos a modo de mensajes a una carpeta en la nube que hace las veces de buzón, hay dos tipos mensajes: aquellos relacionados a los enlaces monitoreados (nuevo enlace registrado o cambios a un enlace existente) y los relacionados a las pruebas (nueva prueba planificada, cambios a los parámetros, cambios al intervalo entre pruebas, prueba deshabilitada, etc.)

Los mensajes que se suben a la nube se escriben en formato json, este formato ofrece grandes ventajas para el desarrollo de aplicaciones distribuidas ya que es fácil de codificar del lado del servidor y fácil de decodificar del lado del monitor es mucho mas ligero que otros formatos como XML y al mismo tiempo es legible para seres humanos, todos las funciones que suben archivos a la nube funcionan de forma simular:
\begin{enumerate}
	\item{Se retira de la base de datos el token de acceso a Dropbox del usuario.}
	\item{Se determina el nombre del archivo a subir, concatenando el id del monitor, el nombre de la carpeta buzón y el tipo de archivo e identificador de la prueba o enlace, por ejemplo:
	\begin{itemize}
		\item{\textbf{/monitor1/mailbox/test\_12:} especifica los detalles de la prueba id \#12 del monitor id \#1.}
		\item{\textbf{/monitor1/mailbox/link\_6:} especifica los detalles del enlace id \#6 del monitor id \#1.}
	\end{itemize}
		 }
	\item{Se crea un objetivo tipo archivo o buffer en memoria.}
	\item{Se codifica el contenido del archivo en formato json, y se inserta en el buffer; el contenido será un diccionario con los detalles relevantes a la prueba o enlace.}
	\item{Se sube el archivo a la nube a través del API de Dropbox.}
\end{enumerate}

\begin{algorithm}
	\caption{Subir prueba a Dropbox}\label{alg:upload}
	\begin{algorithmic}[1]
		\Procedure{upload\_test\_file}{monitor\_test,data}
		\State $\textit{user} \gets \textit{monitor\_test.monitor.owner}$ \Comment{Retira el usuario relacionado}
		
		\State $\textit{profile} \gets \Call{get}{\textit{UserProfile},id=user.id}$\Comment{Retira el perfil de usuario}
		\State $\textit{client} \gets \Call{DropboxClient}{profile.dropbox\_access\_token}$
		\State $\textit{directory} \gets \textit{MONITOR\_FOLDER\_NAME}+\textit{monitor\_test.monitor.id} + \text{'mailbox'} $
		\State $\textit{filename} \gets \textit{directory} + \text{'test\_'} + \textit{monitor\_test.id} + \text{'.json'}$
		\State $\textit{buffer} \gets \Call{StringIO}{}$ \Comment{Crea un objeto tipo archivo en memoria}
		
		\State$\textit{json} \gets \Call{Dumps}{data}$\Comment{Codifica una cadena de caracteres json a partir de un objeto python}
		\State$\textit{buffer}.\Call{Write}{json}$
		
		\State $\textit{client.}\Call{put\_file}{filename,buffer,overwrite=True}$
		
		\Return
		
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Los mensajes deben contener la información necesaria para que el monitor pueda reconstruir el plan de monitoreo a partir de ellos, la estructura y posibles valores de los mensajes pueden ser vistos en la Tabla \ref{tab:testmessage} para los mensajes relacionados a las pruebas y en la Tabla \ref{tab:linkmessage}

\begin{table}
	
	\begin{tabular}{p{2cm}|p{4cm}|p{8cm}}
		Clave      & Valor                & Descripción                                                                        \\ \hline
		disable    & true$|$false           & Si es \textit{false} indica que la prueba debe ser desactivada                     \\ 
		name       & cadena de caracteres & nombre de módulo de la prueba                                                      \\ 
		end\_date   & fecha$|$null           & fecha final de la prueba, si es \textit{null} la prueba se ejecuta indefinidamente \\ 
		start\_date & fecha                & fecha inicial de la prueba                                                         \\ 
		interval   & entero positivo$|$null & Indica el intervalo entre pruebas, si es nulo, la prueba se ejecuta una sola vez   \\ 
		kwargs     & diccionario          & Conjunto de pares $<$nombre,valor$>$ que representa los parámetros de la prueba    \\
	\end{tabular}
	\caption{Contenido del mensaje de prueba planificada}
	\label{tab:testmessage}
\end{table}

\begin{table}
	\begin{tabular}{p{2cm}|p{4cm}|p{8cm}}
	
		Clave  & Valor                & Descripción                                                    \\ \hline
		status & true$|$false           & Si es \textit{false} indica que el enlace debe ser desactivado \\ 
		ip     & cadena de caracteres & dirección ip del TPS del enlace.                               \\ 
		id     & entero positivo      & identificador único del enlace                                 \\ 
		host   & cadena de caracteres & nombre de dominio del TPS del enlace.                          \\
	\end{tabular}
	\caption{Contenido del mensaje de enlace monitoreado}
	\label{tab:linkmessage}
\end{table}

\subsection{Sincronización de datos} \label{sub:Recolector}

El objetivo de la realización de pruebas en las redes a monitorear es recolectar una cantidad de datos suficientes para obtener información del estado de la red, si el monitor tiene un plan de monitoreo definido y está realizando pruebas, este dejará en la nube archivos con resultados de forma constante; es trabajo de la aplicacion web a su vez recolectar estos archivos y introducirlos a la base de datos en un formato tal que permita generar visualizaciones de la forma mas conveniente posible para el usuario, en el marco de este sistema, a este proceso se le da el nombre de "sincronizacion".

El algoritmo general de sincronización (Algoritmo \ref{alg:sync}), retira de la base de datos el monitor a sincronizar, el token de acceso a Dropbox del usuario y las pruebas activas para el monitor, luego para cada prueba llama a una subrutina que descarga los archivos, los procesa y introduce los resultados obtenidos en la base de datos finalmente totaliza el número de archivos recolectados, el número de errores (ya sea errores de parsing de los archivos o problemas de conexión a Dropbox), guarda en la base de datos el registro de la sincronización, los cursores (de los cuales se hablará próximamente) y actualiza el tiempo de ultima sincronización del monitor.


\begin{algorithm}
	\caption{Sincronizar monitor}\label{alg:sync}
	\begin{algorithmic}[1]
		\Procedure{syncronize}{monitor\_id}
		\State $\textit{monitor} \gets \Call{Get}{Monitor,id=monitor\_id}$ \Comment{Retira el monitor por su id}
		
		\State $\textit{profile} \gets \Call{get}{\textit{UserProfile},id=monitor.owner.id}$\Comment{Retira el perfil de usuario}
		\State $\textit{client} \gets \Call{DropboxClient}{profile.dropbox\_access\_token}$
		
		\State $\textit{tests} \gets \text{Get all active tests for this } \textit{monitor} $
		
		\State $\textit{cursors} \gets \text{empty dictionary}$
		\State $\textit{files} \gets 0$
		\State $\textit{errors} \gets 0$
		
		
		\For{\textit{test} \textbf{in} \textit{tests}}
		\State $\textit{cursor,\_files,\_errors} \gets \Call{\_Syncronize}{test,monitor,client}$
		\State $\text{Insert cursor on} \textit{ cursors } \text{using} \textit{ test } \text{as key}$
		\State $\textit{files} \gets \textit{files} + \textit{\_files}$
		\State $\textit{errors} \gets\textit{errors} + \textit{\_errors}$
		\EndFor
		
		\State $\textit{sync} \gets \Call{Syncronization}{monitor,files,errores}$
		\State $\textit{sync.}\Call{Save}{}$
		
		\For{\textit{key,value} \textbf{in} \textit{cursors}}
		\State $\textit{cursor} \gets \Call{DropboxCursor}{value,sync,monitor\_test}$
		\State $\textit{cursor.}\Call{Save}{}$
		
		\EndFor
		
		\State $\textit{monitor.last\_sync\_time} \gets \text{get current time}$
		\State $\textit{monitor.}\Call{Save}{}$
		
		\Return
		
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Debemos recordar que los resultados de las pruebas se guardan en una carpeta por prueba, donde constantemente se están guardando nuevos archivos, por lo tanto, la subrutina de sincronización debe determinar cuales son los archivos nuevos y modificados desde la ultima sincronización, para esto, el API de Dropbox provee el método \textit{delta}, que determina los cambios realizados a una carpeta a partir de un momento específico, a continuación puede verse un ejemplo de la respuesta en formato json obtenida tras llamar el método delta para una carpeta:

\begin{lstlisting}][h,frame=single]
{
   "reset":false,
   "cursor":"AAHskXVmJSRVG_bgh4Oq2VPQqG79nWM26Tl8jSmR...",
   "has_more":false,
   "entries":[
      [
         "/monitor1/ping/link_2_2015_11_02_15.txt",
         {
            "revision":3,
            "rev":"30ec9923d",
            "thumb_exists":false,
            "bytes":0,"modified":
            "Wed, 20 Mar 2013 05:58:43 +0000",
            "path":"/proj1",
            "is_dir":true,
            "icon":"folder_app",
            "root":"app_folder",
            "size":"0 bytes"
         }
      ],
   ]
}
\end{lstlisting}

Como se puede observar, se trata de un diccionario con cuatro entradas:
\begin{itemize}
	\item{reset: determina si se debe "limpiar" el estado local antes de procesar las entradas delta, es verdadero solo durante la primera llamada a delta o en raras ocasiones.}
	\item{cursor: el cursor es una cadena de caracteres de longitud 64, y representa el estado de la carpeta en un momento dado, se puede usar en llamadas sucesivas de "delta" para obtener los cambios a partir de ese momento específico.}
	\item{has\_more: determina si hay mas entradas delta en la carpeta, en tal caso es necesario volver a llamar el método delta inmediatamente de nuevo, esto solo es necesario cuando hay grandes cantidades archivos modificados.}
	\item{entries: es una lista de "entradas delta" cada entrada representa un archivo o carpeta que cambió desde la ultima llamada a delta, cada entrada es un par $<$path,metadata$>$ donde "path" es el nombre del archivo y "metadata" es un diccionario conteniendo algunos datos relevantes al archivo, si "metadata" es "null" indica que el archivo fue eliminado.}
\end{itemize}

El algoritmo de sincronización depende del cursor para determinar los cambios desde la última sincronización, este llama al método delta y obtiene la lista de "entradas delta" luego recorre aquellas entradas delta cuya metadata no es nula (es decir, que no fueron borrados) y le pasa el contenido del archivo a un algoritmo de parsing, que lo lee, procesa e inserta su contenido en el formato apropiado en la base de datos, debemos recordar que cada archivo de traza puede tener un formato distinto dependiendo del tipo de prueba al que pertenezca, por lo que también es trabajo de del algoritmo de sincronización elegir el método correcto al cual pasará el archivo.

\subsection{Computo de visualizaciones}

El computo de las visualizaciones consiste de tres fases comunes a todas las visualizaciones, primero, los datos necesarios son retirados de la base de datos, después estos datos son transformados o pre-procesados de alguna manera, por ejemplo, los timestamps se transforman en horas localizadas según la zona horaria del monitor, o se eliminan valores atípicos de la muestra y finalmente estos datos se combinan con una plantilla para generar una página HTML. 

Muchas de las visualizaciones obtenidas en el sistema se pueden generar trivialmente pasando a la biblioteca de rendering de gráficas un arreglo de pares $<$x,y$>$ por ejemplo rtt vs tiempo, sin embargo otras visualizaciones requieren de algoritmos de análisis que hagan algún pre-procesamiento de los datos y saquen algún tipo de conclusión para mostrar al usuario, a continuación se explica el calculo de las visualizaciones no-triviales del sistema.

\subsubsection{Cálculo de Mapas de Calor}

En este trabajo usamos mapas de calor para representar el valor del tiempo de respuesta promedio en relación a la fecha y la hora del día, los valores "altos" están representados por colores cálidos y los valores "bajos" están representados por colores fríos; cabe destacar que un valor de "alto" para un red de fibra óptica puede ser "bajo" para una red satelital, de modo que el cálculo estos valores dependen unicamente de los datos en la muestra. 

Los mapas de calor permiten evaluar rápidamente la fluctuación del RTT durante un día especifico o notar patrones a largo plazo, otra ventaja de los mapas de calor es que es posible observar periodos de inactividad de la red como "espacios en blanco" en la gráfica ya que para estos periodos no hay datos.

Los parámetros de los mapas de calor son los siguientes:
\begin{itemize}
	\item{\textbf{Enlace:} el enlace seleccionado para observar}
	\item{\textbf{Intervalo de agrupación:} la "granularidad" del mapa de calor, a mayor intervalo de agrupación mas muestras se van a promediar por intervalo, el valor máximo es 60 minutos, lo cual resultará en un mapa de calor con 24 puntos por día, el menor es 10 minutos, lo cual resultará en un mapa de calor con 144 puntos por día}
	\item{\textbf{Rango de tiempo:} ajusta el periodo de tiempo seleccionado para mostrar, se puede seleccionar por meses, años o "todo el tiempo".}
\end{itemize}

Para calcular el mapa de calor debemos primero filtrar las muestras por enlace y rango de tiempo seleccionado, luego, estas se deben agrupar según el intervalo de agrupación y sacar el promedio de cada grupo, hay muchas formas de realizar esta operación sin embargo cuando se trata de grandes conjuntos de datos esta puede ser una operación costosa por lo que preferimos dejar todos los filtros, ordenamientos, agrupaciones, cálculo de promedios, sumas, etc. a la base de datos, si la tabla está apropiadamente indexada esta puede realizar dichos cálculos ordenes de magnitud mas rápido que retirando todos los datos y haciéndolos directamente en la aplicacion.

La tabla \textit{TracePing} tiene los campos "time\_60", "time\_30", "time\_15", "time\_20" y "time\_10" estos campos tienen un valor pre-calculado de tiempo que aloja el periodo de agrupación al que pertenece la muestra, estas columnas facilitan al SMBD a agrupar las muestras en periodos de 60, 30, 20, 15 o 10 minutos respectivamente, mas aún, son guardados en la base de datos tomando en cuenta la zona horaria del monitor, de modo que no es necesario volver a localizar las fechas cuando se está generando el mapa de calor; un ejemplo de esto puede ser visto en la tabla \ref{tab:time}.

\begin{table}[]
	\centering
	
	\begin{tabular}{l|l|l|l}
		timezone & time                & time\_60            & time\_10            \\ \hline
		-4:30    & 2015-11-17 22:29:42 & 2015-11-17 17:00:00 & 2015-11-17 17:50:00 \\
		UTC      & 2015-11-17 22:29:42 & 2015-11-17 22:00:00 & 2015-11-17 22:20:00
	\end{tabular}
	\caption{Ejemplo de los valores de time\_60 y time\_10 para la misma traza en UTC(+0:00) y Caracas (-4:30)}
	\label{tab:time}
\end{table}

Para acelerar aún mas el computo, evitamos usar el ORM para hacer consultas a la base de datos, esto se debe a que, a pesar de que el ORM en el fondo haga las mismas consultas, este desperdicia tiempo y recursos en convertir estos datos crudos en los objetos correspondientes según el modelo de la base de datos, por lo tanto, para este caso es preferible construir nuestras propias consultas SQL.

La consulta realizada para retirar los valores de la base se puede ver a continuación:

\begin{lstlisting}[language=SQL,basicstyle=\small\sffamily,numbers=left,numberstyle=\tiny,frame=tb,columns=fullflexible,showstringspaces=false]
SELECT time_n,AVG(rtt)
FROM traceping 
WHERE link_id=x AND time >= s AND time <= f AND rtt>0
GROUP BY time_n

\end{lstlisting}

Donde:
\begin{itemize}[noitemsep,topsep=0pt,parsep=0pt,partopsep=0pt]
	\item{n: es el periodo de agrupación}
	\item{x: es el id del enlace}
	\item{s: es la fecha inicial}
	\item{f: es la fecha final}
\end{itemize}

Esta consulta retorna entonces el promedio del valor del RTT de las trazas con RTT positivo agrupadas según su intervalo de agrupación, un RTT negativo indica que la prueba se realizó pero no obtuvo respuesta del host o el paquete se perdió, por lo tanto no se consideran para el cálculo de esta gráfica.

Ya teniendo estos datos es trivial desplegar el mapa de calor usando highcharts, sencillamente se prepara un arreglo de tuplas de tipo $<$fecha,hora,rtt promedio$>$ donde fecha es el día mes y año del grupo y hora es un punto flotante entre 0 y 24 que resulta de sumar la hora (0-23) al minuto dividido entre 60.

\begin{figure}[h]
\centering
\includegraphics[width=0.7\linewidth]{img/heatmap}
\caption{Mapa de Calor de RTT con granularidad de 10 minutos para el mes de noviembre (REDISE)}
\label{fig:heatmap}
\end{figure}


\subsubsection{Cálculo de horas activas}

En el marco de este trabajo llamaremos a una hora "activa" cuando se pudieron recoger al menos el 50\% de las muestras durante dicha hora, análogamente una hora "inactiva" es aquella donde no se pudieron recoger el 50\% de las muestras, para determinar si una hora es activa se usa la siguiente fórmula:

\begin{equation}
	T_{min} = 3600/interval * 0.5 
\end{equation}

Donde \textit{interval} es el tiempo entre pruebas en segundos y $T_{min}$ es la cantidad mínima de muestras necesarias para considerar una hora activa.

\begin{equation}
  activo =\begin{cases}
  Si, & T_{min} \leq T_{observadas}\\
  No, & T_{min} > T_{observadas}
  \end{cases}
\end{equation}

Y  $T_{observadas}$ es la cantidad de trazas capturadas exitosamente durante una hora.


De forma similar al algoritmo de cálculo de mapas de calor, debemos agrupar las trazas por hora y contar el número de trazas por grupo, afortunadamente podemos aprovechar la columna "time\_60" para hacer este agrupamiento, luego debemos comparar con el umbral mínimo $T_{min}$ para esa hora. Para determinar el intervalo entre pruebas que estuvo activo durante la prueba, podemos buscar los parámetros activos en cualquier momento usando el historial del plan de monitoreo, sin embargo cada traza se guarda junto con el intervalo entre pruebas, de manera que podemos hacer una consulta mucho mas sencilla a la base de datos.

Sabiendo esto, la consulta a la base de datos queda así:

\begin{lstlisting}[language=SQL,basicstyle=\small\sffamily,numbers=left,numberstyle=\tiny,frame=tb,columns=fullflexible,showstringspaces=false] 
SELECT time_60, COUNT(*), AVG(`interval`)
FROM traceping
WHERE link_id=x AND time_60 >= s AND time_60 < f AND rtt>0
GROUP BY time_60
\end{lstlisting}

Donde:
\begin{itemize}[noitemsep,topsep=0pt,parsep=0pt,partopsep=0pt]
	\item{x: es el id del enlace}
	\item{s: es la fecha inicial}
	\item{f: es la fecha final}
\end{itemize}

La consulta anterior retorna: un timestamp que representa la hora de agrupación, el número de muestras observadas exitosamente, y el intervalo entre pruebas promedio. Calculamos el promedio ya que el usuario puede cambiar el intervalo entre pruebas en cualquier momento, de modo que una misma hora puede tener muestras tomadas con intervalo distinto, calculando el promedio, obtendremos el mismo valor de tiempo entre pruebas para una hora en que el usuario no hizo cambios y un valor promedio para horas en que hubo cambios.

El Algoritmo \ref{alg:horasactivas} totaliza el número de horas activas por hora del día, es decir que si se elige un periodo de n días el algoritmo retorna un arreglo de tamaño 24, donde cada posición del arreglo tendrá un entero entre 0 y n. El algoritmo recorre el arreglo retornado por la consulta SQL verificando la condición para que la hora sea activa, si es activa, suma uno al total para esa hora del día, luego es trivial calcular el porcentaje de horas activas por hora del día dividiendo entre el número total de días.

\begin{algorithm}[H]
	\caption{Calculo de horas activas}\label{alg:horasactivas}
	\begin{algorithmic}[1]
		\Procedure{active\_hours}{parameters}
		\State $\textit{link} \gets \Call{Get}{Link,id=parameters.link\_id}$ \Comment{Retira el enlace por su id}
		
		\State $\textit{start\_date} \gets \textit{parameters.start\_date} $
		\State $\textit{end\_date} \gets \textit{parameters.end\_date} $
			\State $\textit{array} \gets \text{get data from sql query}$\Comment{Ejecuta la consulta a la base de datos}
			\State $\textit{days} \gets (\textit{start\_date}-\textit{end\_date}).\Call{days}{} $ \Comment{Número de dias total}
			\State $\textit{total\_hours} \gets \textit{days}*24$
			\State $\textit{hours} \gets \text{array[24]}$\Comment{Arreglo tamaño 24 inicializado en 0}
			\If{\textit{array} lenght $>$ 0}
				\State $\textit{j} \gets 0$
				\For{\textit{i} \textbf{in} \Call{Range}{0,total\_hours}}
					\State $\textit{current\_hour} \gets \textit{start\_date}+i$ \Comment{Suma a la hora inicial i horas}
					\If{\textit{array[j][0]} = \textit{current\_hour}}
						\If{\textit{j}= length of \textit{ array}} \Call{break}{} \EndIf
						\If{\textit{array[j][1]} $\geqslant$ 1800/\textit{array[j][2]}}\Comment{Condicion para que la hora sea activa}
							\State $ \textit{hours[i\%24]} \gets \textit{hours[i\%24]}+1$ \Comment{le suma a las horas activas para esa hora}
						\EndIf
					\EndIf
					\State $\textit{j} \gets\textit{j} +1$
				\EndFor
			\EndIf
		\Return \textit{hours}
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\subsubsection{Cálculo de periodos de actividad continúa}

Como se dijo en la Subsección \ref{sub:disponibilidad} llamaremos "actividad continua" a un evento durante el cual un servicio está continuamente disponible para un cliente, en este trabajo un servicio está disponible en un instante de tiempo cuando se ha capturado exitosamente una muestra durante ese instante, en caso contrario se guarda un valor de rtt de "-1" indicando que el servicio no estaba disponible, las pruebas que usamos para determinar periodos de actividad continua son las de ping y httping ya que ambas realizan un trabajo similar, pero usando protocolos distintos.

El algoritmo de cálculo de periodos de actividad continúa recorre las trazas para el intervalo de tiempo seleccionado extendiendo periodos de actividad cuando encuentra trazas \textbf{consecutivas} para las cuales el valor de RTT es positivo (hubo respuesta del TPD y por lo tanto el servicio está disponible) y de forma análoga extiende periodos de inactividad continua cuando encuentra trazas \textbf{consecutivas} para las cuales el valor de RTT es -1 (no hubo respuesta). La consulta a la base de datos es muy sencilla ya que solo hace falta consultar el RTT y marca de tiempo de las trazas ordenadas por tiempo:

\begin{lstlisting}[language=SQL,basicstyle=\small\sffamily,numbers=left,numberstyle=\tiny,frame=tb,columns=fullflexible,showstringspaces=false] 
SELECT time,rtt
FROM traceping
WHERE link_id=x AND time >= s AND time <= f
ORDER BY time
\end{lstlisting}

Donde:
\begin{itemize}[noitemsep,topsep=0pt,parsep=0pt,partopsep=0pt]
	\item{x: es el id del enlace}
	\item{s: es la fecha inicial}
	\item{f: es la fecha final}
\end{itemize}

Tras ejecutar la consulta a la base se verificar que se tenga al menos una muestra, en caso contrario, a falta de información el periodo se considera totalmente inactivo. En caso contrario, se revisa la primera traza, si es positiva entonces se crea un periodo activo y se marca el inicio del periodo como el tiempo inicial, luego se pasa a revisar la siguiente traza hasta que se encuentre una traza no positiva y se marca como el tiempo final del periodo activo al tiempo de la traza negativa, este proceso se repite análogamente para el periodo inactivo y así hasta llegar a la última traza, cada vez que se determina el instante final de un periodo este se añade a la lista de periodos activos o inactivos según corresponda. Todo el proceso se puede observar a detalle en el Algoritmo \ref{alg:continuo}.

\begin{algorithm}[h!]
	\caption{Calculo de periodos de actividad continua}\label{alg:continuo}
	\begin{algorithmic}[1]
		\Procedure{continuous\_activity}{parameters}
		\State $\textit{link} \gets \Call{Get}{Link,id=parameters.link\_id}$ \Comment{Retira el enlace por su id}
		
		\State $\textit{start\_date} \gets \textit{parameters.start\_date} $
		\State $\textit{end\_date} \gets \textit{parameters.end\_date} $
		\State $\textit{traces} \gets \text{get data from sql query}$\Comment{Ejecuta la consulta a la base de datos}
		
		\State $\textit{num\_traces} \gets \text{length of } \textit{ traces}$
		
		\State $\textit{active\_periods} \gets \text{new array}$
		\State $\textit{inactive\_periods} \gets \text{new array}$
		
		\If{\textit{num\_traces} = 0}
			\State $\text{append to } \textit{inactive\_periodos } ( \textit{start\_date},\textit{end\_date})$
			
			\Return $\textit{active\_periods}, \textit{inactive\_periods}$
		\EndIf
		
		
		\State $\textit{period\_start} \gets \textit{start\_date} $
		\If{\textit{traces[0][1]} $>$ 0} 
			\State $\textit{period\_active} \gets \textbf{True}$
		\Else
			\State $\textit{period\_active} \gets \textbf{False}$
		\EndIf
		
		\For{\textit{i} \textbf{in} \Call{Range}{1,\textit{num\_traces-1}}}
			\If{\textit{period\_active} \textbf{and} \textit{traces[i][1] $<$0}}
				\State $\text{append to } \textit{active\_periods } (duration,period\_start,traces[i][0])$
				\State $\textit{period\_active} \gets \textbf{False}$
				\State $\textit{period\_start} \gets \textit{traces[i][0]} $
			\Else{ \textbf{if} !\textit{period\_active} \textbf{and} \textit{traces[i][1] $>$0} \textbf{then}}
				\State $\text{append to } \textit{inactive\_periods } (duration,period\_start,traces[i][0])$
				\State $\textit{period\_active} \gets \textbf{True}$
				\State $\textit{period\_start} \gets \textit{traces[i][0]} $
			\EndIf
		\EndFor
		
		\If {\textit{period\_active}}
			\State $\text{append to } \textit{active\_periods } (duration,period\_start,end\_time)$
		\Else
			\State $\text{append to } \textit{inactive\_periods } (duration,period\_start,end\_time)$
		\EndIf
		
		\Return $\textit{active\_periods}, \textit{inactive\_periods}$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\subsubsection{Cálculo de días activos}

A diferencia de las horas activas, definimos a un día como "activo" cuando podemos recoger un periodo de actividad continua de al menos una hora durante ese día, el algoritmo para determinar días activos es en realidad muy similar al de cálculo de periodos de actividad continua (Algoritmo \ref{alg:continuo}), con la excepción de que este funciona separando las trazas por días, y luego busca un periodo activo de al menos una hora.

Ya que el algoritmo de días activos es usado generalmente para dibujar un gráfico de barras indicando el porcentaje de días activos, también es necesario determinar la cantidad de días totales en el periodo seleccionado por el usuario, luego cuando se tenga el total de días activos por día de la semana se puede dividir entre los días totales, un ejemplo del resultado deseado como salida del algoritmo de días activos puede ser visto en la Tabla \ref{table:diasactivos}

\begin{table}[h]
	\centering
	

	\begin{tabular}{l|l|l|l|l|l|l|l}
		& L   & M   & W    & J   & V   & S & D   \\ \hline
		Activos  & 4   & 5   & 3    & 4   & 4   & 3 & 4   \\
		Porcentaje & 100 & 100 & 60 & 100 & 100 &75   & 100 \\
		Totales    & 4   & 5   & 5    & 4   & 4   & 4 & 4  
	\end{tabular}
	
	\caption{Tabla de días activos para el mes de septiembre del servidor de  RESIDE}
		\label{table:diasactivos}
\end{table}

Para facilitar la comprensión del algoritmo este se va a separar en tres subrutinas, el Algoritmo \ref{alg:diastotales} corresponde al cálculo de días totales en el periodo, el Algoritmo \ref{alg:separardias} corresponde a la separación de trazas por día y el Algoritmo \ref{alg:diasactivos} corresponde al computo de días activos.

\begin{algorithm}
	\caption{Calculo de días totales}\label{alg:diastotales}
	\begin{algorithmic}[1]
		\Procedure{total\_days}{start\_date,end\_date}
		\State $\textit{number\_of\_days} \gets (\textit{end\_date} - \textit{start\_date}).\Call{Days}{}$
		
		\State $\textit{total\_days} \gets \text{array[7]}$ \Comment{Arreglo de tamaño 7 inicializado en 0}
		\For{\textit{i} \textbf{in} \Call{Range}{0,number\_of\_days}}
			\State $\textit{current\_day} \gets \textit{start\_date} + 1$ \Comment{Suma a la fecha inicial un día}
			\State $\textit{weekday} \gets \textit{current\_day}.\Call{Weekday}{}$\Comment{Toma el día de la semana de la fecha}
			\State $\textit{total\_days[weekday]} \gets \textit{total\_days[weekday]} +1 $
		\EndFor
		\Return \textit{total\_days}
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}
	\caption{Separación de trazas por día} \label{alg:separardias}
	\begin{algorithmic}[1]
		\Procedure{split\_traces}{traces}
		\State $\textit{days} \gets \text{empty dictionary}$
		
		\For{\textit{trace} \textbf{in} \textit{traces}}
		\State $\textit{ordinal} \gets \textit{trace[0].\Call{toordinal}{}}$ \Comment{Obtiene el ordinal proléptico gregoriano de la fecha}
		\If{\textit{ordinal} \textbf{in} \textit{days}}
			\State $\text{append} \textit{ trace } \text{to} \textit{days[ordinal]}$
		\Else
			\State $\textit{days[ordinal]} \gets \text{empty list}$
			\State $\text{append} \textit{ trace } \text{to} \textit{days[ordinal]}$
		\EndIf
		\EndFor
		\Return \textit{days}
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}
	\caption{Cálculo de días activos} \label{alg:diasactivos}
	\begin{algorithmic}[1]
		\Procedure{active\_days}{parameters}
		
		
		\State $\textit{link} \gets \Call{get}{Link,id=parameters.link\_id}$
		
		\State $\textit{start\_date} \gets \textit{parameters.start\_date}$
		
		\State $\textit{end\_date} \gets \textit{parameters.end\_date}$
		
		\State $\textit{total\_days} \gets \Call{Total\_days}{start\_date,end\_date}$
		
		\State $\textit{active\_days} \gets array[7]$ \Comment{Arreglo tamaño 7 inicializado en 0}
		
		\State $\textit{traces} \gets \text{get data from sql query} $\Comment{ejecuta la consulta a la base de datos}
		
		\State $\textit{days} \gets \Call{Split\_traces}{traces}$
		
		\For{\textit{key} \textbf{in} \textit{days}.\Call{keys}{}} \Comment{itera el diccionario por claves}
			\State $\textit{active\_period} \gets 0$
			\State $\textit{traces} \gets \textit{days[key]} $
			\State $\textit{length} \gets \text{length of} \textit{ traces}$
			\For{\textit{i} \textbf{in} \Call{Range}{1,length}}
				\If{traces[i][1]>0}
					\State $delta\_seconds \gets traces[i][0] - traces[i-1][0]$
					\State $active\_period \gets active\_period + delta\_seconds$
					\If{active\_period $>$ 3600} \Comment{El día es activo}
						\State $weekday \gets traces[i][0].\Call{Weekday}{}$
						\State $active\_days[weekday] \gets active\_days[weekday] + 1$
						\State $\textbf{break}$
					\EndIf
				\Else
					\State $\textit{active\_period} \gets 0$
				\EndIf
			\EndFor		
		\EndFor
		
		\Return \textit{total\_days,active\_days}
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\FloatBarrier

\section{Pruebas de Rendimiento}

Ya que la aplicacion web está pensada para atender a una cantidad arbitraria de usuarios, deseamos conocer el número máximo de usuarios concurrentes a los que se les puede dar servicio con el hardware disponible, llevaremos a cabo pruebas de carga en las cuales se simulará un ráfaga de peticiones variable durante un intervalo de tiempo y así determinar la cantidad de peticiones para cual ocurre una degradación de servicio o el servidor es incapaz de responder a mas peticiones.

Consideramos que ocurre una degradación de servicio cuando el tiempo de espera del usuario aumenta mas allá de un umbral máximo, según \cite{nielsen1994usability} existen tres umbrales importantes a la hora de evaluar el tiempo de respuesta de una aplicacion:

\begin{enumerate}
	\item{\textbf{0.1 segundo:} Límite en el cual un usuario siente que está manipulando los objetos desde la interfaz de usuario.}
	\item{\textbf{1 segundo:} Límite en el cual un usuario siente que está navegando libremente.}
	\item{\textbf{10 segundos:} Límite en el cual se pierde la atención del usuario, es buena idea proveer barras de cargas y medios para cancelar la operación cuando se trata de operaciones de larga duración.}
\end{enumerate}

Para las siguientes pruebas consideraremos las siguientes métricas de rendimiento de la aplicacion web:

\begin{itemize}
	\item{Tiempo de respuesta promedio}
	\item{Tiempo de respuesta mediana}
	\item{Tiempo de respuesta mínima}
	\item{Tiempo de respuesta máximo}
	\item{Porcentaje de error}
	\item{Rendimiento en términos de peticiones por segundo durante la duración de la prueba}
	\item{Rendimiento en términos de bytes por segundo durante la duracion de la prueba}
\end{itemize}

Consideraremos una prueba como exitosa cuando el porcentaje de error sea igual a 0 y el tiempo máximo de espera de una petición no supere los 10.000ms, tomando en cuenta los umbrales definidos por \cite{nielsen1994usability}. Se considerará optima aquella prueba que ademas de cumplir con ser exitosa, tenga el mayor rendimiento en términos de peticiones por segundo (Req/s) entre todas las pruebas realizadas.

La herramienta elegida para ejecutar las pruebas fue JMeter \cite{JMeter}, esta herramienta permite simular casos de uso específicos de una aplicacion web como ráfagas de peticiones que pueden ser configuradas para seguir cualquier patrón dado. En nuestro caso, Jmeter se usará para generar una ráfaga de peticiones con un intervalo constante en cada petición durante un tiempo de un minito. Jmeter provee un componente llamado \textit{Summary Report} que totaliza y promedia los resultados obtenidos de todas las peticiones enviadas del que podemos extraer todas las métricas de interés.

\subsection{Metodología de las pruebas}

Para determinar la carga máxima que la aplicacion web es capaz de soportar en términos de peticiones por minuto, simularemos una ráfaga de peticiones en un intervalo de tiempo de un minuto, variando el número de peticiones hasta obtener un valor óptimo. La metodología a seguir es la siguiente:

\begin{enumerate}
	\item{Se comenzará ejecutando una primera prueba con un número  prudencial de peticiones durante 60 segundos, este número debe preferiblemente ser múltiplo de dos como 32 o 64.}
	\item{Se varía el número de peticiones enviadas en la ráfaga multiplicando por dos cada vez que una prueba es exitosa, así si la primera prueba se hace con 16 peticiones, la siguiente tendrá 32, 64 y así sucesivamente.}
	\item{Tras la primera prueba fallida, se calculará el número de peticiones de la siguiente prueba ($P_{sig}$) como el punto medio entre la cantidad de peticiones de la prueba previa ($P_{prev}$) y la prueba actual ($P_{act}$). 
		
		\[P_{sig} = \begin{cases}
			P_{prev} + |P_{act} - P_{prev}|/2  & \text{Si la prueba fue exitosa}\\
			P_{prev} - |P_{act} - P_{prev}|/2  & \text{Si la prueba fue fallida}\\
		\end{cases}\]
		
		}
	\item{El paso 3. se repite hasta que no se obtenga mayor precisión con pruebas sucesivas}

\end{enumerate}



\subsection{Condiciones de las pruebas}

Todas las pruebas se ejecutaron sobre una red local, entre dos máquinas conectadas a un mismo enrutador: una de ellas ejecuta el servidor web y la otra ejecuta el plan de pruebas simulando las peticiones y totalizando los resultados observados; la latencia de la red se considera menor a 5ms.

Las características del servidor web se pueden observar en la Tabla \ref{tab:hardware}

\begin{table}[h]
	\centering
	\begin{tabular}{l|l|l}
		Procesador                    & Memoria  & Sistema Operativo \\ \hline
		4x Intel i5-2500 CPU @3.30GHz & 8 GB RAM & Ubuntu 15.04     
	\end{tabular}
	
		\caption{Especificaciones del servidor web}
		\label{tab:hardware}
\end{table}

\subsection{Resultados obtenidos}

\begin{enumerate}
	\item{\textbf{Archivos estáticos con Apache:} En esta prueba se configuró un servidor Apache para servir solo páginas web y archivos estáticos, como se puede observar en la Tabla \ref{tab:staticserve}, se ha elegido el valor de 640 peticiones/minuto como valor óptimo ya que tiene el mejor rendimiento en término de peticiones por segundo.}
	
	\begin{table}[h]
		\centering
		\begin{tabular}{|l|l|l|l|l|l|l|l|}
			\hline
			\# Req & Avg (ms) & Med (ms) & Min (ms) & Max (ms) & Error \% & Req/s & kb/sec \\ \hline
			128  & 42    & 37    & 28 & 135    & 0.0 \%   & 2.1  & 24.3  \\
			256  & 44    & 38    & 26 & 273    & 0.0\%   & 4.3  & 48.4  \\ 
			512  & 38    & 37    & 24 & 153    & 0.0\%   & 8.5  & 96.5  \\ 
			1024 & 49468 & 57000 & 43 & \cellcolor{LightRed}  189852 & \cellcolor{LightRed}  30.37\% & 5.3  & 46.3  \\ 
			768  & 29929 & 23248 & 45 & \cellcolor{LightRed}  172688 & \cellcolor{LightRed}  9.24\%  & 4.1  & 43.4  \\ 
			\rowcolor{LightGreen} 640  & 73    & 55    & 27 & 289    & 0.00\%  & 10.6 & 120.6 \\ 
			704  & 8339  & 458   & 28 & \cellcolor{LightRed}  64813  & 0.00\%  & 6.6  & 74.9  \\ 
			672  & 1125  & 217   & 45 & \cellcolor{LightRed}  18280  & 0.00\%  & 9.6  & 108.9 \\ 
			656  & 206   & 120   & 28 & 4194   & 0.00\%  & 10.4 & 117.6 \\
			\hline
		\end{tabular}
		\caption{Peticiones de archivos estáticos con apache}
		\label{tab:staticserve}
	\end{table}
	
	\item{\textbf{Páginas dinámicas con Django sobre Apache:} En esta prueba se configuró Apache para ejecutar \textbf{solo} la aplicacion web Django a través del módulo \textit{mod\_wsgi}, no se solicitaron los archivos estáticos vinculados a las páginas visitadas. En la tabla \ref{tab:djangotest} se observa un valor óptimo de 768 peticiones por minuto, para el cual la media y la mediana se mantienen por debajo del umbral de los 0.1 segundos.}
	
	
	\begin{table}[h]
		\begin{tabular}{|l|l|l|l|l|l|l|l|}
			\hline
			\# Req & Avg (ms) & Med (ms) & Min (ms) & Max (ms) & Error \% & Req/s & kb/sec \\ \hline
			128  & 37    & 33   & 23 & 140    & 0.00\% & 2.1  & 9.8   \\
			256  & 35    & 33   & 24 & 237    & 0.00\% & 4.3  & 19.5  \\ 
			512  & 47    & 33   & 23 & 1038   & 0.00\% & 8.5  & 38.9  \\ 
			1024 & 13709 & 575  & 27 & \cellcolor{LightRed} 97869  & \cellcolor{LightRed} 3.61\% & 7.9  & 35.3  \\ 
			\rowcolor{LightGreen} 768  & 39    & 33   & 23 & 1034   & 0.00\% & 12.8 & 58.2  \\ 
			896  & 12483 & 2384 & 24 & \cellcolor{LightRed} 101648 & \cellcolor{LightRed} 1.56\% & 7.1  & 31.9  \\ 
			832  & 390   & 35   & 24 & 9630   & 0.00\% & 12.7 & 57.7  \\ 
			672  & 1125  & 217  & 45 & 18280  & 0.00\% & 9.6  & 108.9 \\ 
			656  & 206   & 120  & 28 & 4194   & 0.00\% & 10.4 & 117.6 \\
			\hline
		\end{tabular}
		\caption{Peticiones de páginas dinámicas con Django}
		\label{tab:djangotest}
	\end{table}
	
	\item{\textbf{Páginas dinámicas con Django y archivos estáticos sobre el mismo servidor Apache}: en esta prueba se configuró el servidor Apache tal como está descrito en la Sección \ref{sub:servidorweb}, es decir que Apache servirá directamente las peticiones de archivos estáticos y pasará a la aplicacion Django las peticiones dinámicas. En la tabla \ref{tab:djangostatic}} se observa un valor óptimo de 32 peticiones por minuto con una media y mediana por encima del umbral del segundo. 
	
	\begin{table}[h!]
		\begin{tabular}{|l|l|l|l|l|l|l|l|}
			\hline
			\# Req & Avg (ms) & Med (ms) & Min (ms) & Max (ms) & Error \% & Req/s & kb/sec \\ \hline
			64 & 77018 & 74557 & 2558 & \cellcolor{LightRed} 321297 & \cellcolor{LightRed} 9.38\% & 11.5 & 66    \\
			\rowcolor{LightGreen} 32 & 3438  & 3177  & 2484 & 5432   & 0.00\% & 31.1 & 179.3 \\ 
			48 & 41056 & 40148 & 8178 & \cellcolor{LightRed} 100190 & 0.00\% & 25.2 & 144.9 \\ 
			40 & 12023 & 8176  & 2121 & \cellcolor{LightRed} 36000  & 0.00\% & 32.6 & 188   \\ 
			36 & 10152 & 8335  & 2091 & \cellcolor{LightRed} 41631  & 0.00\% & 23.1 & 133   \\ 
			34 & 17259 & 14613 & 4165 & \cellcolor{LightRed} 42601  & 0.00\% & 24.6 & 141.9 \\
			\hline
		\end{tabular}
		\caption{Peticiones de páginas dinámicas con sus archivos estáticos.}
		\label{tab:djangostatic}
	\end{table}
	
\end{enumerate}

\subsection{Análisis de los resultados}

Como se pudo observar en las pruebas anteriores y corroborando lo dicho en la Sección \ref{sub:servidorweb}, de tenerse los recursos suficientes, Django debería ejecutarse preferiblemente en una máquina separada a la encarga de servir archivos estáticos. Se ha observado que un servidor de las características descritas puede manejar una carga de 768 peticiones dinámicas por minuto, y solo 640 peticiones estáticas, lo cual representa una diferencia de mas del 16\%. 

Independiente de la cantidad de peticiones que el servidor pueda manejar en condiciones ideales, en la realidad cada visita \textbf{única}, es decir, cada usuario que visite por primera vez el sitio web deberá descargar todos los archivos estáticos junto con la página HTML generada dinámicamente, como se observó en la tabla \ref{tab:djangostatic}, el servidor es capaz de atender unas 32 peticiones de este tipo por minuto, lo cual representa una marcada diferencia del 95\% en comparación con la prueba sin archivos estáticos, por lo tanto, los archivos estáticos representan un cuello de botella importante para la aplicacion.

A pesar de los anterior, en peticiones sucesivas el navegador web usará los archivos en el caché de modo que en la práctica sería posible atender muchas mas peticiones por minuto.

Desde el punto de vista de la velocidad de respuesta del servicio ofrecido, como se ve en la tabla \ref{tab:djangotest} tanto la velocidad de respuesta promedio como la mediana se mantienen muy por debajo del umbral de los 0.1 segundos, e incluso el tiempo de respuesta máximo se mantiene cerca del umbral del segundo, sin tomar en cuenta la latencia de la red, esto conforma una experiencia de navegación bastante rápida.rag

\chapter{Monitor de Red "Tentacle Probe Source"} \label{cap:monitor}

Tentacle Probe Source (TPS) es un monitor de red ligero, diseñado para ajustarse a las limitaciones de sistemas de bajo costo y con la intensión de ser desplegado en las redes que se desea monitorear y ser dejado desatendido durante periodos arbitrarios de tiempo. Su misión es ejecutar pruebas periódicas siguiendo el plan de monitoreo definido por el usuario con el objetivo de recoger datos sobre las métricas relevantes a la red a monitorear, los resultados de las pruebas son guardados temporalmente en la memoria del dispositivo y se suben a la nube regularmente, la frecuencia en que se suben los datos a la nube depende de la cantidad de memoria disponible en el dispositivo, la cantidad de datos generados por el monitoreo y el ancho de banda disponible.

Uno de los objetivos principales del monitor es ejecutar las pruebas en el momento preciso dado por el plan de monitoreo, ya que el posterior análisis de los datos por parte de Octopus Head exige que las muestras se tomen con un patrón regular y conocido, para esto, un planificador que asegura la ejecución precisa de las pruebas es central en la arquitectura del monitor. Como ya se mencionó, el comportamiento del monitor viene dado por un plan de monitoreo, este es definido por el usuario en Octopus Head, toda la comunicación entre los monitores Tentacle Probe Source y Octopus Head ocurre a través de la nube, Octopus Head transfiere el plan de monitoreo a través de mensajes individuales que especifican cambios tales como replanificación de pruebas, cambios a los parámetros de ejecución, e incluir nuevos enlaces a monitorear.

\section{Diseño del Monitor}

El diseño del monitor esta sujeto a los siguientes baremos: 

\begin{itemize}
	\item{\textbf{Estabilidad} ya que el monitor podría dejarse desatendido es esencial que sea estable, si el monitor no se está ejecutando el usuario no obtendrá los resultados esperados en la aplicación web.}
	\item{\textbf{Flexibilidad} el monitor debe ser capaz de cargar nuevas pruebas en tiempo de ejecución, esto es especialmente importante ya que no desea interrumpir otras pruebas que se estén ejecutando.}
	\item{\textbf{Planificación precisa} es importante que las pruebas se ejecuten en el momento adecuado, siguiendo de manera fiel el plan de monitoreo.}
	\item{\textbf{Ejecutable en equipos de bajo costo} el monitor debe incluir el código mínimo para su funcionamiento, tener un uso eficiente de memoria y evitar desbordar la memoria secundaria del host.}
	\item{\textbf{Configuración remota} el monitor debe implementar algún protocolo para actualizar su plan de monitoreo a partir de cambios hechos en la aplicación web.}
	\item{\textbf{Bitácora} ya que el monitor se ejecuta como un proceso daemon, se desea tener una bitácora donde se puedan leer mensajes sobre los eventos relevantes durante la ejecución.}
\end{itemize}

\subsection{Arquitectura}

Como se puede observar en la figura \ref{fig:tentacle-components.png}, Tentacle Probe Source tiene una arquitectura basada en componentes altamente desacoplados con responsabilidades bien delimitadas para facilitar el desarrollo de la aplicación; cada uno de estos componentes puede ser reemplazado fácilmente siempre y cuando la interfaz entre ellos se mantenga intacta.

\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{img/TPS-arch.png}
	\caption{Diagrama de Componentes del TPS}
	\label{fig:tentacle-components.png}
\end{figure} 

\subsection{Diagrama de actividades}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.9\linewidth]{img/monitor-activity.png}
	\caption{Diagrama de actividades de Tentacle}
	\label{fig:tentacle-activity}
\end{figure}

La ejecución del monitor comienza en el cliente, el cliente es el encargado de instanciar el proceso daemon y lo hace a través del método bien conocido de doble fork; para asegurarse de no ejecutar múltiples instancias del monitor se revisa un archivo .pid, si el archivo existe significa que el monitor se está ejecutando y el cliente informa del error al usuario. 

Después de que el proceso esta daemonizado comienza la fase de inicialización, para esto se crea el planificador y se cargan las tareas del almacén de tareas, importando el código de las pruebas a ejecutar. A este punto las pruebas están planificadas tentativamente y cargadas en memoria pero solo serán ejecutadas después de que se inicie el planificador.

Al iniciar el planificador este pasa a ejecutarse como un subproceso y se encarga de iniciar las tareas en el momento preciso. Cuando el planificador inicia una tarea se la pasa al ejecutor en este caso un grupo de subprocesos previamente inicializados, cuando un subproceso termina de ejecutar una tarea informa al planificador, esto con la finalidad de implementar políticas de concurrencia de tareas.

Mientras tanto, el hilo principal se conecta a la nube usando el API de Dropbox que posee un método para notificar a los clientes sobre cambios a una carpeta en tiempo real y con baja latencia, el método consiste en abrir una conexión HTTP con un alto valor de timeout (entre 30 y 120 segundos), si ocurre un cambio en la carpeta, el servidor de Dropbox responde de inmediato indicando que ocurrieron cambios y el monitor procederá a manejar este evento (descargando los archivos nuevos y aplicando los cambios al plan de monitoreo), en caso contrario, Dropbox responde indicando que no ocurrieron cambios y el monitor reinicia la conexión. 

Los eventos relevantes al monitor son los siguientes: (1) una prueba se ha agregado al plan de monitoreo y debe cargarse a memoria y planificarse (2) una prueba se ha eliminado y debe ser eliminada del plan de monitoreo (3) el intervalo entre pruebas de una prueba ha cambiado y debe replanificarse la próxima ejecución (4) los parámetros de una prueba han cambiado (5) se ha agregado un nuevo enlace a monitorear (6) se ha eliminado o desactivado un enlace monitoreado.

El monitor solo puede detenerse a través de una señal del sistema operativo (SIGTERM), el cliente utiliza el archivo pid para determinar el id del proceso y enviar la señal. El manejador de excepciones del monitor entonces inicia una secuencia de apagado, deteniendo las pruebas, apagando el planificador y desbloqueado el archivo .pid.

Esta secuencia de actividades puede verse en la figura \ref{fig:tentacle-activity}.


\section{Componentes}

En esta sección se explican a detalle los componentes que forman parte del monitor.

\subsection{Cliente}

El cliente de TPS es el programa encargado de iniciar o detener la ejecución del monitor en modo daemon y funge como interfaz entre el usuario y monitor.

La tarea principal del cliente consiste en daemonizar el monitor, el proceso para formar un daemon con comportamiento correcto son los siguientes \cite{pep3143}: 
\begin{enumerate}
	\item{Disociar el programa del terminal}
	\item{Convertirse en un líder de sesión}
	\item{Convertirse en un líder de grupo de procesos}
	\item{Ejecutarse como una tarea de fondo haciendo fork y luego dejando que el programa "padre" finalice inmediatamente, de este modo el proceso "hijo" queda huérfano, en algunos casos es necesario repetir este proceso dos veces para lograr convertir el programa en un líder de sesión.}
	\item{Establecer el directorio raíz (/) como el directorio de trabajo (working directory) del programa}
	\item{Cerrar todos los descriptores de archivos}
	\item{Redirigir los flujos estándar (stdout, stderr, stdin) a un archivo de bitácora, o a /dev/null}
\end{enumerate}

La Tabla \ref{tab:clientcommands} muestra los comandos que pueden ser usados al invocar el cliente; los comandos start y restart se pueden invocar con la opción --no-daemon para iniciar el monitor en modo consola (sin daemonizar), de esta manera se puede ver la salida de la bitácora del monitor, esto puede ayudar al desarrollador o al usuario a encontrar y solucionar problemas.

\begin{table}[h!]
	\centering
	\begin{tabular}{p{2cm}p{13cm}}
		\rowcolor{light-gray} Comando & Descripción \\ 
		\hline start & Inicia el monitor como un proceso daemon, falla si el archivo .pid ya existe (el monitor se esta ejecutando) \\ 
		\hline stop & Detiene el monitor enviando la señal SIGTERM al proceso daemon, falla si el archivo pid no existe (el monitor no se esta ejecutando) \\  
		\hline restart & Detiene e inicia el monitor \\ 
		\hline jobs & Muestra las tareas pendientes en el planificador (plan de monitoreo) \\ 
		\hline 
	\end{tabular} 
	\caption{Comandos del cliente TPS}
	\label{tab:clientcommands}
\end{table}

\subsection{Hilo Principal}

El hilo principal de ejecución es el punto de partida desde el momento en que el proceso ya se ha convertido en un daemon, se encarga de inicializar el planificador el cual a su vez pasa a ejecutarse en segundo plano, luego, su tarea consiste en mantener el plan de monitoreo al día a partir de los cambios que se hagan en Octopus Head.

El hilo principal consiste en un bucle de ejecucion que realiza las siguientes subtareas:
\begin{enumerate}
	\item{Llama al método delta de Dropbox sobre la carpeta que hace las veces de buzón de mensajes del monitor sin usar un cursor, este llamado retorna como lista de entradas delta todos los archivos que hay en la carpeta, de esta manera, el monitor puede leer los mensajes que hayan sido colocados en la carpeta mientras no se estaba ejecutando, luego guarda el cursor retornado por el método delta y lo usa en llamadas sucesivas.}
	\item{Toma la lista de entradas delta obtenida de cada llamada a delta y descarga archivo por archivo, leyendo su contenido, a partir del nombre y contenido del mensaje pueden ocurrir los siguientes escenarios:}
	\begin{itemize}
		\item{Si el nombre del archivo no está en el formato esperado ignora y elimina el mensaje.}
		\item{Si el contenido del archivo no puede ser interpretado, se ignora y elimina el mensaje.}
		\item{Si el contenido del archivo no contiene la información esperada, se ignora y elimina el mensaje, el contenido esperado de los mensajes se puede ver en las tablas \ref{tab:testmessage} y \ref{tab:linkmessage}.}
		\item{Si se trata de un mensaje cuyo nombre comience con \textit{test} se lee el identificador del enlace y se agrega, activa o desactiva el enlace según el valor de \textit{status} del mensaje.}
		\item{Si se trata de un mensaje cuyo nombre comience con \textit{test} se lee el identificador de la prueba, si una prueba con ese identificador ya existe entonces se revisa si esta debe ser replanificada (ya sea porque cambio su tiempo inicial, final o intervalo entre pruebas) o si cambió su lista de parámetros, en caso de que no exista la prueba se inserta al planificador, en caso de que el valor de \textit{status} sea falso, entonces la prueba debe ser eliminada de la planificación.}
	\end{itemize}
	\item{Realiza peticiones al API de notificaciones de Dropbox para ser notificado cuando ocurran cambios al buzón, el método de notificación es muy similar al método de polling típico en que se envía cada cierto tiempo una petición a un servidor preguntando si ha ocurrido un evento de interés (similar a delta), con la diferencia de que las peticiones se envían con un largo valor de timeout (entre 30 y 120 segundos), el servidor de notificación en vez de responder inmediatamente retiene la petición hasta que ocurra un evento de interés o hasta que se cumpla el timeout y devuelve una respuesta indicando si ocurrieron cambios. Esto emula una comunicación directa donde el servidor envía mensajes directamente al cliente y permite que el monitor detecte los cambios en el buzón a baja latencia, pudiendo responder a ellos inmediatamente.}
	\item{Si no ocurrieron cambios, es decir, si se cumplio el tiempo de timeout sin eventos relevantes se repite el paso 3, opcionalmente puede que Dropbox indique al monitor que espere unos segundos antes de envíar la próxima petición al API. En caso contrario se pasa a repetir el paso 1 para así determinar cuales fueron los cambios al buzón y leer los potenciales mensajes.}
	
\end{enumerate}

El diagrama de secuencia del hilo principal del monitor puede ser observado en la Figura \ref{fig:ConexionconlanubedelTPS}.

\begin{figure}
\centering
\includegraphics[width=1\linewidth]{"img/Conexion con la nube del TPS"}
\caption{Diagrama de secuencia del hilo principal del Monitor}
\label{fig:ConexionconlanubedelTPS}
\end{figure}


\subsection{Planificador}

Para la implementación del planificador se hizo uso de APScheduler, una biblioteca que permite retrasar la ejecución de código python a instantes específicos en el futuro; el planificador se puede ejecutar como un subproceso de modo que otro hilo puede encargarse de mantener el estado de planificador actualizado, indicando cuando se deban agregar, re-planificar o eliminar pruebas. 

El planificador es el que une todos los componentes 

El planificador consiste de gatillos para determinar el tiempo de ejecucion de las pruebas, ejecutores que ejecutan las pruebas y almacenes de tareas que guardan el estado del planificador, todos estos componentes son altamente configurables y se pueden extender o reusar para obtener cualquier comportamiento deseado, a continuación se explica su funcionamiento y como se usaron en el marco de este trabajo.

\subsubsection{Gatillos (Triggers)}

Los gatillos contienen la lógica para determinar en que momento se debe ejecutar una tarea, la biblioteca incluye varios gatillos predefinidos, de los cuales dos se han usado para el desarrollo de esta aplicación: 

\begin{itemize}
	\item{\textbf{Gatillo por intervalos:} ejecuta pruebas en intervalos regulares, opcionalmente se pueden suministrar fechas finales e iniciales de modo que las pruebas solo se ejecuten durante un periodo especifico, después de la fecha final el planificador elimina la prueba automáticamente.}
	\item{Gatillo por fecha: ejecuta la prueba en una fecha especifica dada, una sola vez, útil para ejecutar pruebas que usen muchos recursos de red como benchmarks o capturas de tráfico de la red.}
\end{itemize}

\subsubsection{Ejecutores (Executors)}

El ejecutor es el ente encargado de llevar a cabo la ejecución de las tareas, en nuestro caso se ha hecho uso de un grupo de subprocesos (thread pool), la cantidad de hilos en el grupo esta dado por el numero de pruebas que estaremos ejecutando de modo que siempre se tenga al menos un hilo disponible cuando se inicia una prueba. 

El ejecutor comunicado el estado de ejecución de las tareas al planificador, de modo que se pueden implementar limites de concurrencia tales que una tarea solo pueda ser ejecutada simultáneamente un cierto número de veces, en este trabajo solo puede ser ejecutada una prueba del mismo tipo a la vez, en otras palabras la concurrencia máxima es 1.

\subsubsection{Almacén de tareas (Job store)}

El almacén de tareas guarda las tareas planificadas, el comportamiento por defecto es guardar las tareas en memoria, pero existen distintos tipos de almacenes como redis \cite{RedisWebsite} y bases de datos; hemos usado la clase SQLAlchemyJobStore que permite guardar tareas en una base de datos ligera como sqlite y así asegurar la persistencia de los datos de la aplicación en caso de interrupciones o reinicios.

El almacén de tareas debe guardar toda la información necesaria para recrear las tareas, en otras palabras debe guardar el gatillo, la ruta del ejecutable de la prueba, el arreglo de parámetros y el tiempo de la última ejecución, la estructura de la base de datos es muy sencilla: se guarda el identificador de la tarea como clave, el tiempo de la última ejecución (timestamp) y los datos de la ruta del ejecutable y los parámetros se serializan y se guardan en un campo BLOB.

\subsection{Almacenamiento Compartido}

El almacenamiento compartido se encarga de alojar los resultados de las pruebas en archivos de trazas, por cada prueba que se esté ejecutando se crea una carpeta donde se alojan sus respectivos archivos.

Para mantener el numero de archivos en el almacenamiento compartido razonablemente pequeño se crea para cada enlace un archivo por hora y todas las trazas que se generen en ese periodo se anexan al archivo correspondiente; el costo de alojar archivos en la nube no depende del numero de archivos sino del espacio total de disco en uso, ya que existe un limite de peticiones diarias por usuario debemos intentar minimizar la cantidad de peticiones que realizamos a Dropbox.

\section{Pruebas Implementadas}

Gracias a la arquitectura de Tentacle, implementar una prueba es tan sencillo como crear un paquete e implementar la función "run" en el archivo init.py, todas las pruebas implementadas hasta ahora comparten una flujo de ejecución similar:
\begin{enumerate}
	\item{Se lee el archivo de configuración}
	\item{Se obtienen los enlaces a monitorear y los parámetros globales}
	\item{Se ejecuta la prueba por cada enlace monitoreado (ya sea en paralelo o en secuencia).}
	\item{Se ejecuta un comando externo externo como ping o traceroute o se usa una biblioteca python para evaluar alguna métrica del enlace.}
	\item{(opcional) si se ejecuta un comando externo se hace un parsing para extraer los resultados relevantes de la salida del programa}
	\item{Se guardan los resultados en un archivo de trazas; generalmente el resultado de una prueba está representado por una linea en archivo de trazas, sin embargo el desarrollador tiene libertad total sobre el formato que utilice para generar archivos de trazas}
\end{enumerate}

Durante el desarrollo de este proyecto se han implementado las siguientes pruebas:

\subsection{Ping}

Esta prueba hace uso del comando ping para obtener datos de la latencia en un enlace, como ya se menciono en la sección \ref{sub:ping} ping viene incluido en todas las distribuciones de linux por lo que no es necesario instalar ninguna dependencia o programa externo.

La prueba consiste en ejecutar el comando ping para cada uno de los enlaces monitoreados, ejecutamos el comando con la opción -D para que ping imprima cada resultado de latencia con una marca de tiempo entre corchetes, un ejemplo de la salida de ping se puede ver en la figura \ref{fig:ping-out}. 

Es muy sencillo extraer los datos relevantes de la salida de ping, para esto recorremos la salida descartando las lineas que no comiencen con el carácter '[', separamos la salida en palabras, la palabra en la posición 0 corresponde a la marca de tiempo, luego buscamos las palabras que comiencen por "icmp\_seq o icmp\_req y time" para obtener numero de secuencia icmp y tiempo de ida y vuelta respectivamente.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.9\linewidth]{img/ping-out}
	\caption{Ping output}
	\label{fig:ping-out}
\end{figure}

Independientemente del número de sondas que se envíen elegiremos solo un resultado de latencia por prueba (la mediana), si para una prueba no se obtiene ninguna respuesta entonces guardamos una traza con rtt=-1, indicando que el enlace está inactivo o el nodo está rechazando el protocolo.

\begin{table}[h]
	\centering
	\label{table:ping-parameters}
	\begin{tabular}{rp{2cm}p{9cm}}
		\rowcolor{light-gray} 
		Parametro              &  Tipo & Descripcion                                                                \\ \hline
		Numero de sondas       & Entero                      & Número de sondas icmp a enviar.                                            \\ \hline
		Timeout                & Float                       & Tiempo a esperar por una respuesta antes de asumir una sonda como perdida. \\ \hline
		Intervalo entre sondas & Float                       & Tiempo entre el envío de cada sonda individual.                           
	\end{tabular}
	\caption{Parametros de la prueba ping}
\end{table}

\subsection{Httping}

Esta prueba usa el protocolo HTTP para hacer un HEAD Request y obtener el tiempo de respuesta y código de estatus HTTP, a diferencia de la prueba con ping esta no ejecuta un comando externo sino que llama a una función de la biblioteca 'requests' que hace la petición directamente por lo que no es necesario ningún tipo de parsing. 

La tabla \ref{table:httping-parameters} muestra los parámetros de la prueba httping,

\begin{table}[h!]
	\centering
	\label{table:httping-parameters}
	\begin{tabular}{rp{2cm}p{9cm}}
		\rowcolor{light-gray} 
		Parametro              &  Tipo & Descripcion                                                                \\ \hline
		Timeout       & Float                      & Tiempo a esperar por una respuesta                                        \\ \hline
		Path                & String                       & Cadena de caracteres que se adjunta al ip o nombre de dominio del enlace, especialmente útil para probar servicios específicos de una aplicación o servicio web.. \\ \hline
		Port & Entero                       & Espeficia el puerto al que se envía la peticion HTTP.                           
	\end{tabular}
	\caption{Parametros de la prueba httping}
\end{table}

Esta prueba es útil para monitorear todo tipo de servidores web y posee la ventaja sobre ping de utilizar un protocolo de capa aplicación por lo que da una idea mas precisa de la experiencia del usuario al visitar dicho servicio; a diferencia de ping, el resultado obtenido no solo es la latencia de la red, sino la suma de la latencia de la red y el tiempo de respuesta del servidor, que puede estar sujeto, por ejemplo, al nivel de carga que esté manejando dicho servicio, o a la petición especifica que se esté realizando.

\subsection{Traceroute}

Esta prueba ejecuta el comando traceroute para obtener la ruta entre un par de nodos a través de una red ip, llamamos ruta a una secuencia de saltos (hops) que hace un paquete al atravesar un enrutador. 

El comando traceroute imprime la ruta como una lista ordenada donde cada linea representa un salto, con su dirección ip, nombre de dominio y latencia, dependiendo del numero de sondas que se estén enviando por salto pueden existir casos en que se obtenga respuesta de mas de una dirección ip, este comportamiento se puede ver en la figura \ref{fig:traceroute-out} en el salto 9 se observa que obtenemos una respuesta de la dirección ip 154.54.31.230 y dos de 154.54.47.154 

\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{img/traceroute-out-white.png}
	\caption{Salida del comando traceroute}
	\label{fig:traceroute-out}
\end{figure}


A partir de la salida de traceroute se debe obtener una estructura de datos que facilite el análisis de la ruta, para esto se usó el modulo tracerouteparser.py\footnote{tracerouteparser.py es cortesia del proyecto Netalyzr: http://netalyzr.icsi.berkeley.edu}, que extrae la información de la cabecera (ip destino y nombre de dominio), asi como una lista de hops (saltos), cada hop es a su vez una lista de probes (sondas), cada sonda tiene dirección ip, nombre de dominio, rtt y anotaciones; ya que el ip destino es conocido, solo se guarda en el archivo de trazas la lista de saltos en formato json. 

El formato esta compuesto de la siguiente manera:

\lstset{
	numbers=left,
	stepnumber=1,    
	firstnumber=1,
	numberfirstline=true,
	numberstyle=\tiny,
	basicstyle =\small
}

\begin{lstlisting}][h,frame=single]
[
[
{
"anno": anno_1,
"rtt": rtt_1,
"ipaddr": ipaddr_1,
"name": name_1
},
{
"anno":  anno_2,
"rtt": rtt_2,
"ipaddr": ipaddr_2,
"name": name_2
},
...
],
...
]
\end{lstlisting}

Cada vez que se realiza una prueba con traceroute se anexa al archivo de trazas una entrada con la marca de tiempo de inicio de la prueba, un carácter de separación y luego una cadena en el formato json antes mostrado. 

Las parámetros de esta prueba son los siguientes:

\begin{table}[h]
	\centering
	\begin{tabular}{rp{2cm}p{9cm}}
		\rowcolor[HTML]{C0C0C0} 
		Parametro        & {\color[HTML]{333333} Tipo} & Descripcion                                                           \\ \hline
		Numero de sondas & Entero                      & Número de sondas a enviar por cada valor de TTL.                      \\ \hline
		TTL Maximo       & Entero                      & Numero maximo de saltos antes de asumir que el nodo no es alcanzable. \\ \hline
	\end{tabular}
	\caption{Parametros de la prueba con traceroute}
	\label{tab:traceroute-params}
\end{table}

\subsection{Throughput con Iperf}

La prueba de throughput con iperf mide el ancho de banda entre un par de nodos usando el programa Iperf, como se pudo ver en las pruebas anteriores, siempre es necesario que el equipo destino (Tentacle Probe Destination) ofrezca algún tipo de respuesta ya sea en forma de ICMP Echo Reply o HTTP Response, en estos casos no necesariamente hace falta instalar o configurar el equipo destino pues estos ya implementan dichos servicios, sin embargo en el caso de Iperf el usuario que realiza el monitoreo debe asegurarse de mantener una instancia de Iperf en modo servidor para realizar las pruebas, en otras palabras el usuario debe tener acceso o contar con la colaboración explicita de los puntos finales a monitorear.

\begin{table}[h]
	\centering
	\begin{tabular}{rp{2cm}p{9cm}}
		\rowcolor[HTML]{C0C0C0} 
		Parametro        & {\color[HTML]{333333} Tipo} & Descripcion                                                           \\ \hline
		Probar este enlace & Booleano                      & Determina si se debe o no ejecutar la prueba para un enlace especifico.                      \\ \hline
		Tiempo de transmisión       & Entero                      & Numero de segundos para transmitir datos durante la prueba. \\ \hline
		Bytes a enviar      & String                      & Cantidad de bytes a enviar durante la prueba, se puede especificar si el numero es en bytes o megabytes usando las letras B o M respectivamente, este parámetro se ignora si se establece el parametro anterior.. \\ \hline
		Numero de flujos       & Entero                      & Numero de flujos TCP simultáneos a usar durante la prueba. \\ \hline
		Puerto       & Entero                      & Especifica el puerto en que el servidor está escuchando en el TPS. \\ \hline
	\end{tabular}
	\caption{Parametros de la prueba con iperf}
	\label{tab:traceroute-params}
\end{table}

\chapter{Framework de integración de pruebas} \label{cap:framework}

A pesar de que Octopus Monitor incluye un conjunto de pruebas como ping, httping, traceroute y iperf que proveen datos sobre latencia, rendimiento, disponibilidad y alcanzabilidad de los enlaces y servicios monitoreados, una de sus características mas importantes es la facilidad de implementación de nuevas pruebas. 

El framework de integración de pruebas le ahorra al desarrollador la repetición de las tareas comunes a todas las pruebas como definición de URLs, formularios de parámetros, lógica de las vistas, escritura de plantillas,etc. Gracias a esto, el desarrollador se puede concentrar en escribir solo el código especifico a cada prueba particular facilitando y acelerando la expansión de la aplicacion.

Para entender los requisitos que resultarán en los distintos componentes que serán parte del framework, debemos entender el flujo de trabajo del monitoreo a través del cual se obtienen datos de las redes monitoreadas:

\begin{enumerate}
	\item{El usuario selecciona una prueba de la lista de pruebas disponibles para el monitor.}
	\item{La aplicación web despliega un formulario donde el usuario puede planificar la ejecución de la prueba seleccionada y establecer sus parámetros.}
	\item{La aplicacion web sube un mensaje al buzón del monitor de red con los detalles de la prueba planificada.}
	\item{El monitor es notificado del nuevo mensaje, lee su contenido y prepara la prueba para su ejecucion}
	\item{El monitor ejecuta la prueba y guarda los resultados en un archivo de trazas temporal}
	\item{El monitor sube los archivos generados a la nube para su almacenamiento a largo plazo}
	\item{La aplicacion web inicia una rutina de sincronización la cual descarga los archivos, los procesa según el formato del archivo y los guarda en la base de datos.}
	\item{El usuario selecciona una visualización dada de la lista de visualizaciones disponibles y selecciona los datos y las opciones a través de un formulario.}
	\item{El servidor busca la visualización solicitada en el caché, si no la encuentra, llama a la función correspondiente para computarla, la introduce en el cache para futuras consultas y la muestra al usuario.}
\end{enumerate}

A partir de este flujo podemos inferir los siguientes requisitos:

\begin{enumerate}
	\item{Un módulo de planificación genérico de pruebas que incluya los siguientes componentes:}
	\begin{itemize}
			\item{Definiciones de las pruebas disponibles}
			\item{Una lista de parámetros para cada una de las pruebas}
			\item{Un formulario para permitir la selección de los parámetros cada vez que el usuario planifica una prueba}
	\end{itemize}
	\item{Un módulo de sincronización genérico que pueda procesar los archivos de trazas y almacenar los datos de las pruebas.}
	\item{Un módulo de análisis y visualización de los datos recolectados que incluya los siguientes componentes:}
	\begin{itemize}
			\item{Definiciones de las visualizaciones disponibles para los datos de cada prueba.}
			\item{Un formulario de configuración para cada visualización.}
			\item{Una función para computar cada visualización.}
			\item{Un mecanismo de caching genérico.}
			\item{Una plantilla para dibujar cada visualización.}
	\end{itemize}
\end{enumerate}

\section{Planificación genérica de pruebas}

La planificación genérica de pruebas provee una interfaz única que permite a los usuarios agregar pruebas a ejecutar para sus monitores remotos. Como ya se explicó en la Sección \ref{sub:basededatos} mantenemos en la base de datos dos tablas que describen las pruebas que son parte del sistema, la tabla "Test" que incluye los detalles básicos de cada prueba como su nombre, descripción y \textit{nombre de módulo} y la tabla "Parameter" que incluye el nombre, tipo, valor por omisión, ámbito y otros detalles de los parámetros, una prueba puede ser vista como una agregación de sus parámetros. El sistema soporta parámetros de tipo bolean, entero, flotante y cadena de caracteres, sin embargo nuevos tipos podrían ser implementados para ser parte del sistema.

Las pruebas planificadas para un monitor se guardan en la tabla intermedia \textit{MonitorTest}, ademas de guardar las claves del monitor y la prueba relacionadas, esta tabla guarda los parámetros de la prueba en formato json y la información de la planificación (intervalo entre prueba, fecha inicial (o fecha de ejecucion), fecha final, estado, etc.)

Es posible ejecutar pruebas según dos esquemas de planificación: pruebas periódicas que son ejecutadas en intervalos regulares a partir de una fecha inicial y hasta una fecha final y pruebas de una sola ejecucion que pueden ser ejecutadas en un tiempo específico. Algunas pruebas como las de ping y httping están pensadas para ser ejecutadas de forma periódica y así obtener datos constantemente, otras pruebas como iperf que usan un gran número de recursos de red pueden ser planificadas para ejecutarse en un momento específico o con un intervalo entre pruebas mucho mas largo en caso de planificarse de forma periódica.

Cuando un usuario desea planificar una prueba, el sistema filtra entre el conjunto de pruebas para determinar aquellas que están disponibles para su monitor, de esta manera, por ejemplo, un dispositivo de bajo poder de computo como un raspberry pi no tendría disponible una prueba computacionalmente intensiva de troughput multi-flujos, esto se podría extender también para tomar en cuenta el sistema operativo del dispositivo host y así se podrían implementar pruebas específicas para cada sistema operativo. Por ahora, el sistema filtra las pruebas según el esquema de planificación: algunas pruebas solo pueden ser planificadas en intervalos periódicos, otras solo pueden ser planificadas en un tiempo específicos y otras pueden ser planificadas con ambos esquemas.

Cuando el usuario selecciona una prueba el sistema crea un formulario partir de la lista de parámetros, ya se mencionó que los parámetros pueden ser de tipo bolean, entero, flotante y cadena de caracteres, pero también pueden ser "globales" de forma tal que se apliquen a todos los enlaces monitoreados o "específicos" de forma tal que se puedan establecer por enlace.

Los formularios en Django se modelan a través de una clase "Form" que provee todas las funcionalidades necesarias para el despliegue de formularios y validación de datos introducidos por el usuario, cuando deseamos crear un nuevo formulario debemos crear una subclase de "Form" e incluir todos los campos que serán parte del formulario y cualquier validación especial de dichos campos.

\subsection{Formulario de Parámetros de la Prueba}

Es posible crear clases de forma dinámica en tiempo de ejecucion usando las características de meta-programación de python; el Algoritmo \ref{alg:formgen} muestra la estructura básica para agregar campos al formulario según el tipo de datos de los parámetros, sin embargo cada parámetro también incluye datos para determinar si el campo es obligatorio, texto de ayuda y valor por omisión.


\begin{algorithm}[h]
	\caption{Generación dinámica de formularios}\label{alg:formgen}
	\begin{algorithmic}[1]
		\Procedure{make\_parameter\_form}{test,monitor}
		\State $\textit{parameters} \gets \text{get all parameters for } \textit{test}$
		
		\State $\textit{form\_fields} \gets \text{empty ordered dictionary}$
		
		
		\For{\textit{field}  \textbf{in} \textit{parameters}}
		
		\If{field is global}
			 \State $\textit{form\_fields[field.name]} \gets \Call{get\_field}{field.type}$
		\Else
			\State $\textit{links} \gets \text{all \textit{monitor} links}$
			\For{\textit{link}  \textbf{in} \textit{links}}
				\State $\textit{key} \gets \text{concatenate \textit{field.name} '\_' \textit{link.id}}$
				\State $\textit{form\_fields[key]} \gets \Call{get\_field}{field.type}$
			\EndFor
		\EndIf
		\EndFor
		
		\Return $\text{A class inheriting FORM base class containing \textit{form\_fields}}$
		\EndProcedure
		
		\Procedure{get\_field}{type}
			\If{type is boolean}
			\Return \text{boolean field}
			\ElsIf{type is integer}
			\Return \text{integer field}
			\ElsIf{type is float}
			\Return \text{float field}
			\ElsIf{type is string}
			\Return \text{char field}		
			\Else
			\State $\textbf{throw exception } \text{"The type is unsuported"}$
			\EndIf
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

La clase generada luego es pasada a una plantilla genérica capaz de dibujar cualquier formulario dado, cuando el usuario introduce los datos estos son validados por la misma forma, el formulario generado incluye validaciones básicas de tipos de datos, un trabajo futuro podría incluir validaciones mas complejas como intervalos máximos y mínimos para los capos numéricos o validaciones personalizables para campos  de tipo "string".

\subsection{Formulario de Planificación}

Junto con el formulario de parámetros debemos incluir un formulario para introducir las fechas iniciales, finales y intervalo entre pruebas en caso de ser una prueba periódica o el tiempo de ejecucion en caso de ser una prueba de una sola vez.

La validación de este formulario es usada para asegurar las reglas de negocio del sistema:
	\begin{enumerate}
		\item{La fecha inicial y la fecha final no pueden ser previas al tiempo actual}
		\item{la fecha final no puede ser previa a la fecha inicial}
		\item{La fecha inicial no puede ser modificada después de que la prueba ya ha comenzado}
		\item{El intervalo entre pruebas no puede ser menor o igual que 0.}
		\item{Solo puede ser planificada una prueba periódica simultánea del mismo tipo por monitor, es posible deshabilitar una prueba y luego planificar otra del mismo tipo para el mismo periodo}
	\end{enumerate}

Todas las fechas se validan usando la zona horaria del monitor, para validar la condición 5. se retiran de la base de datos todos los otros \textit{MonitorTest} pertenecientes a dicho monitor y cuya fecha final sea mayor al tiempo actual (es decir, aquellos que se estén ejecutando o se van a ejecutar en el futuro) y se verifica que la prueba a insertar en el plan de monitoreo no se intercepte con ninguna otra.

\section{Sincronización genérica de datos} \label{sec:syncgeneric}

El mecanismo general de recolección de datos se ha explicado detalladamente en la Sección \ref{sub:Recolector}, se ha dicho que por cada prueba activa para el monitor se llama a una subrutina de sincronización que descarga los archivos de trazas e introduce los resultados en la base de datos, sin embargo no se ha entrado en detalle sobre el método de procesamiento de los archivos y la forma en que los datos de cada prueba se almacenan en la base de datos.

\subsection{Almacén de datos}

Los resultados de las pruebas generalmente consisten de una marca de tiempo, un enlace relacionado y uno o mas valores conteniendo los datos obtenidos de las pruebas, desafortunadamente no hay forma de guardar datos de esta manera "semi-estructurada" en bases de datos estructuradas por lo que sería necesario definir dos tablas, una para guardar la marca de tiempo de la traza y el tipo de prueba y otra para guardar la lista de datos relacionados a esa prueba, sin embargo esto sería prohibitivamente ineficiente ya que habría que hacer varios joins en tablas de potencialmente cientos de millones de entradas solo para obtener los datos relacionados a una traza, igualmente se podría estar tentado a usar una tabla con el timestamp y un campo text para guardar datos en cualquier formato (como json), pero de nuevo esto sería ineficiente en términos de espacio de almacenamiento y no se podrían aprovechar las características del manejador de bases de datos para calcular promedios, máximos, mínimos o filtrar trazas por columnas específicas.

Estos argumentos evidencian la necesidad de definir modelos específicos diseñados para ajustarse a las necesidades de cada prueba y optimizados para facilitar y acelerar el cálculo de las visualizaciones relacionadas a las pruebas, como ya se vio con el calculo de mapas de calor para las datos de ping y httping.

Al diseñar el almacén de datos el desarrollador debe tomar en cuenta las características de los resultados de las pruebas, por ejemplo, muchas pruebas podrían ajustarse fácilmente al formato de una marca de tiempo seguida por un conjunto definido de valores obtenidos para ese instante, sin embargo, los resultados de las pruebas podrían tener cualquier otra estructura o estar compuestas de datos no-esturcturados; por ejemplo, traceroute tiene como resultado una lista de \textit{n} saltos para alcanzar el host destino y cada salto a su vez está compuesto de \textit{m} sondas.
 
%una primera aproximación podría ser guardar las marcas de tiempo y un identificador de la prueba en una tabla y en otra tabla guardar las sondas con su número de salto, host, ip, rtt y el id de la prueba relacionada, pero preferimos guardar en la base de datos el número de saltos total y un booleano indicando si se pudo alcanzar el host objetivo y guardar los datos de las sondas en un campo text ya que en ningún m

Django incluye un poderoso ORM que puede ayudar a construir y mantener cualquier modelo de base de datos estructurada, los cambios hechos al modelo son registrados por archivos de migración que pueden ser creados en el entorno de desarrollo y luego aplicados fácilmente en el entorno de producción con un comando de migración, de esta manera crear y agregar nuevas columnas e indices a los almacenes de datos es sencillo y rápido.

\subsection{Procesamiento de archivos de trazas}

Ya que los requisitos y características de cada prueba son distintas, el desarrollador de las pruebas tiene la libertad de establecer cualquier formato al guardar sus archivos de trazas, es por esto que el sincronizador no tiene una forma "generica" de procesador dichos archivos; depende del desarrollador escribir la función o \textit{parser} que tome como entrada un archivo de trazas en el formato establecido para el tipo de prueba y lo transforme en objetos a introducir en la base de datos.

Para elegir la función correcta para procesar un archivo de trazas específico el mecanismo de sincronización busca en la base de datos la dirección absoluta del método y lo importa, python incluye funcionalidades para importar módulos en tiempo de ejecucion y pasar métodos a modo de variables, esto puede verse en al Algoritmo \ref{alg:loadsync}.

\begin{algorithm}[h]
	\caption{Getter de la función de sincronización}\label{alg:loadsync}
	\begin{algorithmic}[1]
		\Procedure{get\_parser}{test}
		\State $\textit{function\_path} \gets \textit{test.sync\_function}$ \Comment{Se obtiene la ruta absoluta del parser}
		
		\State $\textit{module\_name,function\_name} \gets \text{split \textit{function\_path}}$ \Comment{Se separa la ruta separando el nombre de la funcíon del nombre del módulo}
		
		\State $\textit{module} \gets \Call{import}{module\_name}$ 
		
		\State $\textit{function} \gets \Call{get}{module,function\_name}$ \Comment{Retorna la funcion buscándola en el modulo}
		
		\Return $\textit{function}$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Es responsabilidad del desarrollador tanto escribir la ruta correctamente en la base de datos como implementar la función en sí, la función puede vivir en cualquier parte del código pero por convención se colocan en el módulo \textit{parsing.py} dentro del paquete \textit{management}.

El parser debe manejar archivos corruptos o mal formados evitando propagar excepciones al mecanismo general de sincronización y debe imponer las reglas de negocio específicas a la prueba, por ejemplo, no tiene sentido introducir a la base de datos valores negativos para el número de saltos para alcanzar un host en o valores imposiblemente altos, introducir valores espurios a la base de datos resultará en visualizaciones inesperadas o erróneas. 

En un trabajo futuro se podría incluir un esquema de archivos de trazas genéricos en los cuales cada línea del archivo representa una traza y cada traza viene dada por un diccionario en formato json, luego el parser puede leer el archivo y mapear los diccionarios a objetos e introducirlos en la tabla correspondiente a la prueba en la base de datos, eso se podría ajustar perfectamente a pruebas ya implementadas como las de ping, httping y iperf.

\section{Visualización genérica de datos}

Después de haber recolectado y almacenado los datos de las pruebas el ultimo paso lógico y el objetivo final del sistema de monitoreo es la visualización de los datos; las visualizaciones son cargadas y desplegadas a través de una interfaz genérica que incluye un formulario para seleccionar las opciones y los datos a visualizar, herramientas como re-computo de visualizaciones (para incluir los datos mas recientes en visualizaciones que estén obsoletas) , creación de enlaces directos para compartir y opciones para ver en una nueva pestaña.

Las visualizaciones al igual que las pruebas se guardan en su propia tabla en la base de datos; como ya se dijo en la Sección \ref{sub:basededatos}, esta tabla lleva el nombre de \textit{ResultView}, y sirve para ayudar al cargador genérico de visualizaciones tanto a computar gráficas como crear urls legibles y desplegar el formulario apropiado cuando se genera la gráfica. Los tipos de visualizaciones incluidos en el sistema se pueden ver en la Tabla \ref{tab:visual-types}

\begin{table}[h]
	\begin{tabular}{p{2.5cm}|p{12cm}}
		tipo        & descripción                                                                                                                                                                               \\ \hline
		heatmap     & Mapa de calor, útil para mostrar mostrar la densidad o concentración de una variable sobre un plano 2D.                                                       \\ \hline
		bar chart   & Gráfica de barras, útil para mostrar las proporciones entre un conjunto de valores.                                                                                                       \\ \hline
		line chart  & Gráfica lineal, útil para mostrar la evolución de una variable con respecto a otra.                                                                                                       \\ \hline
		scatter chart     & Gráfica de puntos, generalmente usada para mostrar los valores de un conjunto de muestras sobre un plano 2D                                                                               \\ \hline
		map         & Cualquier tipo de mapa útil para mostrar información geográfica.                                                                                                                          \\ \hline
		network     & Gráfica de red, útil para mostrar la relación entre distintas entidades.                                                                                                                  \\ \hline
		table       & Tabla, útil para mostrar todo tipo de información.                                            
		\\ \hline
		pie chart   & Gráfica de pie, útil para mostrar la proporción entre dos variables                                                                                                                       \\ \hline
		stock chart & Gráfica de stock, útil para mostrar la evolución de una variable y conjuntos especialmente grandes de datos.                                                                              \\ \hline
		csv         & \textit{Comma separated values} un tipo de archivo popularmente usado para analizar conjuntos de datos estructurados, podría ser usado para permitir análisis de datos externos a octopus \\ 
		json        & Formato json, podría usarse en versiones futuras para permitir implementar visualizaciones en otras plataformas o con otras herramientas.                                                 \\ \hline
		other       & Cualquier tipo de visualización que no quepa en las categorías anteriores.                                                                                                                \\
	\end{tabular}
	\caption{Tipos de visualizaciones soportadas por el sistema}
	\label{tab:visual-types}
	\
\end{table}

\subsection{Construcción de URLs genéricos}

Debemos recordar que estamos desarrollando un framework en el tope de una aplicacion web, por lo tanto, debemos tomar en cuenta que el servidor debe tener una manera de identificar las peticiones y poder relacionarlas a una visualización específica, en la mayoría de los casos sencillamente incluimos el identificador del objeto, por ejemplo, la dirección \textit{"/monitor/2/"} identifica de forma única la página del monitor con id 2, podríamos identificar las visualizaciones de la misma manera, sin embargo, preferimos usar cadenas de caracteres legibles por humanos que identifiquen la visualización por su nombre, a este tipo de cadenas de caracteres se les da el nombre de \textit{slug} y se construyen reemplazando todos los espacios en el nombre por guiones (-) y los caracteres especiales por sus equivalentes en ASCII. Cuando deseamos ver una visualización específica en vez de visitar un url como "/monitor/2/view/1" se visita un URL legible como "/monitor/2/view/average-rtt-heatmap".

Para generar el slug correspondiente a la visualización, sobrescribimos el método \textit{save} de la clase \textit{ResultView}, ya que solo deseamos generar el slug la primera vez que se guarda el registro, revisamos si el id es nulo (solo se le asigna el id a un objeto después de que es guardado por primera vez). Django incluye un método llamado \textit{slugify} que transforma la cadena de caracteres en un slug válido, los slugs pueden ser de hasta 50 caracteres, así que el si el slug es muy largo debe ser cortado, finalmente debemos asegurarnos de que  sea único, para esto buscamos en la base de datos otro \textit{ResultView} con el mismo slug y si se encuentra anexamos al final un guión y un número, esto se repite hasta hallar un slug único de hasta 50 caracteres.

\subsection{Interfaz de visualización}

Cuando un usuario selecciona una visualización de la lista de visualizaciones disponibles para su monitor, el servidor elije el formulario correspondiente, cada visualización tiene distintos parámetros de configuración, por ejemplo algunas pueden pedir al usuario que introduzca un tiempo inicial y un tiempo final para filtrar los datos, otras podrían tener opciones para seleccionar un mes específico, o un periodo de tiempo desde el momento actual como "últimas 24 horas" o "la semana pasada", algunas visualizaciones toman en cuenta los datos de todos los tentáculos de un monitor, otras piden seleccionar primero un tentáculo específico. Como hemos visto en varias oportunidades antes, los formularios no son mas que clases que podemos importar con el método definido en el Algoritmo \ref{alg:loadsync}, para esto la tabla \textit{ResultView} guarda una referencia a la clase del formulario en la columna \textit{form\_class}.

Ya que los formularios de las visualizaciones generalmente incluyen los mismos campos, el framework incluye algunos formularios que pueden ser reutilizados o extendidos para lograr cualquier comportamiento deseado; todos los formularios de visualizaciones heredan de un formulario base llamado \textit{BaseResultForm}, este recibe el id del monitor que luego podría ser usado por algún formulario que tome en cuenta los enlaces del monitor. Por ejemplo, la clase \textit{LinkSelectionForm} crea un menú para seleccionar de entre la lista de enlaces del monitor, todos los formularios predefinidos pueden ser vistos en la tabla \ref{table:formularios}

\begin{table}[h!]
	\centering

	\label{table:formularios}
	\begin{tabular}{l|l|p{8cm}}
		Clase               & Clase Base        & Descripción                                                                  \\ \hline
		BaseResultForm      & Form              & Formulario base para todas las visualizaciones                               \\
		LinkSelectionForm   & BaseResultForm    & Formulario para seleccionar enlace de un monitor                             \\
		SampleForm          & LinkSelectionForm & Formulario para seleccionar un número de muestras a graficar                 \\
		DateRangeForm       & BaseResultForm    & Formulario para seleccionar un periodo de tiempo a graficar                  \\
		ElapsedForm         & BaseResultForm    & Formulario para seleccionar un periodo de tiempo a partir del momento actual \\
		LinkMultiselectForm & BaseResultForm    & Formulario para seleccionar un conjunto de enlaces de un monitor            
	\end{tabular}
	\caption{Formularios predefinidos}
\end{table}

Una característica muy poderosa de los formularios es que se les puede "adjuntar" archivos javascript y hojas de estilo, luego la plantilla que dibuja el formulario puede vincular estos archivos y así obtener cualquier comportamiento deseado en el formulario, por ejemplo, el formulario de los mapas de calor de RTT permite seleccionar entre periodos de "todo el tiempo", "por año" y "por mes"; si se selecciona "año" se muestra un campo para introducir el año y si se selecciona "mes" se muestra un dropdown para seleccionar el mes. Los archivos css y javascript van dentro del paquete "management" en la carpeta "static/css" y "static/js" respectivamente.

Cuando el usuario hace click en el botón "PLOT" comienza el proceso de validación del formulario, una rutina javascript toma el control, extrae los valores seleccionados del formulario y los envía al servidor a través de una petición POST, el servidor valida el formulario y genera una respuesta json:
\begin{itemize}
	\item{Si el formulario es válido, el servidor codifica un url de la visualización con los parámetros en formato GET y un "url directo".}
	\item{Si el formulario es inválido el archivo json contiene un código HTML que luego se incrusta en el tope del formulario e indica los errores de validación.}
	\item{Si no se recibe respuesta del servidor o el código de estado de la respuesta es distinto de "200 OK", entonces la rutina javascript muestra un mensaje indicando al usuario que ocurrió un problema.}
\end{itemize}

Para desplegar las visualizaciones se usa un elemento HTML llamado \textit{iframe}, este elemento se usa para incrustar páginas html dentro de otras a partir de un URL dado, la rutina javascript le pasa al iframe el URL retornado en el archivo json y el iframe a su vez lo solicita al servidor, del lado del servidor el cargador genérico devuelve una visualización en formato HTML.

Algunas veces las visualizaciones pueden tardar largos periodos de tiempo en computarse, para ofrecer al usuario retroalimentación es recomendable mostrar algún tipo de animación de carga o indicador de progreso de la operación. Para implementar esta funcionalidad, se muestra una animación de carga inmediatamente después de que el usuario hace click en el botón "PLOT" o "Re-compute", luego es posible aprovechar una señal emitida por el iframe cuando obtiene respuesta del servidor para ocultar esta animación.

La característica de re-computar visualizaciones funciona de manera análoga al flujo normal de visualización, con la única diferencia de que se solicita al cargador genérico que ignore el caché y force el computo de la visualización.

\subsection{Cargador genérico de visualizaciones}

El cargador genérico de visualizaciones maneja la tarea de retornar visualizaciones listas en formato HTML, el cargador recibe el slug correspondiente a la visualización y una cadena de parámetros GET, el cargador no computa las visualizaciones inmediatamente, sino que primero se asegura de que la visualización exista en el caché.

Se puede decir que una visualización existe en el caché cuando los parámetros de dicha visualización son los mismos que los parámetros GET pasados al cargador, sin embargo, revisar esta condición traería una complejidad innecesaria ya que habría que guardar una arreglo de la lista de parámetros y compararlos cada vez que se solicita una visualización, esto sería lento y contra-propósito ya que habría que mantener tablas en memoria y hacer búsquedas sobre ellas. 

Para evitar esta complejidad, las visualizaciones se identifican a través de un código hash que se genera a partir de la lista de parámetros, luego es tan simple como buscar el archivo por nombre en la carpeta correspondiente, ya que la búsqueda en un directorio depende de la cantidad de archivos en el, dividimos el caché por carpetas para acelerar las consultas al caché, las carpetas tienen como nombre el slug de la visualización a la que pertenecen, por lo tanto un archivo en el caché se identifica como: $CACHE\_ROOT/<slug>/<hash>.html$

Cuando una búsqueda en el caché no obtiene resultados, entonces el sistema pasa a computar la gráfica, para esto, se guarda una referencia a la función en la base de datos, y esta se carga dinámicamente como ya se vió en el Algoritmo \ref{alg:loadsync}, las funciones de cómputo de visualizaciones se guardan dentro del paquete \textit{visual}, en un módulo con el nombre $<test>\_visual.py$ donde test es el nombre de módulo de la prueba a la pertenece dicha visualización.

El único requisito para las funciones de computo es retornar una cadena de caracteres válida en formato HTML (sin embargo los formatos CSV y JSON también son soportados), en caso de retornar algún otro tipo objeto (o retornar nulo) el usuario verá la representación en unicode de dicho objeto en la Interfaz de Visualización.

Se recomienda manejar apropiadamente las excepciones dentro de esta función, en caso contrario, estas se propagarán al cargador de visualizaciones que a su vez responderá con una página de error 500 que se cargará en el marco de la Interfaz de visualización.

\subsubsection{Plantillas genéricas}

Las plantillas son archivos que se usan para introducir el contenido variable de una página web dinámica a través del uso de un micro-lenguaje, el desarrollador tiene la libertad que escribir cualquier código HTML que desee, así como vincular cualquier dependencia como hojas de estilo, imágenes o archivos javascript. Para este trabajo se ha usado principalmente HighCharts y Google Maps, para dibujar la mayoría de las visualizaciones.

El desarrollador debe seguir una serie de pautas al escribir plantillas para visualizaciones, ninguna de ellas es obligatoria pero son recomendables para asegurar que el usuario tenga una experiencia consistente:
\begin{itemize}
	\item{La plantilla debe ajustarse responsivamente al ancho de la pantalla.}
	\item{Siempre se deben usar HighCharts o Google Maps sobre otras bibliotecas que tengas las mismas funcionalidades o similares.}
	\item{Las visualizaciones deben estar preferiblemente sobre fondo blanco.}
	\item{En caso de que no se encontraran datos para el periodo seleccionado, se debe mostrar un mensaje de alerta en vez de una visualización en blanco.}
	\item{se deben usar las hojas de estilo de Bootstrap al dibujar visualizaciones que estén compuestas de elementos HTML.}
\end{itemize}

Para simplificar la tarea de escribir código repetitivo, se ha incluido un conjunto plantillas predefinidas, algunas de ellas pueden ser extendidas para escribir nuevas visualizaciones, otras son plantillas listas para usar que aceptan alguna estructura de datos y resultan en una visualización, las plantillas predefinidas se pueden ver en la Tabla \ref{table:plantillas}.

\begin{table}[h!]
	\centering
	\label{table:plantillas}
	\begin{tabular}{l|p{10cm}}
		Plantilla                        & Descripcion                                                                                                               \\ \hline
		base-visual.html                             & Plantilla base para todas las visualizaciones                                                                             \\
		base-highcharts.html                   & Plantilla base para todas las visualizaciones con HighCharts                                                              \\
		base-highstock.html                    & Plantilla base para todas las visualizaciones con HighStock (submódulo de Hihcharts para dibujar stockcharts)            \\
		base-googlemaps.html                   & Plantilla base para visualizaciones con Google Maps.                                                                      \\
		generic-heatmap.html                  & Plantilla base para mapas de calor de tipo $<$hora,tiempo,valor$>$\\
		generic-stock.html              & Plantilla base para Stockcharts de tipo $tiempo,valor$                                                  \\
		generic-stock-multi.html & Plantilla base para Stockcharts de tipo \textless tiempo,valor\textgreater   con múltiples series.                             \\
		generic-line.html                & Plantilla base para gráficas de linea de tipo \textless time,value\textgreater                                             \\
		generic-line-multi.html   & Plantilla base para gráficas de linea de tipo \textless time,value\textgreater con múltiples series,                      
	\end{tabular}
	\caption{Plantillas Predefinidas}
\end{table}

\section{Workflow de integración de pruebas}

Habiendo entendido todos los componentes que son parte del Framework de Integración de pruebas, solo queda explicar como usarlos para integrar rápidamente una prueba en un entorno de producción. El workflow de integración de pruebas consiste a de dos etapas: la etapa de desarrollo y la etapa de despliegue, esto puede ser visto en la Figura \ref{fig:workflow}.

\begin{figure}[h]
\centering
\includegraphics[width=0.9\linewidth]{img/integrationworkflow.png}
\caption{El workflow de integración de pruebas}
\label{fig:workflow}
\end{figure}
 

\subsection{Etapa de Desarrollo}

Como su nombre lo indica, durante la etapa de desarrollo se diseñan, implementan y validan las pruebas y visualizaciones que serán parte del sistema en el futuro próximo; la etapa de desarrollo ocurre en un entorno de desarrollo que se configura para ser lo más parecido posible al entorno de producción y así evitar potenciales inconsistencias que devengan en errores al momento del despliegue. 

Para desarrollar código fácilmente en distintos entornos se usa un repositorio de código git, los cambios hechos en el entorno de desarrollo pueden ser descargados en el entorno de producción y aplicados al servidor web, los trabajadores celery y la base de datos; todos los componentes deben compartir la misma versión del código antes de ir a producción para evitar comportamientos inesperados durante su interacción.

Cuando se desea desarrollar una prueba, el primer paso es entender y describir los requisitos de la prueba, para facilitar el entendimiento de esta sección usaremos como ejemplo el diseño una prueba que determine la pérdida de paquetes usando el comando ping en modo flood, es decir, que ping generará y enviará paquetes tan rápido como pueda hasta pasar una cierta cantidad de paquetes y se determinará cuantos se perdieron durante la prueba, el módulo de pruebas solo debe encargarse de iniciar el comando y obtener los datos del número de paquetes envíados y el número de paquetes recibidos a partir de la salida.

El módulo de prueba se muestra a continuación, cada ejecucion de la prueba anexa una linea en formato  $<$marca de tiempo,paquetes enviados, paquetes recibidos$>$ al archivo de trazas correspondiente:

\begin{lstlisting}[language=Python,basicstyle=\small\sffamily,numbers=left,numberstyle=\tiny,frame=tb,columns=fullflexible,showstringspaces=false] 

def parse(out,link_id):
   time = str(time.strftime("%d_%m_%y_%H"))
   filename = os.path.join(DATA_FOLDER,"pkgloss","link_%s_%s.txt"%(link_id,time))
   output_file = open(filename,'a')

   lines= out.split('\n')

   for line in lines:
      if "packet loss" in line:
         tokens = line.split()
         sent = tokens[0]
         recieved = tokens[3]
         timestamp = time.time() #gets current time
         output_file.write(str(timestamp)+" "+sent+" "+recieved+"\n")
         break
   output_file.close()

def run(kwargs):
"""executes ping command for each of the test links specified in the config file
parameters:
-count number of icmp packages to send
-max_duration: maximum test durationg
"""
   count = kwargs["count"]
   max_duration = kwargs["maximum duration"]
   config = get_config()
   if config is None:
      return
   links = config["links"]

   for link in links.values():
      if not link["status"]: 
         continue
      try:
	     args = ["ping",link["ip"],"-f","-c",str(count),"-w","str(max_duration)"]
         output = check_output(args)
         parse(output,link["id"])
      except Exception as e:
         log.error(str(e))
\end{lstlisting}

Tras tener definido el módulo de prueba y el formato del archivo de trazas, pasamos a desarrollar el código que estará del lado de la aplicacion web, para esto, comenzamos con incluir en el modelo de la base de datos la tabla que alojará las trazas de esta prueba, para eso escribimos la clase \textit{TracePkgLoss}, esta consiste de un marca de tiempo (time), el identificador de enlace (link), el número de paquetes enviados (sent\_packets), el número de paquetes recibidos (recieved\_packets), el porcentaje de pérdida de paquetes (percentage) y un índice que indexa las columnas \textit{time} , \textit{link} y porcentaje de pérdida de paquetes, a continuación se muestra la definición de dicha clase:

\begin{lstlisting}[language=Python,basicstyle=\small\sffamily,numbers=left,numberstyle=\tiny,frame=tb,columns=fullflexible,showstringspaces=false] 

class TraceBase(models.Model):
   link = models.ForeignKey(Link)
   time = models.DateTimeField()

   class Meta:
      abstract = True
      unique_together = ("time", "link")

class TracegPkgLoss(TraceBase):
   sent_packets = models.IntegerField
   recieved_packets = models.IntegerField()
   percentage = models.SmallIntegerField()
   
   def save(self, *args, **kwargs):
      self.percentage = self.recieved/float/(self.sent)
      super(TracePkgLoss, self).save(*args, **kwargs)

   class Meta(TraceBase.Meta):
      index_together = [
               ["link", "time","percentage"],
            ]

\end{lstlisting}

Cuando hacemos cambios al modelo de la base de datos debemos crear archivos llamados \textit{migrations} que describen los cambios que deben realizarse sobre el modelo de la base de datos, para crear estos archivos, Django crea un archivo de migración inicial que luego compara con el modelo de la base de datos y así descubre los cambios que se han hecho, para realizar esta operación Django incluye el comando \textit{makemigrations}, las migraciones son guardadas en un paquete y conforman una especie de "historial" que puede ser aplicado a la base de datos en el entorno de producción.

El siguiente paso es crear el parser del archivo de trazas, ya que el archivo de trazas viene en formato csv es muy sencillo leer el archivo linea por linea, separar cada linea por el carácter ',', convertir las cadenas de caracteres en sus tipos de dato correspondiente y guardar cada traza en la base de datos, esta función se puede observar a continuación:

\begin{lstlisting}[language=Python,basicstyle=\small\sffamily,numbers=left,numberstyle=\tiny,frame=tb,columns=fullflexible,showstringspaces=false] 

def parse_pkgloss(f,filename,monitor):

   tokens = filename.split('/')
   filename_tokens = tokens[len(tokens)-1].split('_')
   link_id = int(filename_tokens[1])
   timezone = monitor.timezone

   for line in f.readlines():
      tokens = line.split()
      if len(tokens) < 3: continue
      time, sent, received = tokens[0], tokens[1], tokens[2]
      try:
         sent = int(sent)
         received= int(received)
         time = datetime.datetime.fromtimestamp(float(time),timezone)
      except Exception: continue
      trace = TracePkgLoss(link_id=link_id,time=time,sent_packets=sent,received_packets=received)

      try: trace.save()
      except IntegrityError: pass 
\end{lstlisting}

Ahora que tenemos los elementos necesarios para alojar los datos obtenidos de las pruebas solo nos queda definir las visualizaciones que harán uso de esas pruebas, por motivos de simplicidad solo definiremos una visualización que muestre una gráfica de stock del porcentaje de pérdida de paquetes desde el momento actual hasta una cantidad dada de tiempo en el pasado como 24 horas.

A continuación se puede observar el código de la visualización, primero tomamos del diccionario de parámetros el número de horas seleccionadas, luego hacemos una consulta a la base de datos extrayendo todas las trazas que caigan en el periodo de tiempo, luego recorremos el arreglo para localizar las marcas de tiempo a la zona horaria del monitor, finalmente llamamos al método \textit{render\_to\_string} que dibuja la plantilla, en este caso usamos la plantilla genérica \textit{generic-stock.html}.

\begin{lstlisting}[language=Python,basicstyle=\small\sffamily,numbers=left,numberstyle=\tiny,frame=tb,columns=fullflexible,showstringspaces=false] 
def generate_pkgloss_sample_stock(parameters):
   link_id = parameters["link"]
   period =  int(parameters["period"])
   link = Link.objects.get(id=link_id)
   min_time = datetime.datetime.now() - datetime.timedelta(hours=period)

   rows = TracePkgLoss.objects.values_list('time', 'elapsed').filter(time__gt=min_time,
                                                              link_id=link_id,
                                                              elapsed__gt=0)
   array = []
   for row in rows:
      array.append((row[0].astimezone(link.monitor.timezone),row[1]))

   return render_to_string("default_stock.html",{"rows":array,
	"title":"Elapsed Time Stock Chart",
	"series_name":"Sample Elapsed Time"})

\end{lstlisting}

Habiendo definido todas las clases y funciones necesarias, solo falta introducir en la base de datos los registros necesarios para que el sistema sepa de la nueva prueba y donde buscar las funciones correspondientes cuando necesite importarlas. Esto puede hacerse directamente desde el CRUD del sistema, sin embargo, podemos usar archivos llamados \textit{fixtures} que permiten definir los registros que queremos introducir a la base de datos en formato JSON y luego introducirlos a la base de datos en el entorno de producción con el comando \textit{loaddata}.

El fixture incluirá entonces, la entrada para la prueba, las entradas para los parámetros de la prueba y la visualización: 

\begin{lstlisting}[basicstyle=\small\sffamily,numbers=left,numberstyle=\tiny,frame=tb,columns=fullflexible,showstringspaces=false] 
[
  {
    "model": "main.test",
      "pk": 5,
      "fields": {
        "name": "Packet Loss",
        "module_name": "pkgloss",
        "description": "Sends a burst of ICMP packages in quick susecion and counts the number
         of lost packages",
        "is_periodic": true,
        sync_function: "octopusmonitor.management.parsing.parse_pkgloss"
      }
  },
  {
      "model": "main.parameter",
      "pk": 15,
      "fields": {
        "name": "Count",
        "description": "Number of packets to send",
        "type": "i",   (integer)
        "test_id": 5,
        "is_global": true,
        "default_value": "1000",
        "required": true
      }
  },
  ...
  {
    "model": "main.result_view",
    "pk": 26,
    "fields": {
      "name": "Package loss % Stockchart",
      "description": "Displays a stockchart of the last package loss data",
      "type": "k",   (stock chart)
      "test_id": 15,
      "form_class": "octopusmonitor.main.forms.ElapsedForm",
      "generating_function" "octopusmonitor.visual.pkgloss_visual.generate_pkgloss_sample_stock":
    }
  }
]

\end{lstlisting}



Antes de pasar a la siguiente etapa es recomendable probar exhaustivamente todo el código usando distintos conjuntos de datos, parámetros, o escribiendo pruebas unitarias.

\subsection{Etapa de Despliegue}

En la etapa de despliegue se aplicarán en el entorno de producción todos los cambios realizados en la etapa de desarrollo; esta etapa consiste en una serie de pasos intencionalmente simples y rápidos para evitar largas interrupciones de servicio mientras que estos son aplicados, después de que finaliza la etapa de despliegue la nueva prueba estará disponible para que los usuarios la incluyan a sus monitores. 

La etapa de despliegue comienza descargando la última versión del código del repositorio y parando el servidor web para evitar cualquier petición durante este periodo, es buena idea planificar los despliegues para momentos de baja carga del servidor, y notificar a los usuarios con previo avisto.

Para actualizar el servidor web y los trabajadores basta con reemplazar el código que estos ejecutan, sin embargo, para actualizar la base de datos se hace uso de archivos de migraciones que se crear en la etapa de desarrollo; las migraciones pueden ser aplicadas con el comando \textit{migrate}, para saber cual fue la última migración aplicada Django mantiene una tabla para llevar cuenta del estado de la base de datos, así es posible saber cuales de las migraciones deben ser aplicadas. Se debe tener especial ciudado al ejecutar migraciones, mientras algunas veces estas pueden ser rápidas y seguras, algunas migraciones incluyen operaciones costosas como agregar indices a tablas existentes o actualizar todas las entradas de una tabla, también es importante tomar en cuenta que las migraciones no incurran en conflictos con datos contenidos en la base de datos, por ejemplo, aplicar una restricción de unicidad sobre una columna con valores repetidos.

En la Sección \ref{sub:servidorweb} se dijo que la aplicacion web Django no se encarga de servir los archivos estáticos al cliente, es por esto que generalmente un entidad desacoplada ya sea el mismo servidor web configurado para servir ciertas rutas sin pasarlas a Django o otro servidor web aparte deben proveer este servicio, sin embargo los archivos estáticos viven junto al resto del código de la aplicacion, para que el servidor desacoplado pueda encontrar estos archivos, estos deben ser copiados al directorio apuntado por la variable \textit{STATIC\_ROOT}, para esto Django incluye el comando \textit{collectstatic} que busca en cada paquete los archivos estáticos y los copia a dicho directorio.

El paso final de despliegue es reiniciar los componentes que lo requieran, en otras palabras el servidor web y los trabajadores de modo que estos puedan importar el nuevo código, los demás micro-servicios como broker de mensajería, planificador y backend de resultados no requieren ser reiniciados durante los despliegues. 

Reiniciar el servidor web es trivial usando los comandos \textit{start, stop, restart}, sin embargo es buena idea borrar todos los archivos .pyc del código de la aplicacion para forzar a apache a releer todo el código antes de levantar la aplicacion. 

Reiniciar los trabajadores puede hacerse de distintas maneras dependiendo de la configuración elegida, por ejemplo, es posible usar un programa como \textit{supervisord\footnote{Supervisord es un programa que permite monitorear y controlar conjuntos de procesos en sistemas UNIX}} para que monitoree los trabajadores y se asegure de que se mantengan en linea todo el tiempo, sin embargo, también es posible enviarles mensajes a todos los trabajadores en modo broadcast para que se reinicien a sí mismos, esto puede facilitar despliegues en que se tienen trabajadores distribuidos en distintas máquinas, siempre y cuando se descargue la última versión del código en la maquina host del trabajador previamente, en futuras versiones el trabajador podría ser capaz de aceptar un comando para actualizarse y reiniciarse a si mismo.

\chapter{Conclusiones y Recomendaciones}

\section{Conclusiones}

Durante el desarrollo de este trabajo, construimos un sistema de monitoreo de redes de propósito general, ligero y extensible, el sistema permite recolectar y almacenar datos sobre el estado de la red a partir de pruebas planificadas y observar los resultados obtenidos a largo plazo. Para el diseño e implementación del sistema se usó una metodología en espiral en que se agregaron nuevas características incrementalmente a cada uno de los componentes del sistema.

Los logros mas relevantes desde un punto de vista computacional se nombran a continuación: 

\begin{itemize}
	\item{Se desarrolló una aplicacion web que permite a usuarios autenticados manejar de forma remota sus monitores de red, recolectar los datos obtenidos y finalmente observar los datos obtenidos a partir del monitoreo.}
	\item{Construimos un monitor de red con la cantidad de código mínimo para planificar tareas de monitoreo periódico de acuerdo al plan definido en la aplicacion web. El monitor escrito en python es ligero e ideal para desplegar en dispositivos de bajo costo (ver Capitulo \ref{cap:monitor}).}
	\item{Establecimos un esquema de sincronización a costo cero entre la aplicacion web y el monitor a través del uso de cuotas de almacenamiento en la nube y peticiones gratuitas al API de Dropbox.}
	\item{Para la aplicacion web se diseñó una arquitectura a cuatro capas capaz de manejar eficientemente las distintas tareas de la aplicacion web, esta arquitectura permite escalar cada uno de sus componentes tanto como sea necesario facilitando el manejo de mayores cargas de trabajo y usuarios.}
	\item{Para la aplicacion web se se diseño e implementó una interfaz sencilla y fácil de usar que se ajusta de manera fluida a la resolución de pantalla de cualquier dispositivo.}
	\item{Se desarrolló un framework para integrar fácilmente nuevas pruebas y visualizaciones al sistema, se encontraron los puntos comunes y las tareas repetitivas relacionadas con la implementación y despliegue de nuevas pruebas en un sistema en fase de producción (ver Capítulo \ref{cap:framework}).}
	\item{Se desarrolló una batería de pruebas para que fueran parte del sistema, así como para determinar los requisitos y pormenores del framework de integración de pruebas:}
	\begin{itemize}
		\item{\textbf{Prueba de ping:} fue la primera prueba implementada y se usa para determinar la latencia y disponibilidad de los enlaces, esta prueba se usó para inferir congestión en la red y periodos de actividad e inactividad.}
		\item{\textbf{Prueba de Httping:} similar a la prueba anterior, se usa para determinar el tiempo de respuesta usando peticiones HTTP.}
		\item{\textbf{Prueba de Traceroute:} se usó para determinar la alcanzabilidad de un nodo a través de un enlace y inferir detalles como congestión a nivel de nodos intermedios. Su implementación ayudó a inferir los requisitos de pruebas con resultados no estructurados.}
		\item{\textbf{Prueba con Iperf:} se usó para determinar el rendimiento de los enlaces así como para determinar los requisitos del sistema cuando fuera necesaria la colaboración de los nodos monitoreados.}
		
	\end{itemize}
	\item{Varios métodos de visualización de datos fueron conceptualizados e implementados y probaron ser una manera intuitiva de inferir hechos sobre el comportamiento y estado de la red, un ejemplo de esto fueron los mapas de calor de latencia que muestran al mismo tiempo patrones de congestión como áreas con colores calientes (rojos y amarillos) y ademas muestran periodos de inactividad como espacios en blanco.}
\end{itemize}

Ademas del diseño y desarrollo del sistema, también se ejecutaron pruebas para determinar el rendimiento, estabilidad y escalabilidad tanto de la aplicacion web como del monitores en escenarios reales de producción incluidos casos de uso de la vida real.

Un monitor de pruebas fue desplegado para probar algunos servicios críticos de REDULA tales como ula.ve, saber.ula.ve y un servidor de RESIDE. Este monitor de pruebas se mantuvo conectado a la nube y recolectando datos constantemente durante periodos de semanas y meses y no mostró problemas de rendimiento o estabilidad.

La aplicacion web fue desplegada en un servidor de pruebas, la integracion y prueba constante de nuevas caracteristicas en este entorno de produccion fue crucial en el desarrollo del workflow de integracion de pruebas, la aplicacion web está disponible en el siguiente URL: http://www.octopusmon.it/octopusmonitor. 

El esquema de sincronización de datos a través de la nube usando el API de Dropbox probó ser una manera confiable de transferir datos entre los monitores y la aplicacion web, a pesar de que existe un límite de peticiones diarias que puede hacerse al API por usuario, este nunca fue alcanzado incluso con las máximas frecuencias de sincronización; se observó un máximo de 3602 peticiones por día, cada monitor conectado a la nube usará unas 3000 peticiones diarias. Al momento de escribir este documento, se han sincronizado mas de 1161533 trazas usando este mecanismo, cada una de ellas representando el resultado de la ejecucion de una prueba.

Se realizaron pruebas de rendimiento al sistema para aproximar la cantidad de usuarios concurrentes que este sería capaz de atender en el hardware disponible, descubrimos que la aplicacion web sería capaz de atender 768 peticiones \textbf{dinámicas} por minuto lo que equivale a 1105920 por día, sin embargo solo sería capaz de atender 32 peticiones con minuto dado que estas incluyan la descarga de archivos estáticos, por lo tanto concluimos que para asegurar la escalabilidad del sistema es conveniente delegar esta tarea a otro servidor o un servicio de entrega de contenidos.

A pesar de que hacer análisis sobre los datos recolectados esta fuera del alcance de este trabajo, se realizaron descubrimientos útiles sobre la latencia, disponibilidad y estabilidad de los enlaces monitoreados; por ejemplo, se encontró un patrón claro de menor latencia y mayor estabilidad en el periodo entre las 12am y las 8am, lo cual corresponde al patrón de uso esperado de la red, encontramos constantes periodos de inactividad para ula.ve al igual que tiempos de respuesta mas largo en comparación con saber.ula.ve, ademas encontramos que ambos sitios rechazan paquetes del protocolo ICMP, por lo que se monitorearon a través de HTTP, esto solo para nombrar algunos resultados relevantes.

\section{Recomendaciones}

Como trabajos futuros, proponemos la implementación de algoritmos de sincronización que ademas de introducir datos en la base de datos sean capaces de detectar condiciones criticas a partir de los datos recolectados y alertar proactivamente al usuario emitiendo notificaciones a través de la aplicacion web, email o sms. Las alertas podrían ser anexadas a las pruebas y podrían funcionar como parte del framework de integración de pruebas.

También sería posible la implementación de nuevos esquemas de sincronizacion con los monitores que permitan el streaming de datos en tiempo real desde los monitores hasta el navegador del usuario, ya sea permitiendo que el servidor web sirva para negociar una conexion directa entre ellos, o que el servidor web sirva como relé a través del cual se pasen los datos.


\appendix


\chapter{Casos de uso de la aplicacion web.}

\subsection{Usuario no autenticado}


\begin{table}[h!]
	\caption{Caso de uso  Ver Página Principal}
	\begin{center}
		\footnotesize{
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{UN-01}} & \multicolumn{2}{l}{\textit{Ver página principal}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario desea visitar la página principal del sistema.}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario escribe el URL del sitio y presional enter. \\
			& 2 & El servidor retorna la página principal. \\
			% Linea de Secuencia excepciones
			\multirow{2}{*}{\textbf{\textit{Excepciones}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 3 & Si el servicio no está disponible el usuario ve un mensaje de error 503. \\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Pantalla principal del sistema.}\\
			
		\end{tabular}
	}
	\end{center}
\end{table}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Inicio de sesión}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{UN-02}} & \multicolumn{2}{l}{\textit{Iniciar sesión}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario desea ingresar al sistema.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{Pantalla principal del sistema.}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario hace click en el enlace de login. \\
			& 2 & El servidor muestra el formulario de login. \\
			& 3 & El usuario ingresa sus credenciales. \\
			& 4 & El usuario hace click en el botón login. \\
			% Linea de Secuencia excepciones
			\multirow{2}{*}{\textbf{\textit{Excepciones}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 3 & Si las credenciales son incorrectas el servidor informa del error. \\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Usuario autenticado y Pantalla "Home".}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Registro de usuario}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{UN-03}} & \multicolumn{2}{l}{\textit{Registro de usuario}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario desea registrarse para ingresar al sistema.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{pantalla principal del sistema.}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario hace click en el enlace de registro. \\
			& 2 & El servidor muestra el formulario de registro. \\
			& 3 & El usuario ingresa su nombre de usuario \\
			& 4 & El usuario ingresa su contraseña\\
			& 5 & El usuario ingresa su correo electrónico \\
			& 6 & El usuario hace click en el botón submit \\
			& 7 & El servidor envía un correo electrónico de confirmación \\
			% Linea de Secuencia excepciones
			\multirow{2}{*}{\textbf{\textit{Excepciones}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 7 & Si el nombre de usuario o correo electronico son incorrectos el servidor informa del error. \\
			& 8 & Si las contraseñas no coinciden el servidor informa del error. \\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{usuario registrado y correo enviado.}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Confirmación de usuario}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{UN-04}} & \multicolumn{2}{l}{\textit{Confirmación de usuario}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario desea confirmar su cuenta.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{Correo de confirmación enviado (UN-03).}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario hace click en el enlace de confirmación \\
			& 2 & El servidor activa la cuenta del usuario \\
			% Linea de Secuencia excepciones
			\multirow{2}{*}{\textbf{\textit{Excepciones}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 3 & Si el código de confirmación está vencido la activación falla. \\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Cuenta de usuario activa y Pantalla de Login.}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Recuperar contraseña}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{UN-05}} & \multicolumn{2}{l}{\textit{Recuperar contraseña}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario ha olvidado su contraseña y desea recuperarla.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de login.}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario hace click en "forgot password" \\
			& 2 & El usuario ingresa su correo electrónico\\
			& 3 & El servidor envía un correo electrónico de recuperación de contraseña\\
			& 4 & El usuario hace click en el enlace de recuperación\\
			& 5 & El usuario ingresa una nueva contraseña \\
			% Linea de Secuencia excepciones
			\multirow{2}{*}{\textbf{\textit{Excepciones}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 6 & Si las contraseñas no coinciden el servidor informa del error. \\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Contraseña restablecida.}\\
		\end{tabular}
	\end{center}
\end{table}

\FloatBarrier
\subsection{Usuario}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Cambiar contraseña}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{UA-01}} & \multicolumn{2}{l}{\textit{Cambiar contraseña}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario desea cambiar su contraseña.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de cuenta de usuario.}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario hace click en "cambiar contraseña" \\
			& 2 & El usuario ingresa su nueva contraseña\\
			& 3 & El usuario confirma su nueva contraseña\\
			& 4 & El servidor actualiza la contraseña\\
			% Linea de Secuencia excepciones
			\multirow{2}{*}{\textbf{\textit{Excepciones}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 6 & Si las contraseñas no coinciden el servidor informa del error. \\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Contraseña actualizada.}\\
		\end{tabular}
	\end{center}
\end{table}


\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Vincular cuenta de Dropbox}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{UA-02}} & \multicolumn{2}{l}{\textit{Vincular cuenta de Dropbox}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario desea vincular su cuenta de Dropbox con Octopus Monitor.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de cuenta de usuario.}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario hace click en "vincular cuenta de Dropbox" \\
			& 2 & El servidor retorna un enlace a Dropbox y un formulario\\
			& 3 & El usuario hace click en el enlace\\
			& 4 & El usuario ingresa a Dropbox\\
			& 5 & El usuario da permisos a la aplicacion de Octopus Monitor\\
			& 6 & Dropbox muestra un código al usuario\\
			& 7 & El usuario ingresa el código en el formulario\\
			& 8 & El servidor envía el codigo a Dropbox\\
			& 9 & Dropbox retorna el código de acceso del usuario\\
			& 10 & El servidor actualiza el perfil del usuario\\
			% Linea de Secuencia excepciones
			\multirow{2}{*}{\textbf{\textit{Excepciones}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 5 & Si el usuario no da permisos a la aplicacion el flujo termina. \\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Cuenta de Dropbox vinculada.}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Ver monitores}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{UA-03}} & \multicolumn{2}{l}{\textit{Ver monitores}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario desea ver la lista de sus monitores.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{Pantalla "Home".}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario hace click en "monitores" en el menú lateral \\
			& 2 & El servidor retorna la lista de los monitores\\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de monitores.}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Crear monitor}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{UA-04}} & \multicolumn{2}{l}{\textit{Crear monitor}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario desea crear un monitor.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de monitores.}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario hace click en el boton de agregar monitor \\
			& 2 & El servidor envía el formulario de datos básicos\\
			& 3 & El usuario ingresa los datos básicos del monitor\\
			& 3 & El usuario hace click en "next"\\
			& 4 & El servidor envía el formulario de localización\\
			& 5 & El usuario ingresa los datos de localización\\
			& 6 & El usuario hace click en "next"\\
			\multirow{2}{*}{\textbf{\textit{Excepciones}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 2 & Si los datos no son validos el servidor informa del error. \\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de instrucciones de instalación del monitor.}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Ver monitor}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{UA-05}} & \multicolumn{2}{l}{\textit{Ver monitor}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario desea ver los detalles de un monitor.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de monitores.}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario hace click en el enlace "view" de un monitor \\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Pantalla del monitor.}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Editar monitor}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{UA-05}} & \multicolumn{2}{l}{\textit{Editar monitor}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario desea editar los detalles de un monitor.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{Pantalla del monitor.}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario hace click en el boton "edit" del monitor \\
			& 2 & El servidor envía el formulario de edición \\
			& 3 & El usuario ingresa los datos \\
			& 4 & El usuario hace click en el botón "done" \\
			\multirow{2}{*}{\textbf{\textit{Excepciones}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 3 & Si los datos no son validos el servidor informa del error. \\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Pantalla del monitor.}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Eliminar monitor}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{UA-06}} & \multicolumn{2}{l}{\textit{Eliminar monitor}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario desea eliminar un monitor.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{Pantalla del monitor.}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario hace click en el boton "delete" del monitor \\
			& 2 & El servidor envía un dialogo de confirmación \\
			& 3 & El usuario confirma que desea continuar \\
			& 4 & El servidor elimina el monitor y todos las entradas relacionadas en el base de datos \\
			\multirow{2}{*}{\textbf{\textit{Excepciones}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 3 & Si el usuario no confirma el flujo termina. \\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de monitores.}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Ver Tentáculos}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{UA-07}} & \multicolumn{2}{l}{\textit{Ver Tentáculos}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario desea ver la lista de tentáculos para un monitor.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{Pantalla del monitor.}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario hace click en el enlace "tentaculos" del sub-menu lateral del monitor \\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de Tentáculos.}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Registrar tentáculo}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{UA-08}} & \multicolumn{2}{l}{\textit{ Registrar tentáculo}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario desea registrar un tentáculo.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de tentáculos.}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario hace click en el botón "register tentacle" \\
			& 2 & El servidor envía el formulario de registro de tentáculo\\
			& 3 & El usuario ingresa los datos del tentáculo \\
			& 4 & El usuario hace click en "submit" \\
			\multirow{2}{*}{\textbf{\textit{Excepciones}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 3 & Si los datos no son válidos el servidor informa del error. \\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de tentáculos.}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Editar tentáculo}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{UA-09}} & \multicolumn{2}{l}{\textit{ Editar tentáculo}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario desea editar un tentáculo.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de tentáculos.}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario hace click en el ícono de lapiz del tentáculo en la lista. \\
			& 2 & El servidor envía el formulario de edición de tentáculo\\
			& 3 & El usuario ingresa los datos del tentáculo \\
			& 4 & El usuario hace click en "submit" \\
			\multirow{2}{*}{\textbf{\textit{Excepciones}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 3 & Si los datos no son válidos el servidor informa del error. \\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de tentáculos.}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Editar localización del tentáculo}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{UA-10}} & \multicolumn{2}{l}{\textit{ Editar tentáculo}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario desea editar la localización un tentáculo.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de tentáculos.}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario hace click en el ícono del marcador de mapa del tentáculo en la lista. \\
			& 2 & El servidor envía el formulario de localizacion de tentáculo\\
			& 3 & El usuario ingresa los datos de localización tentáculo \\
			& 4 & El usuario hace click en "submit" \\
			\multirow{2}{*}{\textbf{\textit{Excepciones}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 3 & Si los datos no son válidos el servidor informa del error. \\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de tentáculos.}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Ver plan de monitoreo}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{UA-11}} & \multicolumn{2}{l}{\textit{ Ver plan de monitoreo}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario desea ver el plan de plan de monitoreo.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{Pantalla del monitor.}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario hace click en "tests" en el menú lateral de navegación. \\
			& 2 & El servidor envía un menú para seleccionar el tipo de prueba a observar\\
			& 3 & El usuario selecciona un tipo de prueba y hace click en "view test plan" \\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de Plan de Monitoreo para una prueba.}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Planificar prueba periódica}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{UA-12}} & \multicolumn{2}{l}{\textit{ Planificar prueba periódica}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario desea planificar una prueba de tipo periódico.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de plan de Monitoreo.}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario hace click en el botón "schedule periodic tests". \\
			& 2 & El servidor envía una lista de pruebas disponibles para el monitor\\
			& 3 & El usuario selecciona una prueba de la lista. \\
			& 4 & El servidor envía el formulario de planificacion y configuracion de prueba \\
			& 5 & El usuario ingresa la fecha inicial, final y el intervalo entre pruebas \\
			& 6 & El usuario ingresa los parámetros de la prueba \\
			& 7 & El usuario hace click en el boton "submit" \\
			& 8 & El servidor guarda la prueba y sube un mensaje al buzón del monitor\\
			\multirow{2}{*}{\textbf{\textit{Excepciones}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 5 & Si la fechas son inválidas o el intervalo no es un número el servidor informa del error. \\
			& 6 & Si alguno de los parámetros es invalido el servidor informa del error\\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de detalles de la prueba.}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Planificar prueba}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{UA-13}} & \multicolumn{2}{l}{\textit{ Planificar prueba}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario desea planificar una prueba para un momento específico.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de plan de Monitoreo.}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario hace click en el botón "schedule periodic tests". \\
			& 2 & El servidor envía una lista de pruebas disponibles para el monitor\\
			& 3 & El usuario selecciona una prueba de la lista. \\
			& 4 & El servidor envía el formulario de planificacion y configuracion de prueba \\
			& 5 & El usuario ingresa la fecha inicial, final y el intervalo entre pruebas \\
			& 6 & El usuario ingresa los parámetros de la prueba \\
			& 7 & El usuario hace click en el boton "submit" \\
			& 8 & El servidor guarda la prueba y sube un mensaje al buzón del monitor\\
			\multirow{2}{*}{\textbf{\textit{Excepciones}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 5 & Si los datos no son válidos el servidor informa del error. \\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de detalles de la prueba.}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Editar prueba}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{UA-14}} & \multicolumn{2}{l}{\textit{ Editar prueba}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario desea modificar los parámetros de una prueba planificada.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de detalles de la prueba.}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario edita los campos que desea cambiar o redefinir. \\
			& 2 & El usuario hace click en el botón "Submit"\\
			& 3 & El servidor guarda la prueba y sube un mensaje al buzón del monitor\\
			\multirow{2}{*}{\textbf{\textit{Excepciones}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & Si los datos no son válidos el servidor informa del error. \\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de detalles de la prueba.}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Habilitar/Deshabilitar prueba}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{UA-15}} & \multicolumn{2}{l}{\textit{ Habilitar/Deshabilitar prueba}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario desea habilitar o deshabilitar una prueba.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de detalles de la prueba.}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario hace click en el enlace enable/disable test. \\
			& 2 & El servidor cambia el estado de la prueba y sube un mensaje al buzón del monitor\\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de detalles de la prueba.}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Seleccionar visualización}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{UA-16}} & \multicolumn{2}{l}{\textit{ Seleccionar visualización}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario desea ver una visualización de datos para un monitor.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{Pantalla del monitor.}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario hace click en "results" en el menú lateral de navegación. \\
			& 2 & El servidor filtra las visualizaciones según las pruebas que se han activo para el monitor y envía la lista\\
			& 3 & El usuario busca una visualización en la lista y hace click sobre el enlace correspondiente\\
			
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de visualización de resultados.}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Computar visualización}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{UA-17}} & \multicolumn{2}{l}{\textit{ Computar visualización}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario desea computar una visualización.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de visualización de resultados.}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario introduce los parámetros de configuración de la visualización en el formulario. \\
			& 2 & El usuario hace click en el botón "PLOT"\\
			& 3 & El servidor valida el formulario y envía un URL directo de cómputo de visualización\\
			& 4 & El navegador solicita el URL en segundo plano\\
			& 5 & El servidor busca en el caché o computa la visualización\\
			& 6 & El servidor retorna la visualización\\
			& 7 & El navegador enmarca la visualización en la interfaz\\
			\multirow{2}{*}{\textbf{\textit{Excepciones}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & Si los datos no son válidos el servidor informa del error. \\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de visualización de resultados.}\\
		\end{tabular}
	\end{center}
\end{table}

\FloatBarrier

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Re-computar visualización}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{UA-18}} & \multicolumn{2}{l}{\textit{ Re-computar visualización}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario desea computar una visualización para incluir nuevos datos sin pasar por el caché.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de visualización de resultados.}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario introduce los parámetros de configuración de la visualización en el formulario. \\
			& 2 & El usuario hace click en el botón "Re-compute"\\
			& 3 & El servidor valida el formulario y envía un URL directo de re-cómputo de visualización\\
			& 4 & El navegador solicita el URL en segundo plano\\
			& 5 & El servidor computa la visualización\\
			& 6 & El servidor retorna la visualización\\
			& 7 & El navegador enmarca la visualización en la interfaz\\
			\multirow{2}{*}{\textbf{\textit{Excepciones}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & Si los datos no son válidos el servidor informa del error. \\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de visualización de resultados.}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Ver enlace directo de una visualización}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{UA-19}} & \multicolumn{2}{l}{\textit{ Ver enlace directo de una visualización}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario desea ver el enlace directo de una visualización para compartir.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{UA-17, UA-18.}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario hace click en el botón "View direct link"\\
			& 2 & El navegador muestra el enlace directo de la visualización\\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de visualización de resultados.}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Ver visualización en nueva pestaña}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{UA-20}} & \multicolumn{2}{l}{\textit{ Ver visualización en nueva pestaña}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario desea ver la visualización a tamaño completo en una nueva pestaña.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{UA-17, UA-18.}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario hace click en el enlace "View in new tab"\\
			& 2 & El navegador abre una nueva pestaña con el URL de la visualización\\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de Visualización.}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Ver detalles de sincronización}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{UA-21}} & \multicolumn{2}{l}{\textit{ Ver detalles de sincronización}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario ver el horario de sincronización y la información sobre las últimas sincronizaciones.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{Pantalla del monitor}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario hace click en el enlace "Sync" en el sub-menú del monitor \\
			& 2 & El servidor devuelve la Pantalla de sincronización\\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de sincronización}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Sincronizar monitor}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{UA-22}} & \multicolumn{2}{l}{\textit{ Sincronizar monitor}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario desea sincronizar un monitor inmediatamente.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de sincronización}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario hace click en el boton "Sync now" \\
			& 2 & El servidor encola la sincronizacion del monitor\\
			& 3 & El servidor devuelve la pantalla de sincronización con un mensaje indicando al usuario que espere.\\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de sincronización}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Definir horario de sincronización}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{UA-23}} & \multicolumn{2}{l}{\textit{  Definir horario de sincronización}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario desea definir el horario de sincronización de un monitor.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de sincronización}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario selecciona un esquema de sincronización \\
			& 2 & El navegador muestra el formulario para el esquema seleccionado\\
			& 3 & El usuario introduce los datos.\\
			& 4 & El usuario hace click en "Submit".\\
			& 5 & El servidor actualiza la base de datos.\\
			& 6 & El planificador detecta los cambios y ajusta el tiempo de la próxima sincronización del monitor\\
			\multirow{2}{*}{\textbf{\textit{Excepciones}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 3 & Si los datos no son válidos el servidor informa del error. \\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de sincronización}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Crear reporte}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{UA-24}} & \multicolumn{2}{l}{\textit{  Crear reporte}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario desea crear  un nuevo reporte.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de reportes}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario hace click en el botón "Crear Reporte" \\
			& 2 & El servidor envía un formulario de crear reporte\\
			& 3 & El usuario introduce el nombre del reporte.\\
			& 4 & El usuario introduce el cuerpo del reporte\\
			\multirow{2}{*}{\textbf{\textit{Excepciones}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 3 & Si los datos no son válidos el servidor informa del error. \\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Pantalla del reporte}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Editar reporte}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{UA-25}} & \multicolumn{2}{l}{\textit{  Editar reporte}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario desea editar un reporte existente.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{Pantalla del reporte}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario hacer click en el botón "editar"\\
			& 2 & El servidor envía el formulario de edición de reporte\\
			& 3 & El usuario introduce los cambios al reporte\\
			& 4 & El servidor guarda los cambios\\
			\multirow{2}{*}{\textbf{\textit{Excepciones}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 2 & Si los datos no son válidos el servidor informa del error. \\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Pantalla del reporte}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Cambiar privacidad del reporte}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{UA-26}} & \multicolumn{2}{l}{\textit{ Cambiar privacidad del reporte}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario desea hacer un reporte público o privado.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{Pantalla del reporte}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario hacer click en el botón "Public" o "Private"\\
			& 2 & El navegador envía una petición asíncrona al servidor\\
			& 3 & El servidor guarda los cambios y devuelve una respuesta exitosa\\
			& 4 & El navegador actualiza la interfaz mostrando el nuevo estado de privacidad\\
			& 5 & El servidor guarda los cambios\\
			\multirow{2}{*}{\textbf{\textit{Excepciones}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 2 & Si el servidor no responde se alerta al usuario. \\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Pantalla del reporte}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Agregar visualización a un reporte}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{UA-27}} & \multicolumn{2}{l}{\textit{Agregar visualización a un reporte}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario desea agregar una visualización a un reporte.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{Pantalla del reporte}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario hacer click en el botón "Add Result"\\
			& 2 & El usuario computa una visualización (UA-17) \\
			& 3 & El usuario hace click en el botón "Add to Report"\\
			& 4 & El navegador muestra un formulario para agregar comentarios al reporte\\
			& 5 & El usuario introduce comentarios sobre la visualización\\
			& 6 & El usuario somete el formulario\\
			& 7 & El servidor agrega la visualización al reporte\\
			\multirow{2}{*}{\textbf{\textit{Excepciones}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 5 & Si los datos introducidos son inválidos el servidor alerta el problema. \\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de Visualización}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Editar visualización de un reporte}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{UA-28}} & \multicolumn{2}{l}{\textit{ Editar visualización de un reporte}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario desea editar los comentarios de una visualización en un reporte.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{Pantalla del reporte}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario hacer click en los comentarios del reporte\\
			& 2 & El navegador muestra un formulario para editar los comentarios \\
			& 3 & El usuario hace los cambios al texto\\
			& 4 & El hace click en el botón "aceptar"\\
			& 5 & El servidor actualiza el reporte y devuelve una respuesta exitosa\\
			& 6 & El navegador actualiza la interfaz\\
			\multirow{2}{*}{\textbf{\textit{Excepciones}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 3 & Si los datos introducidos son inválidos el servidor alerta el problema. \\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Pantalla del Reporte}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Eliminar visualización de un reporte}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{UA-29}} & \multicolumn{2}{l}{\textit{Eliminar visualización de un reporte}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario desea eliminar una visualización en un reporte.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{Pantalla del reporte}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario hacer click en el enlace "remove" correspondiente a la visualización\\
			& 2 & El servidor actualiza el reporte \\
			& 3 & El servidor envía el reporte sin la visualización eliminada\\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Pantalla del Reporte}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Eliminar visualización de un reporte}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{UA-29}} & \multicolumn{2}{l}{\textit{Eliminar visualización de un reporte}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario desea eliminar una visualización en un reporte.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{Pantalla del reporte}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario hacer click en el enlace "remove" correspondiente a la visualización\\
			& 2 & El servidor actualiza el reporte \\
			& 3 & El servidor envía el reporte sin la visualización eliminada\\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Pantalla del Reporte}\\
		\end{tabular}
	\end{center}
\end{table}

\FloatBarrier

\subsection{Administrador}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Inicio de sesión}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{AD-01}} & \multicolumn{2}{l}{\textit{Iniciar sesión}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El administrador desea ingresar al sistema de administración.}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario visita el subdominio de administración. \\
			& 2 & El servidor muestra el formulario de login. \\
			& 3 & El usuario ingresa sus credenciales. \\
			& 4 & El usuario hace click en el botón login. \\
			% Linea de Secuencia excepciones
			\multirow{2}{*}{\textbf{\textit{Excepciones}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 3 & Si las credenciales son incorrectas el servidor informa del error. \\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Usuario autenticado y Pantalla de Administración.}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Seleccionar modelo}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{AD-02}} & \multicolumn{2}{l}{\textit{Seleccionar modelo}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El administrador desea seleccionar un modelo de la lista de modelos del sistema.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de administración del sistema}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario hace click al enlace del modelo en la lista. \\
			& 2 & El servidor muestra la página del modelo. \\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Pantalla del modelo.}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Crear prueba}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{AD-03}} & \multicolumn{2}{l}{\textit{Crear prueba}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El administrador desea crear una prueba nueva.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{AD-02}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario hace click en el botón "add test".\\
			& 2 & El servidor envía el formulario de prueba nueva.\\
			& 3 & El usuario introduce el nombre, descripción, nombre de módulo, tipos y ruta de la función de sincronización de la prueba. \\
			& 4 & El usuario somete el formulario. \\
			& 5 & El servidor guarda la prueba. \\
			\multirow{2}{*}{\textbf{\textit{Excepciones}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 3 & Si los datos no son válidos el servidor informa del error. \\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de administración}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Editar prueba}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{AD-04}} & \multicolumn{2}{l}{\textit{Editar prueba}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El administrador desea editar una prueba existente.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{AD-02}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario selecciona una prueba de la lista.\\
			& 2 & El servidor envía el formulario de edición de prueba.\\
			& 3 & El usuario introduce los datos a editar. \\
			& 4 & El usuario somete el formulario. \\
			& 5 & El servidor guarda los cambios. \\
			\multirow{2}{*}{\textbf{\textit{Excepciones}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 3 & Si los datos no son válidos el servidor informa del error. \\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de administración}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Agregar parámetro}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{AD-05}} & \multicolumn{2}{l}{\textit{Agregar parámetro}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El administrador desea agregar un parámetro a una prueba.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{AD-02}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario hace click en el botón "add parameter".\\
			& 2 & El servidor envía el formulario de parámetro nuevo.\\
			& 3 & El usuario introduce el nombre, descripción, tipo, valor por defecto. \\
			& 4 & El usuario selecciona la prueba a la que el parámetro pertenece de una lista. \\
			& 5 & El usuario somete el formulario. \\
			& 6 & El servidor guarda el parámetro. \\
			\multirow{2}{*}{\textbf{\textit{Excepciones}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 3 & Si los datos no son válidos el servidor informa del error. \\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de administración}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Editar parámetro}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{AD-06}} & \multicolumn{2}{l}{\textit{Editar parámetro}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El administrador desea editar un parámetro de una prueba existente.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{AD-02}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario selecciona un parámetro de la lista.\\
			& 2 & El servidor envía el formulario de edición de  parámetro.\\
			& 3 & El usuario introduce los datos a editar. \\
			& 4 & El usuario somete el formulario. \\
			& 5 & El servidor guarda el parámetro. \\
			\multirow{2}{*}{\textbf{\textit{Excepciones}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 3 & Si los datos no son válidos el servidor informa del error. \\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de administración}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Eliminar parámetro}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{AD-07}} & \multicolumn{2}{l}{\textit{Eliminar parámetro}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El administrador desea eliminar un parámetro de una prueba existente.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{AD-02}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario selecciona un parámetro de la lista.\\
			& 2 & El servidor envía el formulario de edición de  parámetro.\\
			& 3 & El usuario hace click en el enlace "eliminar". \\
			& 4 & El servidor envía una página de confirmación. \\
			& 5 & El usuario confirma la eliminación. \\
			& 6 & El servidor eliminar el parámetro. \\
			\multirow{2}{*}{\textbf{\textit{Excepciones}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 5 & Si el usuario no confirma la eliminación no se elimina el parámetro. \\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de administración}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Crear visualización}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{AD-08}} & \multicolumn{2}{l}{\textit{Crear visualización}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El administrador desea crear una nueva visualización.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{AD-02}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario hace click en "crear visualización".\\
			& 2 & El servidor envía el formulario de visualización nueva.\\
			& 3 & El usuario introduce el nombre, descripción, tipo, y la clase del formulario y ruta de la función de cómputo. \\
			& 4 & El usuario selecciona la prueba relacionada a la visualización. \\
			& 5 & El usuario somete el formulario. \\
			& 6 & El servidor guarda la visualización. \\
			\multirow{2}{*}{\textbf{\textit{Excepciones}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 3 & Si los datos no son válidos el servidor informa del error. \\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de administración}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Editar visualización}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{AD-09}} & \multicolumn{2}{l}{\textit{Editar visualización}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El administrador desea editar una visualización existente.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{AD-02}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario selecciona una visualización de la lista.\\
			& 2 & El servidor envía el formulario de edición de  visualización.\\
			& 3 & El usuario introduce los datos a editar. \\
			& 4 & El usuario somete el formulario. \\
			& 5 & El servidor guarda la visualización. \\
			\multirow{2}{*}{\textbf{\textit{Excepciones}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 3 & Si los datos no son válidos el servidor informa del error. \\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de administración}\\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!] \footnotesize
	\caption{Caso de uso  Eliminar parámetro}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{AD-10}} & \multicolumn{2}{l}{\textit{Eliminar visualización}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El administrador desea eliminar una visualización existente.}\\
			\textbf{\textit{Precondicion}} & \multicolumn{2}{p{10cm}}{AD-02}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario selecciona una visualización de la lista.\\
			& 2 & El servidor envía el formulario de edición de  visualización.\\
			& 3 & El usuario hace click en el enlace "eliminar". \\
			& 4 & El servidor envía una página de confirmación. \\
			& 5 & El usuario confirma la eliminación. \\
			& 6 & El servidor eliminar la visualización. \\
			\multirow{2}{*}{\textbf{\textit{Excepciones}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 5 & Si el usuario no confirma la eliminación no se elimina el parámetro. \\
			\textbf{\textit{Postcondicion}} & \multicolumn{2}{p{10cm}}{Pantalla de administración}\\
		\end{tabular}
	\end{center}
\end{table}

\chapter{Casos de uso del monitor de red}

\begin{table}[h] \footnotesize
	\caption{Caso de uso  Iniciar monitor}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{TM-01}} & \multicolumn{2}{l}{\textit{Iniciar monitor}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario desea iniciar el monitor de red tentacle.}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario invoca el cliente con el comando "start". \\
			& 2 & El cliente crea el proceso daemon y retorna. \\
			% Linea de Secuencia excepciones
			\multirow{2}{*}{\textbf{\textit{Excepciones}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 3 & Si el archivo pid existe entonces el cliente muestra un mensaje de error indicando que el monitor ya se esta ejecutando. \\
		\end{tabular}
	\end{center}
\end{table}


\begin{table}[h] \footnotesize
	\caption{Caso de uso  Detener monitor}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{TM-02}} & \multicolumn{2}{l}{\textit{Detener monitor}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario desea detener el monitor que se esta ejecutando en modo daemon.}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario invoca el cliente con el comando "stop". \\
			& 2 & El cliente abre el archivo pid y envía la señal SIGTERM al proceso daemon. \\
			& 3 & El monitor maneja la excepción deteniendo su ejecución. \\
			% Linea de Secuencia excepciones
			\multirow{3}{*}{\textbf{\textit{Excepciones}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 4 & Si el archivo pid no existe, el cliente informa al usuario que el monitor no se esta ejecutando. \\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h] \footnotesize
	\caption{Caso de uso  Reiniciar monitor}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{TM-03}} & \multicolumn{2}{l}{\textit{Reiniciar monitor}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario desea reiniciar el monitor que se esta ejecutando en modo daemon.}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario invoca el cliente con el comando "restart". \\
			& 2 & El cliente abre el archivo pid y envía la señal SIGTERM al proceso daemon. \\
			& 3 & El monitor maneja la excepción deteniendo su ejecución. \\
			& 4 & El cliente crea el proceso daemon y retorna. \\
			% Linea de Secuencia excepciones
			\multirow{3}{*}{\textbf{\textit{Excepciones}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 5 & Si el archivo pid no existe, el cliente informa al usuario que el monitor no se esta ejecutando. \\
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h] \footnotesize
	\caption{Caso de uso  Ver Plan de Monitoreo}
	\begin{center}
		\begin{tabular}{r|p{0.7cm}p{9.3cm}}
			\textbf{\textit{TM-04}} & \multicolumn{2}{l}{\textit{Ver Plan de Monitoreo}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario desea ver el plan de ejecución del monitor.}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario invoca el cliente con el comando "jobs". \\
			& 2 & El cliente abre la base de datos y retira la información. \\
			& 3 & El cliente muestra por pantalla las tareas planificadas y los enlaces monitoreados y retorna. \\
			% Linea de Secuencia excepciones
			\multirow{3}{*}{\textbf{\textit{Excepciones}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 5 & Si la base de datos no se ha creado muestra una lista vacía. \\
		\end{tabular}
	\end{center}
\end{table}

%***************************************************************** %
% FIN DE estructura tentativa de la Propuesta
% ***************************************************************** %

% Estilo de la bibliografï¿½a
\bibliographystyle{ieeetr}

% ***************************************************************** %
% Para agregar toda la bibliografia del archivo .bib
% solo descomente el siguiente comando
% ***************************************************************** %
\nocite{*}
% ***************************************************************** %
% Nombre del archivo con extensiï¿½n .bib en donde se almacena la bibliografï¿½a
\bibliography{bib-tesis}

% ***************************************************************** %
% FIN DE
% Cuerpo
% ***************************************************************** %

\end{document}
