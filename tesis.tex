\documentclass[12pt,oneside]{book}

\usepackage{ulamonog} % formato para la propuesta o proyecto de grado
\usepackage[ansinew]{inputenc} % escribir acentos



%\usepackage[activeacute,spanish]{babel}

\usepackage{color}
\usepackage[colorlinks]{hyperref}
\usepackage[table,xcdraw]{xcolor}
\usepackage{multirow}
\usepackage{colortbl}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\definecolor{light-gray}{gray}{0.95}
\usepackage{listings}

% ***************************************************************** %
% En el siguiente comando se pueden modificar:
% Titulo, Autor, Palabras clave
% ***************************************************************** %

% si se va a imprimir,
% se incluye al final despues de citecolor=blue, el comando draft=true
% Las siguientes son propiedades del pdf, mï¿½s no cambian nada dentro del
% texto de la monografï¿½a
\hypersetup{pdftitle={Propuesta de Tesis},
pdfauthor={Jesús Gómez},
pdfsubject={Propuesta de Proyecto de Grado}, % se deja igual (se cambia para el proyecto de grado)
pdfkeywords={ Monitoreo de redes, Calidad de servicio, Big Data, Benchmarking, Cloud}, pdfstartview=FitH,
bookmarks=true, citecolor=blue}%, draft=true}

% ***************************************************************** %
% FIN DE
% Titulo, Autor, Palabras clave
% ***************************************************************** %

% Si desea que no aparezca la lista de tablas o figuras descomente las siguientes lineas
\nolistoftables
\nolistoffigures

%\usepackage{natbib}

\sloppy

\begin{document}

\frontmatter


% ***************************************************************** %
% Portada y resumen
% ***************************************************************** %

% Si desea que el logo de la ULA aparezca en la parte superior,
% descomente la siguiente lï¿½nea. Por defecto aparece en la parte inferior
\logoarriba{}

% Aï¿½o en el cual se entrega el proyecto de grado o la propuesta
\copyrightyear{2015}

% Al final cuando hayan presentado, sin comentar,
% deberia ser el nï¿½mero de tesis presentada y la opciï¿½n, IO por ejemplo
% (Actualmente, 11-03-08, no se estï¿½ trabajando con esta metodologï¿½a de llevar un
% nï¿½mero de proyecto para las tesis, por lo cual debe ir comentado)
%\numproy{00IO}

% En caso de hacer la propuesta, descomente la siguiente
% instrucciï¿½n. Para el Proyecto de Grado debe comentarse. Modifica
% tanto la categorï¿½a de la monografï¿½a, como la apariciï¿½n de
% "Presentado ante la ilustre Universidad de Los Andes
% como requisito parcial para obtener el Tï¿½tulo de" en la portada
%\tipomonografia{Propuesta de Proyecto de Gradooo}


% Tï¿½tulo de la monografï¿½a, el cual saldrï¿½ en la portada
\title{Diseño e implementación de un sistema de monitoreo de redes orientado a la recolección masiva de datos.}

% Autor de la monografï¿½a, el cual saldrï¿½ en la portada
 \author{Jesús Alberto Gómez Pérez}

% La fechaentrega, presentaciondia, presentacionlugar
% y mencionespecial, es para aquel caso en el cual se
% vaya a utilizar la hoja del veredicto en el formato
% que se presenta aquï¿½. El primerjurado, segundojurado,
% y cedula, son campos que pueden llenarse, pero sï¿½lo
% aparecerï¿½n si se utiliza la pï¿½gina del veredicto

% Cï¿½dula del autor de la monografï¿½a
 \cedula{XX.XXX.XXX}

% Tutor del Proyecto de Grado
 \tutor{Dr. Andrés Arcia-Moret}

% Cualquiera de los instructores que aparecen a continuaciï¿½n
% pueden comentarse o descomentarse segï¿½n sea el caso:

%%% Cotutor del Proyecto de Grado
% \cotutor{Dra. propuesta}
% \cotutordos{Dra. propuesta dos}
%%% Asesor del Proyecto de Grado
% \asesor{Dr. Asesor}
%%% Asesor Industrial del Proyecto de Grado
% \asesorindustrial{Dr. Asesor Industrial}
%%% Tutor Industrial del Proyecto de Grado
% \tutorindustrial{Dr. Tutor Industrial}
%%% Jurados del Proyecto de Grado
 \primerjurado{Dr. Primer Profesor}
 \segundojurado{Prof. Segundo Profesor}

% ***************************************************************** %
% Si sabe la fecha de presentaciï¿½n
%
% con o sin comentar
% (Esta hoja es un formato para asentar la nota del proyecto de grado;
% sin embargo, la hoja que se utiliza para ese fin, se busca en la escuela
% dï¿½as antes de la presentaciï¿½n)
% ***************************************************************** %
%\fechaentrega{Diciembre 2006} % Si sabe cuando se presentï¿½
%\presentaciondia{7 de Diciembre de 2005} % si conoce exactamente el dï¿½a
%\presentacionlugar{Salï¿½n de reuniones EISULA} % si conoce exactamente el lugar donde se presentï¿½
% ***************************************************************** %
% FIN DE
% Si sabe la fecha de presentaciï¿½n
% ***************************************************************** %


% ***************************************************************** %
% Si tiene mencion especial
% con o sin comentar
% ***************************************************************** %
%\mencionespecial{Este proyecto fue seleccionado como \textbf{mejor
%proyecto de grado} de la Escuela de Ingenierï¿½a de Sistemas, en el
%IC aniversario de la Facultad de Ingenierï¿½a.} % si tiene menciï¿½n especial
% (El texto puede cambiarse \mencionespecial{*********} segï¿½n corresponda
% ***************************************************************** %
% FIN DE
% Si tiene mencion especial
% con o sin comentar
% ***************************************************************** %

% NO TOCAR si es Ingenieria de Sistemas
% \grado{Ingeniero Quï¿½mico} % por defecto Ingeniero de Sistemas

%\signaturepage ----- NO TOCAR

%%%%%OJO%%%%%Arreglen esto segï¿½n su opciï¿½n
% Si es control y automatizacion se comentan las siguientes lï¿½neas. Si es de
% Sistemas Computacionales comenta la tercera. De Investigaciï¿½n de Operaciones
% comenta la segunda
\opcion{Sistemas Computacionales}
% \opcion{Investigaciï¿½n de Operaciones}

% Aquï¿½ se escribe el resumen de la monografía
\resumen{En el presente proyecto se plantea el desarrollo de un sistema de monitoreo distribuido de enlaces críticos de redes a través de un servicio web centralizado. Este servicio además pretende hacer énfasis en la visualización de los datos recolectados a partir de pruebas periódicas. El sistema está planteado como una herramienta para facilitar el entendimiento del funcionamiento de la red y ofrecer una solución centralizada, de muy bajo costo y con componentes de hardware que puedan estar desatendidos.}

% Aquï¿½ se escriben las palabras claves de la monografï¿½a
\descriptores{Monitoreo de redes, Calidad de servicio, Big Data, Benchmarking, Cloud}

% Esto es para que salga la cota en la hoja del resumen. Actualmente,
% 11-03-08, en la Escuela de Ingenierï¿½a de Sistemas no es necesario
% buscar la cota previamente, sino que el Proyecto de Grado se entrega
% en la Escuela sin cota.
%\cota{IXD A01.1}

% Si desea eliminar la frase "Este trabajo fue procesado en LATEX"
% del resumen, descomente la siguiente lï¿½nea
\sinlatex{}

% ***************************************************************** %
% FIN DE
% Portada y resumen
% ***************************************************************** %


% ***************************************************************** %
% Si tiene dedicatoria
% con o sin comentar
% ***************************************************************** %
%\dedicatoria{A todos los amados seres\\ cuando son dos lï¿½neas o mï¿½s}
% ***************************************************************** %
% FIN DE
% Si tiene dedicatoria
% ***************************************************************** %

\beforepreface

% ***************************************************************** %
% Agradecimientos y capï¿½tulos NO numerados
% ***************************************************************** %

%\prefacesection{Agradecimientos}
% Aï¿½n no hay agradecimientos

%%% Capitulo sin numero, antes de la pagina 1

%\prefacesection{Introducciï¿½n}
% Este es un ejemplo de una secciï¿½n no numerada.


% ***************************************************************** %
% FIN DE
% Agradecimientos y capï¿½tulos NO numerados
% ***************************************************************** %

\afterpreface

\pagestyle{fancyplain}
\renewcommand{\chaptermark}[1]{\markboth{#1}{\textsc{\footnotesize\thechapter\ #1}}}
\renewcommand{\sectionmark}[1]{\markright{\textsc{\footnotesize\thesection\ #1}}}
\lhead[\fancyplain{}{\textsc{\footnotesize\thepage}}]%
{\fancyplain{}{\rightmark}}
\rhead[\fancyplain{}{\leftmark}]%
{\fancyplain{}{\textsc{\footnotesize\thepage}}} \cfoot{}

\mainmatter

% ***************************************************************** %
% Cuerpo
% ***************************************************************** %
% De aquï¿½ en adelante se desarrollan los capï¿½tulos numerados de la monografï¿½a

% ***************************************************************** %
% INICIO DE estructura tentativa de la Propuesta
% ***************************************************************** %

\chapter{Introducción}

\section{Antecedentes}

Existen dos estrategias de monitoreo de redes: monitoreo activo o benchmarking que consiste en generar tráfico para realizar medidas y comprobar la respuesta de la red  y monitoreo pasivo que consiste en escanear el tráfico de la red en ciertos puntos estratégicos para censar el tráfico en la red. El benchmarking tiene la desventaja de tener que inyectar tráfico lo cual puede entorpecer el funcionamiento normal de la red ejemplos de herramientas de benchmarking son ping, iperf y traceroute.

El monitoreo pasivo tiene la ventaja de que nos puede dar una muy buena idea del uso de la red sin embargo para mayor efectividad debe realizarse en nodos intermedios a los que muchas veces no tenemos acceso, ejemplos de herramientas de monitoreo pasivo son tcpdump y wireshark; en ambos casos hay que resaltar que es difícil tener una imagen completa de la realidad de la red.

Uno de los trabajos más importantes en el área de monitoreo de redes es el Protocolo Simple de Administración de Red o SNMP (del inglés Simple Network Management Protocol) este emergió como una de las primeras soluciones al problema de manejo de redes y se ha convertido en la solución más ampliamente aceptada  debido a su diseño modular e independiente de productos o redes específicas. SNMP consiste de (1) un administrador de red, (2) una serie de dispositivos remotos monitoreados (3) bases de información de administración (MIBs) en estos dispositivos, (4) agentes remotos que reportan la información de las MIBs al administrador de red y toman acciones si les indica y (5) un protocolo de comunicación entre los dispositivos \cite{Kurose:13}.

SNMP no solo ofrece al administrador de red reportes sobre cada uno de los dispositivos administrados sino que también permite tomar acción sobre ellos proactivamente antes de que ocurran problemas o de forma reactiva para solucionar problemas cuando ocurren de forma inesperada.

La red de TVWS (TV White Spaces o Espacios blancos en el espectro radioeléctrico) de Malawi fue implementada en el marco de un proyecto para llevar Internet a áreas rurales en países en vías de desarrollo utilizando soluciones de bajo costo a través de los espacios en blanco en el espectro radioeléctrico específicamente en la banda UHF (siglas del inglés Ultra High Frequency, 'frecuencia ultra alta') \cite{Malawi:13}.

Muchas veces esta red debe dejarse desatendida durante largos periodos de tiempo ya que sus nodos son de difícil acceso o es muy costoso tener a profesionales dedicados que se encarguen de su mantenimiento, este escenario hace evidente la necesidad de una solución de monitoreo de redes a distancia y de mínimo mantenimiento. Además es atractivo para el centro de monitoreo de la red poder añadir, modificar o eliminar nodos de interés de manera sencilla a la interfaz de monitoreo.

Para intentar solucionar este problema y recolectar información sobre la red de Malawi se implementó un sistema en dos partes: un monitor de red instalado en la estación base (BS) en Malawi y un servicio web remoto, el monitor en la estación base se conecta a cada uno de los nodos de la red y determina el tiempo de ida y vuelta (RTT por sus siglas en ingles)  de forma automatizada en ciertos intervalos de tiempo, guarda los resultados en archivos y los coloca en una carpeta que se sincroniza a través de un servicio en la nube  de tipo PaaS (Plataforma como servicio) con el servidor web, que a su vez escanea la carpeta compartida y actualiza su base de datos que puede usarse para generar gráficas de RTT promedio y determinar tiempos de actividad continuos y porcentaje de disponibilidad de servicio \cite{MalawiNetMonitor:15}.

A pesar de que este sistema recolecta información útil y presenta gráficas muy sencillas de entender, su programación no permite agregar nuevos nodos, esto trae como consecuencia que debe ser modificado manualmente cuando la red se expande, dando lugar a la necesidad de que el servicio web se pueda expandir para dar servicio a múltiples monitores remotos simultáneamente.

Por estos motivos proponemos la construcción de un sistema de monitoreo a gran escala que llamaremos Octopus Monitor, para hacerlo totalmente configurable y robusto además de agregar una interfaz de configuración vía web que permita manejar usuarios, agregar monitores remotos, agregar nodos y modificar los parámetros de las pruebas, todo esto apoyándonos en un sistema de archivos compartidos a través de la nube.

Mientras que  el mayor valor de Malawinet Monitor es la visualización de grandes volúmenes de datos  que se pueden obtener a partir de pruebas de bajo impacto de tráfico (ping, traceroute), se han realizado otros trabajos en el área de monitoreo de redes como Bowlmap; este es un sistema de monitoreo de redes a través de la visualización de mediciones para el Laboratorio Abierto Inalámbrico de Berlín (BOWL,  por sus siglas en ingles). Este sistema tiene una alta flexibilidad ya que permite realizar cambios en sus pruebas existentes así como agregar pruebas totalmente nuevas y a su vez generar las visualizaciones necesarias para el análisis de dicha información, además tiene la ventaja de solo transmitir la información necesaria para cada actualización lo que acelera las peticiones y permite la visualización de data en tiempo real \cite{Bowlmap:12}.

\section{Planteamiento del Problema}

Las redes de computadoras se componen de un conjunto de nodos interconectados sujetos a numerosos factores que escapan de nuestro control y sobre los que muchas veces no tenemos conocimiento, en otras palabras la red puede llegar a ser impredecible y no ofrece garantías sobre el servicio que ofrece; algunas aplicaciones dependen de una alta disponibilidad y estabilidad por lo que es esencial para un administrador de red tener información del estado de la red, para diagnosticar,  solucionar problemas y asegurar la calidad de servicio.

Existen muchos otros ejemplos en los que es importante tener datos del estado de la red como en redes de bajo costo en las que pueden ocurrir largas interrupciones de servicio o para un cliente de un servicio de alojamiento web que desea saber si su sitio web está disponible y que tan rápido responde; plataformas como Pingdom \cite{PINGDOM} o UptimeRobot \cite{UPTIMEROBOT} permiten monitorear distintos servicios en Internet y generan alertas cuando encuentran problemas, sin embargo no son gratuitas y no permiten la inclusión de nuevos tipos de pruebas o la visualización masiva de datos históricos.

 Mantener estas mediciones con las herramientas existentes se vuelve una tarea compleja mientras crece el número de nodos a monitorear (es decir, las fuentes de información) y la cantidad de datos aumenta a través del tiempo, sumado a esto solo podemos capturar información a partir de los nodos externos de la red, por lo que en la mayoría de los casos no es posible tener una imagen completa de los enlaces a monitorear.

  A pesar de que Malawinet Network Monitor podría ofrecer estadísticas de tiempo de ida y vuelta (RTT) y disponibilidad de un enlace solo a partir de las trazas capturadas con Ping, se desea además implementar un marco de trabajo que permita agregar nuevas pruebas automatizadas que ayuden a obtener una imagen más completa de la red.
  
\section{Justificacion}
  


\section{Objetivos}

\subsection{Objetivos Generales}

Construir un servicio web de monitoreo de redes de bajo costo para países en vías de desarrollo con almacenamiento de datos en la nube de tipo PaaS que sea de fácil instalación y permita configurar múltiples monitores remotos para ajustarse a cambios en las características de las redes a monitorear y la carencia de personal in sitio.

\subsection{Objetivos Específicos}

\begin{itemize}
\item Desarrollar un servicio de monitoreo de bajo costo para países en vías de desarrollo que de servicio a múltiples monitores de red remotos, presente visualizaciones gráficas a partir de los datos recogidos y ofrezca un marco de trabajo para agregar nuestros tipos de pruebas a los monitores de red existentes.
\item Desarrollar un cliente monitor para desplegar en nodos desatendidos con dispositivos recolectores de muestra de bajo costo (ej. Raspberry PI, Alix boards, APU) para observar el comportamiento de los enlaces a través de aplicaciones de monitoreo sencillas y de consola.
\item Utilizar de sistemas de bajo costo y alta disponibilidad en la nube para almacenamiento y transferencia de datos.
\item Integrar los distintos subsistemas que conforman el servicio de monitoreo.
\item Desarrollar un modulo de calculo asíncrono de gráficas que permita mejorar los tiempos de interacción del usuario final con el sistema utilizando técnicas para agilizar cómputo como caching, prefetching, threads, etc.
\end{itemize}

\section{Metodología}

En este trabajo se seguirá una metodología en espiral; el modelo en espiral es un modelo del ciclo de vida del software donde el esfuerzo del desarrollo es iterativo. Cada ciclo de la espiral representa una fase del desarrollo de software, cada uno de los ciclos consiste de los siguientes pasos:
\begin{enumerate}
  \item Determinar o fijar los objetivos. En este paso se definen los objetivos específicos para posteriormente identifica las limitaciones del proceso y del sistema de software, además se diseña una planificación detallada de gestión y se identifican los riesgos.
  \item Análisis del riesgo. En este paso se efectúa un análisis detallado para cada uno de los riesgos identificados del proyecto, se definen los pasos a seguir para reducir los riesgos y luego del análisis de estos riesgos se planean estrategias alternativas.
  \item Desarrollar, verificar y validar. En este tercer paso, después del análisis de riesgo, se eligen un paradigma para el desarrollo del sistema de software y se lo desarrolla.
  \item Planificar. En este último paso es donde el proyecto se revisa y se toma la decisión si se debe continuar con un ciclo posterior al de la espiral. Si se decide continuar, se desarrollan los planes para la siguiente fase del proyecto.
\end{enumerate}

Se realizarán cuatro ciclos, el primero corresponde a la realización de un monitor remoto básico que realice mediciones de RTT de la red con almacenamiento en la nube y visualizaciones de los datos obtenidos.

El segundo ciclo consiste en permitir el monitoreo de una cantidad arbitraria de monitores remotos permitiendo a múltiples usuarios manejar sus monitores remotos desde el servicio web y observar las visualizaciones.

El tercer ciclo corresponde en diseñar e integrar una prueba con otras herramientas (traceroute, iperf, etc) para conseguir puntos comunes y generar un enfoque de integración sencillo de los wrappers futuros a las aplicaciones. (ej. Lidiar con aplicaciones que requieren enfoque cliente solo [ping] o cliente-servidor [iperf]).

El cuarto ciclo consiste en hacer análisis del rendimiento del sistema y hacer las optimizaciones necesarias para ofrecer una calidad de servicio apropiada, determinar costos, limitaciones y requisitos mínimos para implementar en países en vías de desarrollo.

\section{Alcanze}

\section{Estructura del Documento}


%
%******************************
%FIN DE CAPITULO I
%******************************
%

\chapter{Marco Teórico}

En este capitulo se presentan los conceptos necesarios para la comprensión de este documento y se describen las herramientas de software y formatos que se emplearán para el desarrollo del sistema propuesto.

\section{Monitoreo de Redes}



\section{Principio Fin-a-Fin}



\section{Métricas de calidad de un enlace}



\subsection{Tiempo de ida y vuelta (RTT)}



\subsection{Throughput}


\subsection{Jitter}



\subsection{Actividad del enlace}



\subsection{Perdida de paquetes}

\subsection{Alcanzabilidad}

\section{Big Data}

\section{Data Visualization}

\section{Computacion en la nube}

\subsection{IaaS}


\subsection{PaaS}

\subsection{SaaS}


\section{Herramientas usadas para el desarrollo del sistema}

\subsection{Django}

\subsection{Celery}

\subsection{Redis} \label{sub:redis}

\subsection{Bases de Datos}

\subsection{Modelo Vista Controlador (MVC)}

\subsection{Caching}

\subsection{Dropbox API}

\subsection{Json}

\subsection{Diseño web adaptable}

\subsection{Highcharts}

\subsection{Google Maps}

\subsection{freegeoip}

\subsection{Ajax}

\subsection{APScheduler}

\subsection{Ping} \label{sub:ping}

\subsection{Requests}

\subsection{Traceroute}

\section{Estado del Arte}

\subsection{Tabla comparativa del estado del arte}

\chapter{Monitor de Red "Octopus Tentacle"}

Octopus Tentacle (OT) es un monitor de red ligero, diseñado para ajustarse a las limitaciones de sistemas de bajo costo y con la intensión de ser desplegado en las redes que se desea monitorear y ser dejado desatendido durante periodos arbitrarios de tiempo.

OT ejecuta pruebas en intervalos regulares, recogiendo datos sobre distintas métricas, los resultados de las pruebas son guardados en un espacio de almacenamiento compartido en la nube para que la aplicación web sea capaz de retirar estos datos posteriormente.

Uno de los objetivos principales de Octopus Tentacle es ejecutar las pruebas en el momento preciso, ya que el posterior análisis de los datos exige que las muestras se tomen con un patrón regular y conocido, para esto se hace uso de un planificador, cada prueba se ejecuta en su propio hilo, siendo posible que varias pruebas se ejecuten simultáneamente.

El monitor OT posee una arquitectura basada en plugins que hace posible agregar nuevas pruebas en tiempo de ejecución, sin necesidad de reiniciar el monitor, eliminando potenciales interrupciones a pruebas que ya se están ejecutando. Esto también implica que no importa cuantas pruebas estén disponibles, el monitor solo tiene en memoria aquellas que son parte del conjunto de pruebas a ejecutar.

El comportamiento del monitor viene dado por un archivo de configuración en formato json, este archivo se aloja en el almacenamiento compartido en la nube y funge de interfaz entre los monitores remotos y la aplicación web. OT revisa regularmente este archivo y lo compara con su estado interno haciendo los cambios que sean necesarios. 

\section{Diseño del Monitor}

El diseño del monitor esta sujeto a los siguientes baremos: 

\begin{itemize}
	\item{\textbf{Estabilidad} ya que el monitor podría dejarse desatendido es esencial que sea estable, si el monitor no se está ejecutando el usuario no obtendrá resultados en la aplicación web.}
	\item{\textbf{Flexibilidad} el monitor debe ser capaz de cargar nuevas pruebas en tiempo de ejecución, esto es especialmente importante ya que no desea interrumpir otras pruebas que se estén ejecutando}
	\item{\textbf{Planificación precisa} es importante que las pruebas se ejecuten en el momento adecuado, siguiendo de la manera mas fiel posible la planificación dada.}
	\item{\textbf{Ejecutable en equipos de bajo costo} el monitor debe incluir el código mínimo para su funcionamiento y tener un uso muy bajo de memoria.}
	\item{\textbf{Configuración remota} el monitor debe tener algún protocolo para actualizar su estado interno a partir de cambios hechos en la aplicación web.}
	\item{\textbf{Bitacora} ya que el monitor se ejecuta como un proceso daemon, se desea tener una bitácora donde se puedan leer mensajes sobre ciertos eventos importantes del monitor.}
\end{itemize}

\subsection{Arquitectura}

Como se puede observar en la figura \ref{fig:tentacle-components.png}, Octopus Tentacle tiene una arquitectura basada en componentes altamente desacoplados con una interfaz bien definida para facilitar el desarrollo de la aplicación.

\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{img/tentacle-components.png}
	\caption{Diagrama de Componentes Octopus Tentacle}
	\label{fig:tentacle-components.png}
\end{figure} 

\subsection{Diagrama de actividades}

La ejecución del monitor Tentacle comienza en el cliente, el cliente es el encargado de instanciar el proceso daemon y lo hace a través de un método bien conocido de doble fork. Para asegurarse de no ejecutar múltiples instancias del monitor se revisa un archivo .pid, si el archivo existe significa que el monitor se está ejecutando y el cliente informa del error al usuario. 

Después de que el proceso esta daemonizado comienza la fase de inicializacion, para esto se crea el planificador y se lee el archivo de configuración insertando en el almacén de tareas del planificador cada prueba a ejecutar, para esto primero hay que importar el código de cada prueba a través del manejador de plugins.

A este punto las pruebas están planificadas tentativamente y cargadas en memoria pero solo serán ejecutadas después de que se inicie el planificador.

Al iniciar el planificador este pasa a ejecutarse como un subproceso y se encarga de iniciar las tareas en el momento justo. Cuando el planificador inicia una tarea se la pasa al ejecutor en este caso un grupo de subprocesos previamente inicializados, cuando un subproceso termina de ejecutar una tarea informa al planificador, esto con la finalidad de implementar politicas para limitar la cantidad de tareas del mismo tipo que se estan ejecutando simultaneamente.

El hilo principal revisa periódicamente el archivo de configuración y lo compara con el almacen de tareas, existen tres tipos de cambios relevantes: (1) una prueba se ha insertado en la configuracion y debe cargarse a memoria y planificarse (2) una prueba se ha eliminado y debe ser eliminada de la planificacion (3) el intervalo entre pruebas de una prueba ha cambiado y debe replanificarse.

El monitor solo puede detenerse a través de una señal del sistema operativo, en este caso SIGTERM, el cliente utiliza el archivo pid para determinar el id del proceso y enviar la señal. El manejador de excepciones del monitor entonces inicia una secuencia de apagado, deteniendo las pruebas, apagando el planificador y desbloqueado el archivo .pid.

Esta secuencia de actividades puede verse en la figura \ref{fig:tentacle-activity}.

\begin{figure}
\centering
\includegraphics[width=0.9\linewidth]{img/tentacle-activity}
\caption{Diagram de actividades de Tentacle}
\label{fig:tentacle-activity}
\end{figure}


\section{Componentes}

\subsection{Cliente}

El cliente de Octopus Tentacle es el programa encargado de iniciar o detener la ejecución del monitor en modo daemon y funge como interfaz entre el usuario y monitor.

Se puede invocar el cliente con los siguientes comandos:

% Please add the following required packages to your document preamble:
% \usepackage[table,xcdraw]{xcolor}
% If you use beamer only pass "xcolor=table" option, i.e. \documentclass[xcolor=table]{beamer}

\begin{table}[h!]
	\centering
	\label{my-label}
	\begin{tabular}{p{2cm}p{13cm}}
		\rowcolor{light-gray} Comando & Descripción \\ 
		\hline start & Inicia el monitor como un proceso daemon, falla si el archivo .pid ya existe (el monitor se esta ejecutando) \\ 
		\hline stop & Detiene el monitor enviando la señal SIGTERM al proceso daemon, falla si el archivo pid no existe (el monitor no se esta ejecutando) \\ 
		\hline 
	\end{tabular} 
	\caption{Comandos del cliente Octopus Tentacle}
\end{table}

\subsection{Hilo Principal}

El hilo principal de ejecución es el punto de partida desde el momento en que el proceso ya se ha convertido en un daemon, se encarga de inicializar el planificador a partir del archivo de configuración y se asegura de mantener el estado del planificador al día en caso de que se observen cambios en el mismo. 

\subsection{Manejador de plugins}

Este modulo contiene la lógica para cargar plugins de forma dinámica, cada plugin se identifica a través de un "nombre de modulo" único, si no se encuentra un paquete que coincida con dicho nombre se escribe un mensaje de error en la bitácora y se omite esta entrada.

El único requisito para que un modulo sea un plugin valido es que este implemente una función "run" que sirva como punto de partida para una prueba. 

\subsection{Planificador}

Para la implementación del planificador se hizo uso de APScheduler, una biblioteca que permite ejecutar de forma periódica código python; el planificador se puede ejecutar como un subproceso de modo que es posible agregar, eliminar y re-planificar tareas en cualquier momento desde el hilo principal de la aplicación. 

APScheduler consiste de un conjunto de componentes configurables que se pueden extender o re-usar para obtener cualquier comportamiento deseado, a continuación se explica su funcionamiento y como se usaron en el marco de esta aplicación.

\subsubsection{Triggers (Gatillos)}

Los triggers contienen la lógica para determinar en que momento se debe ejecutar una tarea, la biblioteca incluye un trigger en intervalos periódicos que se ha usado para esta aplicación.  

\subsubsection{Executors (Ejecutores)}

El ejecutor es el ente encargado de llevar a cabo la ejecución de las tareas, en nuestro caso se ha hecho uso de un grupo de subprocesos (thread pool), la cantidad de hilos en el grupo esta dado por el numero de pruebas que estaremos ejecutando de modo que siempre se tenga al menos un hilo disponible cuando se inicia una prueba. 

\subsubsection{Almacén de tareas (Job store)}

El almacén de tareas guarda las tareas planificadas, el comportamiento por defecto es guardar las tareas en memoria, pero existen distintos tipos de almacenes como redis (ver sección \ref{sub:redis}) y bases de datos; el comportamiento por defecto es preferido ya que solo estaremos manejando un conjunto pequeño de tareas y no es necesario ningún tipo de persistencia en caso de que el monitor se detenga.

\subsection{Almacenamiento Compartido}

El almacenamiento compartido se encarga de alojar el archivo de configuración del monitor así como los resultados de las pruebas, por cada prueba que se esté ejecutando se crea una carpeta donde se alojan sus respectivos archivos de trazas.

Para mantener el numero de archivos en el almacenamiento compartido razonablemente pequeño se crea para cada enlace un archivo por hora y todas las trazas que se generen en ese periodo se anexan al archivo correspondiente; mientras el costo de alojar archivos en la nube no depende del numero de archivos sino del espacio total de disco en uso, existe un limite de peticiones diarias por usuario que debemos evitar superar. Este tema se explicará a profundidad en la sección \ref{fig:sub:sincronizacion}.

El trabajo de mantener el almacenamiento compartido sincronizado con la nube se delega a una aplicación de terceros, esto no solo facilita el desarrollo de la aplicación, que sencillamente guarda los archivos en disco, sino que ademas permite cambiar con mucha facilidad el servicio de almacenamiento en la nube que se esté usando con mínimos cambios al monitor.

\section{Estructura del archivo de configuración}

El archivo de configuración determina el comportamiento del monitor de red tentacle, un requisito primordial de este archivo es que sea sencillo de leer y modificar tanto por la aplicación web como el propio monitor, por esto se eligió el formato json, que puede ser decodificado de forma trivial a estructuras de datos python. 

El archivo de configuración consiste de un diccionario que tiene la siguiente estructura:

\begin{lstlisting}
{
	"sleep time": sleep_time_1,
	"tests":{
		"test_1":{
			"parameter_1":value_1,
			"parameter_2":value_2,
			...
		},
		"test_2":{
			"parameter_1":value_1,
			"parameter_2":value_2,
			...
		},
		...
	},
	"links":{
		"link_1":{
			"status":true|false,
			"ip":"ip_1",
			"id":id_1
		},
		"link_2":{
			"status":true|false,
			"ip":"ip_2",
			"id":id_2
		},
		...
	},
	"id":2
}
\end{lstlisting}

Como se puede observar, el diccionario tiene las siguientes entradas:
	
\begin{itemize}
\item{\textbf{sleep time:} determina el tiempo que el hilo principal del monitor espera antes de verificar si hay cambios en el archivo de configuración}
\item{\textbf{tests:} un diccionario cuyas claves son las pruebas a ejecutar, los valores son a su vez diccionarios con los parámetros de las pruebas}
\item{\textbf{links:} la lista de los enlaces monitoreados, cada enlace es a su vez un diccionario con las siguientes entradas:
	\begin{itemize}
		\item{\textbf{status:} determina si se deben realizar pruebas sobre este enlace.}
		\item{\textbf{ip:} dirección ip de enlace.}
		\item{\textbf{id:} identificador único del enlace .}
	\end{itemize}
	
	}
\item{\textbf{id:} el identificador único del monitor }
\end{itemize}


\section{Pruebas Implementadas}

Gracias a la arquitectura de Tentacle, implementar una prueba es tan sencillo como crear un paquete e implementar la función "run" en el archivo init.py, todas las pruebas implementadas hasta ahora comparten una flujo de ejecución similar:
\begin{enumerate}
	\item{Se lee el archivo de configuración}
	\item{Se obtienen los enlaces a monitorear y los parámetros globales}
	\item{Por cada enlace a monitorear se crea un hilo donde se ejecutará la prueba en sí.}
	\item{Se leen los parámetros específicos al enlace (si los hay)}
	\item{Se ejecuta un comando externo externo como ping o traceroute o se usa una biblioteca python para evaluar alguna métrica del enlace.}
	\item{(opcional) si se ejecuta un comando externo se hace un parsing para extraer los resultados relevantes de la salida del programa}
	\item{Se guardan los resultados en un archivo de trazas; generalmente el resultado de una prueba está representado por una linea en archivo de trazas, sin embargo el desarrollador tiene libertad total sobre el formato que utilice}
\end{enumerate}

Las pruebas implementadas hasta ahora no inyectan una cantidad de trafico considerable a la red por lo que ejecutarlas en paralelo para cada enlace monitoreado no debería afectar los resultados, sin embargo también es posible implementar pruebas que se ejecuten en secuencia esto es especialmente útil si se desea medir, por ejemplo, el throughput del enlace y se desea minimizar el efecto de otros flujos de datos en la red.

\subsection{Ping}

Esta prueba hace uso del comando ping para obtener datos de la latencia en un enlace, como ya se menciono en la sección \ref{sub:ping} ping viene incluido en todas las distribuciones de linux por lo que no es necesario instalar ninguna dependencia o programa externo.

La prueba consiste en ejecutar el comando ping para cada uno de los enlaces monitoreados, ejecutamos el comando con la opción -D para que ping imprima cada resultado de latencia con una marca de tiempo entre corchetes, un ejemplo de la salida de ping se puede ver en la figura \ref{fig:ping-out}. 

Es muy sencillo extraer los datos relevantes de la salida de ping, para esto recorremos la salida descartando las lineas que no comiencen con el carácter '[', separamos la salida en palabras, la palabra en la posición 0 corresponde a la marca de tiempo, luego buscamos las palabras que comiencen por "icmp\_seq o icmp\_req y time" para obtener numero de secuencia icmp y tiempo de ida y vuelta respectivamente.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.9\linewidth]{img/ping-out}
	\caption{Ping output}
	\label{fig:ping-out}
\end{figure}

Independientemente del número de sondas que se envíen elegiremos solo un resultado de latencia por prueba (la mediana), si para una prueba no se obtiene ninguna respuesta entonces guardamos una traza con rtt=-1, indicando que el enlace está inactivo o el nodo está rechazando el protocolo.

\begin{table}[h]
	\centering
	\label{table:ping-parameters}
	\begin{tabular}{rp{2cm}p{9cm}}
		\rowcolor{light-gray} 
		Parametro              &  Tipo & Descripcion                                                                \\ \hline
		Numero de sondas       & Entero                      & Número de sondas icmp a enviar.                                            \\ \hline
		Timeout                & Float                       & Tiempo a esperar por una respuesta antes de asumir una sonda como perdida. \\ \hline
		Intervalo entre sondas & Float                       & Tiempo entre el envío de cada sonda individual.                           
	\end{tabular}
		\caption{Parametros de la prueba ping}
\end{table}

\subsection{Httping}

Esta prueba usa el protocolo HTTP para hacer un HEAD Request y obtener el tiempo de respuesta y código de estatus HTTP, a diferencia de la prueba esta no ejecuta un comando externo sino que llama a una función de la biblioteca 'requets' que hace la petición directamente por lo que no es necesario ningún tipo de parsing. 

La tabla \ref{table:httping-parameters} muestra los parámetros de la prueba httping, note que los parámetros path y port son específicos a cada enlace, los parámetros de este tipo se guardan en el archivo de configuración uniendo el nombre del parámetro y el id del enlace usando guión bajo como carácter de separación, un ejemplo del archivo de configuración para un monitor ejecutando esta prueba se puede ver a continuación: 

\begin{lstlisting}

{
	"sleep time":10,
	"tests":{
		"httping":{
			"port_8":80,
			"port_9":80,
			"path_8":"",
			"path_9":"/octopusmonitor/",
			"path_7":"",
			"interval":300,
			"port_7":80,
			"timeout":5
		}
	},
	"links":{
		"RESIDE":{
			"status":true,
			"ip":"150.185.138.59",
			"id":9
		},
		"ULA Site":{
			"status":true,
			"ip":"150.185.168.156",
			"id":8
		},
		"Saber ULA":{
			"status":true,
			"ip":"190.168.5.17",
			"id":7
		}
	},
	"id":2
}

\end{lstlisting}

\begin{table}[h]
	\centering
	\label{table:httping-parameters}
	\begin{tabular}{rp{2cm}p{9cm}}
		\rowcolor{light-gray} 
		Parametro              &  Tipo & Descripcion                                                                \\ \hline
		Timeout       & Float                      & Tiempo a esperar por una respuesta                                        \\ \hline
		Path                & String                       & Cadena de caracteres que se adjunta al ip o nombre de dominio del enlace, especialmente útil para probar servicios específicos de una aplicación o servicio web.. \\ \hline
		Port & Entero                       & Espeficia el puerto al que se envía la peticion HTTP.                           
	\end{tabular}
	\caption{Parametros de la prueba ping}
\end{table}


\subsection{Traceroute}

Esta prueba ejecuta el comando traceroute para obtener la ruta entre un par de nodos a través de una red ip, llamamos ruta a una secuencia de saltos (hops) que hace un paquete al atravesar un enrutador. 

El comando traceroute imprime la ruta como una lista ordenada donde cada linea representa un salto, con su dirección ip, nombre de dominio y latencia, dependiendo del numero de sondas que se estén enviando por salto pueden existir casos en que se obtenga respuesta de mas de una dirección ip, este comportamiento se puede ver en la figura \ref{fig:traceroute-out} en el salto 9 se observa que obtenemos una respuesta de la dirección ip 154.54.31.230 y dos de 154.54.47.154 

\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{img/traceroute-out-white.png}
	\caption{Salida del comando traceroute}
	\label{fig:traceroute-out}
\end{figure}


A partir de la salida de traceroute se debe obtener una estructura de datos que facilite el análisis de la ruta, para esto se usó el modulo tracerouteparser.py\footnote{tracerouteparser.py es cortesia del proyecto Netalyzr: http://netalyzr.icsi.berkeley.edu}, que extrae la información de la cabecera (ip destino y nombre de dominio), asi como una lista de hops (saltos), cada hop es a su vez una lista de probes (sondas), cada sonda tiene dirección ip, nombre de dominio, rtt y anotaciones; ya que el ip destino es conocido, solo se guarda en el archivo de trazas la lista de saltos en formato json. 

El formato esta compuesto de la siguiente manera:

\lstset{
	numbers=left,
	stepnumber=1,    
	firstnumber=1,
	numberfirstline=true,
	numberstyle=\tiny,
	basicstyle =\small
}

\begin{lstlisting}][h,frame=single]
[
	[
		{
			"anno": anno_1,
			"rtt": rtt_1,
			"ipaddr": ipaddr_1,
			"name": name_1
		},
		{
			"anno":  anno_2,
			"rtt": rtt_2,
			"ipaddr": ipaddr_2,
			"name": name_2
		},
		...
	],
	...
]
\end{lstlisting}

Cada vez que se realiza una prueba con traceroute se anexa al archivo de trazas una entrada con la marca de tiempo de inicio de la prueba, un carácter de separación y luego el formato json antes mostrado. 

Las parámetros de esta prueba son los siguientes:

\begin{table}[h]
	\centering
	\begin{tabular}{lll}
		\rowcolor[HTML]{C0C0C0} 
		Parametro        & {\color[HTML]{333333} Tipo} & Descripcion                                                           \\ \hline
		Numero de sondas & Entero                      & Número de sondas a enviar por cada valor de TTL.                      \\ \hline
		TTL Maximo       & Entero                      & Numero maximo de saltos antes de asumir que el nodo no es alcanzable. \\ \hline
	\end{tabular}
		\caption{Parametros de la prueba con traceroute}
		\label{tab:traceroute-params}
\end{table}

\section{Casos de uso}

Ya que el monitor de red Tentacle funciona de forma automatizada y todas las acciones de configuración y visualización de los datos recolectados por el se realizan en la aplicación web, solo se tienen dos casos de uso para el monitor.

\begin{table}[H]
	\caption{Caso de uso – Iniciar monitor}
	\begin{center}
		\begin{tabular}{r|p{2cm}p{8cm}}
			\textbf{\textit{MU-01}} & \multicolumn{2}{l}{\textit{Iniciar monitor}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario desea iniciar el monitor de red tentacle.}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario invoca el cliente con el comando "start". \\
			& 2 & El cliente crea el proceso daemon y retorna. \\
			% Linea de Secuencia excepciones
			\multirow{2}{*}{\textbf{\textit{Excepciones}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 3 & Si el archivo pid existe entonces el cliente muestra un mensaje de error indicando que el monitor ya se esta ejecutando. \\
		\end{tabular}
	\end{center}
\end{table}


\begin{table}[H]
	\caption{Caso de uso – Detener monitor}
	\begin{center}
		\begin{tabular}{r|p{2cm}p{8cm}}
			\textbf{\textit{AD-01}} & \multicolumn{2}{l}{\textit{Detener monitor}}\\
			\hline
			% Linea de descripción 
			\textbf{\textit{Descripción}} & \multicolumn{2}{p{10cm}}{El usuario desea detener el monitor que se esta ejecutando en modo daemon.}\\
			% Linea de Secuencia normal
			\multirow{2}{*}{\textbf{\textit{Secuencia normal}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 1 & El usuario invoca el cliente con el comando "stop". \\
			& 2 & El cliente abre el archivo pid y envía la señal SIGTERM al proceso daemon. \\
			& 3 & El monitor maneja la excepción deteniendo su ejecución. \\
			% Linea de Secuencia excepciones
			\multirow{3}{*}{\textbf{\textit{Excepciones}}} & \cellcolor{light-gray}\textbf{Paso} & \cellcolor{light-gray}\textbf{Acción} \\
			& 2 & Si el valor ingresado no es un email, el sistema informa del error. \\
			& 2 & Si el valor está vacío, el sistema informa del error. \\
		\end{tabular}
	\end{center}
\end{table}

\chapter{Aplicación Web "Optopus Monitor"}

\section{Diseño del sistema}

\subsection{Arquitectura}

\subsection{Estructura de la base de datos}

\subsection{Flujo de navegacion}

\subsection{Diseño de Pantallas}

\section{Componentes}

\subsection{Recolector de datos}

\subsection{Generación de visualizaciones}

\subsubsection{Cálculo de Mapas de Calor de RTT}

\subsubsection{Cálculo de horas activas}

\subsubsection{Cálculo de días activos}

\subsubsection{Cálculo de periodos de actividad continúa}

\section{Casos de Uso}

\section{Caching de gráficas}

\section{Pruebas de Rendimiento}

\chapter{Framework de integración de pruebas}

\chapter{Conclusiones y Recomendaciones}



% ***************************************************************** %
% FIN DE estructura tentativa de la Propuesta
% ***************************************************************** %

% Estilo de la bibliografï¿½a
\bibliographystyle{ieeetr}

% ***************************************************************** %
% Para agregar toda la bibliografia del archivo .bib
% solo descomente el siguiente comando
% ***************************************************************** %
\nocite{*}
% ***************************************************************** %
% Nombre del archivo con extensiï¿½n .bib en donde se almacena la bibliografï¿½a
\bibliography{bib-tesis}

% ***************************************************************** %
% FIN DE
% Cuerpo
% ***************************************************************** %

\end{document}
